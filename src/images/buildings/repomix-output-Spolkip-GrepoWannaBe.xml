This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
public/
  index.html
  manifest.json
src/
  components/
    alliance/
      AllianceCreation.js
      AllianceDiplomacy.js
      AllianceMembers.js
      AllianceOverview.js
      AllianceResearch.js
    chat/
      Chat.css
      Chat.js
    city/
      AcademyMenu.js
      AdminCheatMenu.js
      BarracksMenu.js
      BuildingDetailsModal.js
      BuildingLayout.json
      BuildingSpot.js
      BuildQueue.js
      CaveMenu.js
      CityHeader.js
      CityModals.js
      Cityscape.js
      CityViewContent.js
      DivinePowers.css
      DivinePowers.js
      HospitalMenu.js
      ResearchQueue.js
      ResourceBar.js
      SenateView.js
      ShipyardMenu.js
      TempleMenu.js
      UnitQueue.js
      WorshipDisplay.js
    icons/
      EyeIcon.js
      EyeOffIcon.js
    map/
      AllianceModal.css
      AllianceModal.js
      Countdown.js
      FarmingVillageModal.js
      MapGrid.js
      MapModals.js
      MovementIndicator.js
      MovementItem.js
      MovementModal.js
      MovementsPanel.js
      OtherCityModal.js
      ScoutPanel.js
      SidebarNav.js
      Tiles.js
      TopBar.js
      TradePanel.js
    messaging/
      MessagesView.css
      MessagesView.js
    profile/
      ProfileView.css
      ProfileView.js
    shared/
      LoadingScreen.js
      Modal.js
      SettingsModal.js
    AuthScreen.js
    CityFounding.js
    CityView.js
    Game.js
    MapView.js
    ReportsView.js
    SelectionScreen.js
    SideInfoPanel.js
    Temple.js
    TroopDisplay.js
    WorldSelectionScreen.js
  contexts/
    AuthContext.js
    GameContext.js
  firebase/
    config.js
  gameData/
    allianceResearch.json
    BuildingLayout.json
    buildings.json
    gods.json
    research.json
    units.json
  hooks/
    useCityState.js
    useMapActions.js
    usemapdatapls.js
    useMapInteraction.js
    useModalState.js
  utils/
    combat.js
    travel.js
    worldGeneration.js
  App.js
  index.css
  index.js
.firebaserc
.gitignore
firebase.json
package.json
tailwind.config.js
todo.txt
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="public/index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="A city-building strategy game created with React and Firebase."
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>Grepolike</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>
</file>

<file path="public/manifest.json">
{
  "short_name": "Grepolike",
  "name": "Grepolis Clone - A City-Building Game",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}
</file>

<file path="src/components/alliance/AllianceCreation.js">
// src/components/alliance/AllianceCreation.js
import React, { useState } from 'react';
import { useGame } from '../../contexts/GameContext';

const AllianceCreation = ({ onClose }) => {
    const { createAlliance } = useGame();
    const [name, setName] = useState('');
    const [tag, setTag] = useState('');

    const handleCreate = () => {
        if (name.trim() && tag.trim()) {
            createAlliance(name.trim(), tag.trim());
            onClose();
        }
    };

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            <div className="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md border-2 border-gray-600 text-white" onClick={e => e.stopPropagation()}>
                <div className="flex justify-between items-center mb-4">
                    <h3 className="text-xl font-bold mb-2">Create an Alliance</h3>
                    <button onClick={onClose} className="text-gray-400 text-3xl leading-none hover:text-white">&times;</button>
                </div>
                <div className="flex flex-col gap-4">
                    <input
                        type="text"
                        value={name}
                        onChange={(e) => setName(e.target.value)}
                        placeholder="Alliance Name"
                        className="w-full bg-gray-900 p-2 rounded"
                    />
                    <input
                        type="text"
                        value={tag}
                        onChange={(e) => setTag(e.target.value)}
                        placeholder="Alliance Tag (e.g., ABC)"
                        maxLength="5"
                        className="w-full bg-gray-900 p-2 rounded"
                    />
                    <button onClick={handleCreate} className="btn btn-confirm">Create Alliance</button>
                </div>
            </div>
        </div>
    );
};

export default AllianceCreation;
</file>

<file path="src/components/alliance/AllianceDiplomacy.js">
import React from 'react';
import { useGame } from '../../contexts/GameContext';

const AllianceDiplomacy = () => {
    const { playerAlliance } = useGame();

    return (
        <div>
            <h3 className="text-xl font-bold mb-2">Diplomacy</h3>
            <div className="grid grid-cols-2 gap-4">
                <div>
                    <h4 className="font-bold">Allies</h4>
                    <ul>
                        {playerAlliance.diplomacy?.allies?.map(ally => <li key={ally.id}>{ally.name}</li>) || <li>None</li>}
                    </ul>
                </div>
                <div>
                    <h4 className="font-bold">Enemies</h4>
                    <ul>
                        {playerAlliance.diplomacy?.enemies?.map(enemy => <li key={enemy.id}>{enemy.name}</li>) || <li>None</li>}
                    </ul>
                </div>
            </div>
            {/* Add forms for leaders to manage diplomacy */}
        </div>
    );
};

export default AllianceDiplomacy;
</file>

<file path="src/components/alliance/AllianceMembers.js">
import React from 'react';
import { useGame } from '../../contexts/GameContext';

const AllianceMembers = () => {
    const { playerAlliance } = useGame();

    return (
        <div>
            <h3 className="text-xl font-bold mb-2">Members</h3>
            <ul>
                {playerAlliance.members.map(member => (
                    <li key={member.uid} className="flex justify-between items-center p-2 bg-gray-700 rounded mb-1">
                        <span>{member.username}</span>
                        <span>{member.rank}</span>
                    </li>
                ))}
            </ul>
        </div>
    );
};

export default AllianceMembers;
</file>

<file path="src/components/alliance/AllianceOverview.js">
import React from 'react';
import { useGame } from '../../contexts/GameContext';

const AllianceOverview = () => {
    const { playerAlliance } = useGame();

    return (
        <div>
            <h3 className="text-xl font-bold mb-2">Alliance Description</h3>
            <p className="text-gray-400">{playerAlliance.description || 'No description provided.'}</p>
            {/* Add more overview details here, like total points, member count, etc. */}
        </div>
    );
};

export default AllianceOverview;
</file>

<file path="src/components/alliance/AllianceResearch.js">
import React, { useState } from 'react';
import { useGame } from '../../contexts/GameContext';
import allianceResearch from '../../gameData/allianceResearch.json';

const AllianceResearch = () => {
    const { playerAlliance, donateToAllianceResearch } = useGame();
    const [donation, setDonation] = useState({ wood: 0, stone: 0, silver: 0 });
    const [selectedResearch, setSelectedResearch] = useState(null);

    const handleDonationChange = (e) => {
        setDonation({ ...donation, [e.target.name]: parseInt(e.target.value) || 0 });
    };

    const handleDonate = (researchId) => {
        donateToAllianceResearch(researchId, donation);
        setDonation({ wood: 0, stone: 0, silver: 0 });
    };

    return (
        <div>
            <h3 className="text-xl font-bold mb-2">Alliance Research</h3>
            <div className="grid grid-cols-2 gap-4">
                {Object.entries(allianceResearch).map(([id, research]) => {
                    const level = playerAlliance.research[id]?.level || 0;
                    const progress = playerAlliance.research[id]?.progress || {};
                    const cost = {
                        wood: Math.floor(research.baseCost.wood * Math.pow(research.costMultiplier, level)),
                        stone: Math.floor(research.baseCost.stone * Math.pow(research.costMultiplier, level)),
                        silver: Math.floor(research.baseCost.silver * Math.pow(research.costMultiplier, level)),
                    };

                    return (
                        <div key={id} className="p-4 bg-gray-700 rounded">
                            <h4 className="font-bold">{research.name} (Level {level})</h4>
                            <p className="text-sm text-gray-400">{research.description}</p>
                            {level < research.maxLevel && (
                                <>
                                    <div className="my-2">
                                        <p>Progress:</p>
                                        <p className="text-xs">Wood: {progress.wood || 0} / {cost.wood}</p>
                                        <p className="text-xs">Stone: {progress.stone || 0} / {cost.stone}</p>
                                        <p className="text-xs">Silver: {progress.silver || 0} / {cost.silver}</p>
                                    </div>
                                    <button onClick={() => setSelectedResearch(id)} className="btn btn-sm btn-primary">Donate</button>
                                </>
                            )}
                        </div>
                    );
                })}
            </div>

            {selectedResearch && (
                <div className="mt-4 p-4 bg-gray-800 rounded">
                    <h4 className="font-bold">Donate to {allianceResearch[selectedResearch].name}</h4>
                    <div className="flex gap-2 my-2">
                        <input type="number" name="wood" value={donation.wood} onChange={handleDonationChange} className="w-full bg-gray-900 p-1 rounded" placeholder="Wood" />
                        <input type="number" name="stone" value={donation.stone} onChange={handleDonationChange} className="w-full bg-gray-900 p-1 rounded" placeholder="Stone" />
                        <input type="number" name="silver" value={donation.silver} onChange={handleDonationChange} className="w-full bg-gray-900 p-1 rounded" placeholder="Silver" />
                    </div>
                    <button onClick={() => handleDonate(selectedResearch)} className="btn btn-confirm">Confirm Donation</button>
                    <button onClick={() => setSelectedResearch(null)} className="btn btn-secondary ml-2">Cancel</button>
                </div>
            )}
        </div>
    );
};

export default AllianceResearch;
</file>

<file path="src/components/chat/Chat.css">
.chat-toggle-button {
    position: fixed;
    bottom: 20px;
    left: 20px;
    z-index: 1000;
    background-color: #4a5568;
    color: white;
    border: 2px solid #718096;
    border-radius: 50%;
    width: 60px;
    height: 60px;
    font-size: 24px;
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    transition: all 0.2s ease-in-out;
}

.chat-toggle-button:hover {
    background-color: #2d3748;
    transform: scale(1.1);
}

.chat-window {
    position: fixed;
    width: 380px;
    height: 500px;
    background-color: #2d3748;
    border-radius: 10px;
    box-shadow: 0 10px 25px rgba(0,0,0,0.5);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    z-index: 1000;
    border: 1px solid #4a5568;
}

.chat-header {
    background-color: #1a202c;
    color: #a0aec0;
    padding: 10px 15px;
    font-weight: bold;
    cursor: move;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid #4a5568;
}

.chat-header .close-btn {
    background: none;
    border: none;
    color: #a0aec0;
    font-size: 24px;
    cursor: pointer;
}

.messages-container {
    flex-grow: 1;
    overflow-y: auto;
    padding: 15px;
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.message {
    padding: 8px 12px;
    border-radius: 18px;
    max-width: 85%;
    word-wrap: break-word;
    display: flex;
    flex-direction: column;
}

.message .author {
    font-weight: bold;
    font-size: 0.9em;
    margin-bottom: 4px;
    color: #a0aec0;
}

.message p {
    margin: 0;
    color: #edf2f7;
}

.message.sent {
    background-color: #3182ce;
    align-self: flex-end;
    border-bottom-right-radius: 4px;
}
.message.sent .author {
    color: #bee3f8;
}

.message.received {
    background-color: #4a5568;
    align-self: flex-start;
    border-bottom-left-radius: 4px;
}
.message.received .author {
    color: #e2e8f0;
}

.send-message-form {
    display: flex;
    padding: 10px;
    border-top: 1px solid #4a5568;
    background-color: #1a202c;
}

.send-message-form input {
    flex-grow: 1;
    padding: 10px 15px;
    border-radius: 20px;
    border: 1px solid #4a5568;
    background-color: #2d3748;
    color: white;
    margin-right: 10px;
    outline: none;
}
.send-message-form input:focus {
    border-color: #4299e1;
}

.send-message-form button {
    padding: 10px 20px;
    border-radius: 20px;
    border: none;
    background-color: #4299e1;
    color: white;
    cursor: pointer;
    font-weight: bold;
    transition: background-color 0.2s;
}

.send-message-form button:hover {
    background-color: #3182ce;
}
</file>

<file path="src/components/chat/Chat.js">
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { db } from '../../firebase/config';
import { collection, addDoc, query, orderBy, onSnapshot, serverTimestamp } from 'firebase/firestore';
import { useAuth } from '../../contexts/AuthContext';
import './Chat.css';

const Chat = ({ worldId, isVisible, onClose }) => {
    const { currentUser, userProfile } = useAuth();
    const [messages, setMessages] = useState([]);
    const [newMessage, setNewMessage] = useState('');
    const messagesEndRef = useRef(null);

    // Draggable state
    const [position, setPosition] = useState({ x: 20, y: window.innerHeight - 540 });
    const [isDragging, setIsDragging] = useState(false);
    const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
    const chatWindowRef = useRef(null);


    useEffect(() => {
        if (!worldId) return;

        const q = query(collection(db, 'worlds', worldId, 'chat'), orderBy('timestamp', 'asc'));
        const unsubscribe = onSnapshot(q, (querySnapshot) => {
            const msgs = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            setMessages(msgs);
        });

        return () => unsubscribe();
    }, [worldId]);

    useEffect(() => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    }, [messages]);

    const handleSendMessage = async (e) => {
        e.preventDefault();
        if (newMessage.trim() === '' || !worldId || !currentUser || !userProfile) return;

        await addDoc(collection(db, 'worlds', worldId, 'chat'), {
            text: newMessage,
            timestamp: serverTimestamp(),
            uid: currentUser.uid,
            authorName: userProfile.username,
        });

        setNewMessage('');
    };
    
    const handleMouseDown = (e) => {
        if (e.target.classList.contains('chat-header')) {
            setIsDragging(true);
            setDragStart({
                x: e.clientX - position.x,
                y: e.clientY - position.y,
            });
        }
    };

    const handleMouseMove = useCallback((e) => {
        if (isDragging) {
            setPosition({
                x: e.clientX - dragStart.x,
                y: e.clientY - dragStart.y,
            });
        }
    }, [isDragging, dragStart, setPosition]);

    const handleMouseUp = () => {
        setIsDragging(false);
    };

    useEffect(() => {
        if (isDragging) {
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp);
        } else {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        }

        return () => {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        };
    }, [isDragging, handleMouseMove]);


    if (!isVisible) return null;

    return (
        <div 
            className="chat-window" 
            ref={chatWindowRef}
            style={{ top: `${position.y}px`, left: `${position.x}px` }}
        >
            <div className="chat-header" onMouseDown={handleMouseDown}>
                <h4>World Chat</h4>
                <button onClick={onClose} className="close-btn">&times;</button>
            </div>
            <div className="messages-container">
                {messages.map((msg) => (
                    <div key={msg.id} className={`message ${msg.uid === currentUser.uid ? 'sent' : 'received'}`}>
                        <span className="author">{msg.authorName}:</span>
                        <p>{msg.text}</p>
                    </div>
                ))}
                <div ref={messagesEndRef} />
            </div>
            <form onSubmit={handleSendMessage} className="send-message-form">
                <input
                    type="text"
                    value={newMessage}
                    onChange={(e) => setNewMessage(e.target.value)}
                    placeholder="Type a message..."
                />
                <button type="submit">Send</button>
            </form>
        </div>
    );
};

export default Chat;
</file>

<file path="src/components/city/AcademyMenu.js">
// src/components/city/AcademyMenu.js
import React from 'react';
import researchConfig from '../../gameData/research.json';
import ResearchQueue from './ResearchQueue'; // Import the new ResearchQueue

const formatTime = (seconds) => {
    if (seconds < 0) seconds = 0;
    const h = Math.floor(seconds / 3600).toString().padStart(2, '0');
    const m = Math.floor((seconds % 3600) / 60).toString().padStart(2, '0');
    const s = Math.floor(seconds % 60).toString().padStart(2, '0');
    return `${h}:${m}:${s}`;
};

const AcademyMenu = ({ cityGameState, onResearch, onClose, researchQueue, onCancelResearch }) => { // Add researchQueue and onCancelResearch to props
    const { buildings, resources, research = {} } = cityGameState;
    const academyLevel = buildings.academy?.level || 0;

    const canAfford = (cost) => {
        return resources.wood >= cost.wood && resources.stone >= cost.stone && resources.silver >= cost.silver;
    };

    const meetsRequirements = (reqs) => {
        if (reqs.academy && academyLevel < reqs.academy) {
            return false;
        }
        if (reqs.research && !research[reqs.research]) {
            return false;
        }
        return true;
    };

    // Determine if a research is already in the queue
    const isResearchInQueue = (researchId) => {
        return (researchQueue || []).some(item => item.researchId === researchId);
    };

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            <div className="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-3xl border-2 border-gray-600 flex flex-col max-h-[90vh]" onClick={e => e.stopPropagation()}>
                <div className="flex justify-between items-center mb-4">
                    <h3 className="font-title text-3xl text-white">Academy (Level {academyLevel})</h3>
                    <button onClick={onClose} className="text-gray-400 text-3xl leading-none hover:text-white">&times;</button>
                </div>
                
                {/* Render the ResearchQueue here */}
                <ResearchQueue researchQueue={researchQueue} onCancel={onCancelResearch} />

                <div className="overflow-y-auto space-y-4 pr-2">
                    {Object.entries(researchConfig).map(([id, config]) => {
                        const isResearched = research[id];
                        const requirementsMet = meetsRequirements(config.requirements);
                        const affordable = canAfford(config.cost);
                        const inQueue = isResearchInQueue(id); // Check if in queue

                        let button;
                        if (isResearched) {
                            button = <button disabled className="btn btn-disabled w-full py-2 mt-2">Completed</button>;
                        } else if (inQueue) { // New condition for in queue
                            button = <button disabled className="btn btn-disabled w-full py-2 mt-2">In Queue</button>;
                        } else if (!requirementsMet) {
                            let reqText = `Requires Academy Lvl ${config.requirements.academy || 0}`;
                            if (config.requirements.research) {
                                reqText += ` & ${researchConfig[config.requirements.research].name}`;
                            }
                            button = <button disabled className="btn btn-disabled w-full py-2 mt-2">{reqText}</button>;
                        } else {
                            button = <button onClick={() => onResearch(id)} disabled={!affordable || researchQueue.length >= 5} className={`btn ${affordable && researchQueue.length < 5 ? 'btn-upgrade' : 'btn-disabled'} w-full py-2 mt-2`}>
                                {researchQueue.length >= 5 ? 'Queue Full' : 'Research'}
                            </button>;
                        }

                        return (
                            <div key={id} className={`p-4 rounded-lg flex justify-between items-center ${isResearched ? 'bg-green-900/50' : 'bg-gray-700'} ${inQueue ? 'opacity-80' : ''}`}>
                                <div>
                                    <h4 className="text-xl font-bold text-yellow-300">{config.name}</h4>
                                    <p className="text-sm text-gray-400">{config.description}</p>
                                    <div className="text-xs text-gray-300 mt-2">
                                        <span>Cost: {config.cost.wood}W, {config.cost.stone}S, {config.cost.silver}Ag</span>
                                        <span className="ml-4">Time: {formatTime(config.cost.time)}</span>
                                    </div>
                                </div>
                                <div className="w-1/4 ml-4">
                                    {button}
                                </div> {/* Closing div tag added here, the extra '}' was removed */}
                            </div>
                        );
                    })}
                </div>
            </div>
        </div>
    );
};

export { AcademyMenu };
</file>

<file path="src/components/city/AdminCheatMenu.js">
// src/components/city/AdminCheatMenu.js
import React, { useState } from 'react';
import unitConfig from '../../gameData/units.json';
import researchConfig from '../../gameData/research.json'; // Import research config

const AdminCheatMenu = ({ onCheat, onClose, isInstantBuildActive }) => {
    const [amounts, setAmounts] = useState({ wood: 0, stone: 0, silver: 0, population: 0 });
    const [troop, setTroop] = useState({ unit: 'swordsman', amount: 0 });
    const [warehouseLevels, setWarehouseLevels] = useState(0);
    const [instantBuild, setInstantBuild] = useState(isInstantBuildActive);
    const [unresearchId, setUnresearchId] = useState(''); // New state for unresearch
    const [isInstantResearch, setIsInstantResearch] = useState(false); // New state for instant research
    const [isInstantUnits, setIsInstantUnits] = useState(false); // New state for instant units
    const [favorAmount, setFavorAmount] = useState(0); // New state for favor cheat


    const handleCheat = () => {
        onCheat(amounts, troop, warehouseLevels, instantBuild, unresearchId, isInstantResearch, isInstantUnits, favorAmount); // Pass new values
        onClose();
    };

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            <div className="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md border-2 border-gray-600" onClick={e => e.stopPropagation()}>
                <h3 className="font-title text-2xl text-white mb-4">Admin Cheats</h3>
                <div className="space-y-4">
                    {Object.keys(amounts).map(resource => (
                        <div key={resource} className="flex justify-between items-center">
                            <label className="text-white capitalize">{resource}</label>
                            <input
                                type="number"
                                value={amounts[resource]}
                                onChange={(e) => setAmounts(prev => ({ ...prev, [resource]: parseInt(e.target.value, 10) || 0 }))}
                                className="bg-gray-700 text-white rounded p-2 w-32"
                            />
                        </div>
                    ))}
                    <div className="flex justify-between items-center">
                        <label className="text-white capitalize">Add Troops</label>
                        <select
                            value={troop.unit}
                            onChange={(e) => setTroop(prev => ({ ...prev, unit: e.target.value }))}
                            className="bg-gray-700 text-white rounded p-2 w-32"
                        >
                            {Object.keys(unitConfig).map(unitId => (
                                <option key={unitId} value={unitId}>{unitConfig[unitId].name}</option>
                            ))}
                        </select>
                        <input
                            type="number"
                            value={troop.amount}
                            onChange={(e) => setTroop(prev => ({ ...prev, amount: parseInt(e.target.value, 10) || 0 }))}
                            className="bg-gray-700 text-white rounded p-2 w-24"
                        />
                    </div>
                    <div className="flex justify-between items-center">
                        <label className="text-white capitalize">Upgrade Warehouse</label>
                        <input
                            type="number"
                            value={warehouseLevels}
                            onChange={(e) => setWarehouseLevels(parseInt(e.target.value, 10) || 0)}
                            className="bg-gray-700 text-white rounded p-2 w-32"
                        />
                    </div>
                    {/* New Cheat: Unresearch Option */}
                    <div className="flex justify-between items-center pt-4 border-t border-gray-600">
                        <label htmlFor="unresearch" className="text-white">Unresearch:</label>
                        <select
                            id="unresearch"
                            value={unresearchId}
                            onChange={(e) => setUnresearchId(e.target.value)}
                            className="bg-gray-700 text-white rounded p-2 w-40"
                        >
                            <option value="">Select Research</option>
                            {Object.keys(researchConfig).map(researchKey => (
                                <option key={researchKey} value={researchKey}>
                                    {researchConfig[researchKey].name}
                                </option>
                            ))}
                        </select>
                    </div>
                    {/* New Cheat: Add Favor */}
                    <div className="flex justify-between items-center">
                        <label htmlFor="addFavor" className="text-white">Add Favor:</label>
                        <input
                            id="addFavor"
                            type="number"
                            value={favorAmount}
                            onChange={(e) => setFavorAmount(parseInt(e.target.value, 10) || 0)}
                            className="bg-gray-700 text-white rounded p-2 w-32"
                        />
                    </div>
                    {/* New Checkbox for Instant Build */}
                    <div className="flex justify-between items-center pt-4 border-t border-gray-600">
                        <label htmlFor="instantBuild" className="text-white capitalize">1-Second Builds</label>
                        <input
                            id="instantBuild"
                            type="checkbox"
                            checked={instantBuild}
                            onChange={(e) => setInstantBuild(e.target.checked)}
                            className="w-6 h-6 rounded"
                        />
                    </div>
                    {/* New Checkbox for Instant Research */}
                    <div className="flex justify-between items-center">
                        <label htmlFor="instantResearch" className="text-white capitalize">1-Second Research</label>
                        <input
                            id="instantResearch"
                            type="checkbox"
                            checked={isInstantResearch}
                            onChange={(e) => setIsInstantResearch(e.target.checked)}
                            className="w-6 h-6 rounded"
                        />
                    </div>
                    {/* New Checkbox for Instant Units */}
                    <div className="flex justify-between items-center">
                        <label htmlFor="instantUnits" className="text-white capitalize">1-Second Units</label>
                        <input
                            id="instantUnits"
                            type="checkbox"
                            checked={isInstantUnits}
                            onChange={(e) => setIsInstantUnits(e.target.checked)}
                            className="w-6 h-6 rounded"
                        />
                    </div>
                </div>
                <button onClick={handleCheat} className="btn btn-primary w-full py-2 mt-6">
                    Apply Cheats
                </button>
            </div>
        </div>
    );
};

export default AdminCheatMenu;
</file>

<file path="src/components/city/BarracksMenu.js">
// src/components/city/BarracksMenu.js
import React, { useState, useEffect } from 'react';
import unitConfig from '../../gameData/units.json';
import UnitQueue from './UnitQueue';
import Modal from '../shared/Modal'; // FIX: Added missing import for Modal

// Dynamically import all unit images
const unitImages = {};
const imageContext = require.context('../../images', false, /\.(png|jpe?g|svg)$/);
imageContext.keys().forEach((item) => {
    const key = item.replace('./', '');
    unitImages[key] = imageContext(item);
});

const UnitStats = ({ unit }) => (
    <div className="w-1/2 bg-gray-900 p-4 rounded-lg space-y-2">
        <h5 className="font-bold text-lg text-yellow-300 mb-3">Unit Information</h5>
        <div className="flex items-center justify-between text-sm"><span>⚔️ Attack</span><span className="font-bold">{unit.attack}</span></div>
        <div className="flex items-center justify-between text-sm"><span>🛡️ Defense</span><span className="font-bold">{unit.defense}</span></div>
        <div className="flex items-center justify-between text-sm"><span>🐎 Speed</span><span className="font-bold">{unit.speed}</span></div>
    </div>
);

const BarracksMenu = ({ resources, availablePopulation, onTrain, onClose, cityGameState, unitQueue, onCancelTrain }) => {
    const landUnits = Object.keys(unitConfig).filter(id => unitConfig[id].type === 'land');
    const [selectedUnitId, setSelectedUnitId] = useState(landUnits[0] || null);
    const [trainAmount, setTrainAmount] = useState(1);
    
    useEffect(() => {
        setTrainAmount(1);
    }, [selectedUnitId]);

    if (!selectedUnitId) {
        return (
            <Modal message="No land units available to train." onClose={onClose} />
        );
    }

    const selectedUnit = unitConfig[selectedUnitId];
    const cityUnits = cityGameState?.units || {};
    const landUnitQueue = (unitQueue || []).filter(item => unitConfig[item.unitId]?.type === 'land');

    const totalCost = {
        wood: selectedUnit.cost.wood * trainAmount,
        stone: selectedUnit.cost.stone * trainAmount,
        silver: selectedUnit.cost.silver * trainAmount,
        population: selectedUnit.cost.population * trainAmount,
    };

    const canAfford = resources.wood >= totalCost.wood &&
                    resources.stone >= totalCost.stone &&
                    resources.silver >= totalCost.silver &&
                    availablePopulation >= totalCost.population;

    const handleTrain = () => {
        if (trainAmount > 0) onTrain(selectedUnitId, trainAmount);
    };

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            <div className="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-4xl border-2 border-gray-600 flex flex-col max-h-[90vh]" onClick={e => e.stopPropagation()}>
                <div className="flex justify-between items-center mb-4">
                    <h3 className="font-title text-3xl text-white">Barracks</h3>
                    <button onClick={onClose} className="text-gray-400 text-3xl leading-none hover:text-white">&times;</button>
                </div>

                <div className="flex-grow flex gap-4 overflow-y-auto">
                    {/* Left Panel: Unit Selection */}
                    <div className="w-1/3 flex flex-col gap-2">
                        {landUnits.map(unitId => {
                            const unit = unitConfig[unitId];
                            const isSelected = selectedUnitId === unitId;
                            return (
                                <button
                                    key={unitId}
                                    onClick={() => setSelectedUnitId(unitId)}
                                    className={`flex items-center p-2 rounded border-2 transition-colors w-full ${isSelected ? 'bg-gray-600 border-yellow-500' : 'bg-gray-700 border-gray-600 hover:border-yellow-400'}`}
                                >
                                    <img src={unitImages[unit.image]} alt={unit.name} className="w-12 h-12 mr-3 object-contain" />
                                    <div>
                                        <p className="font-bold text-left text-white">{unit.name}</p>
                                        <p className="text-sm text-left text-gray-400">In City: {cityUnits[unitId] || 0}</p>
                                    </div>
                                </button>
                            );
                        })}
                    </div>

                    {/* Right Panel: Details */}
                    <div className="w-2/3 flex flex-col gap-4">
                        <div className="bg-gray-700 p-4 rounded-lg">
                            <h4 className="font-title text-2xl text-yellow-400">{selectedUnit.name}</h4>
                            <p className="text-gray-400 italic mt-1">{selectedUnit.description}</p>
                        </div>
                        <div className="flex gap-4">
                            <div className="w-1/2 bg-gray-900 p-4 rounded-lg space-y-1">
                                <h5 className="font-bold text-lg text-yellow-300 mb-2">Cost (Total)</h5>
                                <p className="text-sm text-gray-300">Wood: {selectedUnit.cost.wood} ({totalCost.wood})</p>
                                <p className="text-sm text-gray-300">Stone: {selectedUnit.cost.stone} ({totalCost.stone})</p>
                                <p className="text-sm text-gray-300">Silver: {selectedUnit.cost.silver} ({totalCost.silver})</p>
                                <p className="text-sm text-gray-300">Population: {selectedUnit.cost.population} ({totalCost.population})</p>
                                <p className="text-sm text-gray-300">Time per unit: {selectedUnit.cost.time}s</p>
                            </div>
                            <UnitStats unit={selectedUnit} />
                        </div>
                        <div className="bg-gray-700 p-4 rounded-lg flex items-center justify-between">
                            <input
                                type="number"
                                value={trainAmount}
                                onChange={(e) => setTrainAmount(Math.max(1, parseInt(e.target.value, 10) || 1))}
                                className="bg-gray-800 text-white rounded p-2 w-24"
                            />
                            <button
                                onClick={handleTrain}
                                disabled={!canAfford || (unitQueue || []).length >= 5}
                                className={`py-2 px-6 text-lg rounded-lg btn ${(canAfford && (unitQueue || []).length < 5) ? 'btn-confirm' : 'btn-disabled'}`}
                            >
                                {(unitQueue || []).length >= 5 ? 'Queue Full' : 'Train'}
                            </button>
                        </div>
                    </div>
                </div>
                
                <UnitQueue unitQueue={landUnitQueue} onCancel={onCancelTrain} />
            </div>
        </div>
    );
};

export default BarracksMenu;
</file>

<file path="src/components/city/BuildingDetailsModal.js">
import React from 'react';
import buildingConfig from '../../gameData/buildings.json';

const BuildingDetailsModal = ({ buildingId, buildingData, onClose, getProductionRates, getWarehouseCapacity, getFarmCapacity, onOpenBarracks, onOpenShipyard }) => {
    const config = buildingConfig[buildingId];
    if (!config) return null;

    const nextLevel = buildingData.level + 1;

    const isWarehouse = buildingId === 'warehouse';
    const isProductionBuilding = ['timber_camp', 'quarry', 'silver_mine'].includes(buildingId);
    const isFarm = buildingId === 'farm';
    const isBarracks = buildingId === 'barracks';
    const isShipyard = buildingId === 'shipyard';

    const getResourceType = (id) => {
        if (id === 'timber_camp') return 'wood';
        if (id === 'quarry') return 'stone';
        if (id === 'silver_mine') return 'silver';
        return '';
    };

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            <div className="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md border-2 border-gray-600" onClick={e => e.stopPropagation()}>
                <div className="flex justify-between items-start mb-4">
                    <div>
                        <h3 className="font-title text-3xl text-white">{config.name}</h3>
                        <p className="text-yellow-300 font-bold text-lg">Level {buildingData.level}</p>
                    </div>
                    <button onClick={onClose} className="text-gray-400 text-3xl leading-none hover:text-white">&times;</button>
                </div>
                <p className="text-gray-400 mt-2 mb-6">{config.description}</p>

                {isWarehouse && (
                    <div className="text-sm space-y-1 mb-6 text-gray-300">
                        <p className="font-semibold text-lg">Capacity:</p>
                        <p>Current: {getWarehouseCapacity(buildingData.level).toLocaleString()}</p>
                        <p>Next Level: {getWarehouseCapacity(nextLevel).toLocaleString()}</p>
                    </div>
                )}

                {isProductionBuilding && (
                    <div className="text-sm space-y-1 mb-6 text-gray-300">
                        <p className="font-semibold text-lg">Production (per hour):</p>
                        <p>Current: {getProductionRates({ [buildingId]: buildingData })[getResourceType(buildingId)].toLocaleString()}</p>
                        <p>Next Level: {getProductionRates({ [buildingId]: { level: nextLevel } })[getResourceType(buildingId)].toLocaleString()}</p>
                    </div>
                )}

                {isFarm && (
                    <div className="text-sm space-y-1 mb-6 text-gray-300">
                        <p className="font-semibold text-lg">Population Capacity:</p>
                        <p>Current: {getFarmCapacity(buildingData.level).toLocaleString()}</p>
                        <p>Next Level: {getFarmCapacity(nextLevel).toLocaleString()}</p>
                    </div>
                )}

                {isBarracks && (
                    <button onClick={onOpenBarracks} className="btn btn-primary w-full py-2">
                        Train Troops
                    </button>
                )}

                {isShipyard && (
                    <button onClick={onOpenShipyard} className="btn btn-primary w-full py-2">
                        Build Naval Units
                    </button>
                )}
            </div>
        </div>
    );
};

export default BuildingDetailsModal;
</file>

<file path="src/components/city/BuildingLayout.json">
[
  { "id": "city_wall", "name": "City Wall", "position": { "x": 10, "y": 1240 } },
  { "id": "senate", "name": "Senate", "position": { "x": 925, "y": 750 } },
  { "id": "timber_camp", "name": "Lumber Mill", "position": { "x": 700, "y": 850 } },
  { "id": "quarry", "name": "Stone Quarry", "position": { "x": 1150, "y": 850 } },
  { "id": "barracks", "name": "Barracks", "position": { "x": 500, "y": 950 } },
  { "id": "silver_mine", "name": "Silver Mine", "position": { "x": 925, "y": 950 } },
  { "id": "market", "name": "Market", "position": { "x": 1350, "y": 950 } },
  { "id": "warehouse", "name": "Warehouse", "position": { "x": 700, "y": 1050 } },
  { "id": "farm", "name": "Farm", "position": { "x": 1150, "y": 1050 } },
  { "id": "temple", "name": "Temple", "position": { "x": 925, "y": 1100 } },
  { "id": "cave", "name": "Cave", "position": { "x": 500, "y": 1100 } },
  { "id": "academy", "name": "Academy", "position": { "x": 1350, "y": 1100 } },
  { "id": "shipyard", "name": "Shipyard", "position": { "x": 925, "y": 1350 } }
]
</file>

<file path="src/components/city/BuildingSpot.js">
import React from 'react';

const BuildingSpot = ({ building, level, onClick, image }) => {
    const { id, name, position } = building;

    const isCityWall = id === 'city_wall';

    // Define styles based on whether it's the city wall or not
    const spotStyle = {
        top: `${position.y}px`,
        left: `${position.x}px`,
        width: isCityWall ? '2000px' : '150px',
        height: isCityWall ? '100px' : '100px', // Adjusted height for better image display
        backgroundImage: level > 0 && image ? `url(${image})` : 'none',
        backgroundSize: 'contain',
        backgroundRepeat: 'no-repeat',
        backgroundPosition: 'center',
    };

    if (level === 0) {
        return (
             <div
                className="building-spot absolute flex items-center justify-center p-2 rounded-lg cursor-pointer border-dashed border-gray-400/50 hover:border-yellow-400 hover:bg-black/20" // Removed border-2
                style={spotStyle}
                onClick={onClick}
                title={`Build ${name}`}
            >
                <span className="text-gray-400 text-sm">
                    {isCityWall ? `Build ${name}` : 'Empty Plot'}
                </span>
            </div>
        );
    }

    return (
        <div
            className="building-spot absolute flex flex-col items-center justify-center p-2 rounded-lg shadow-lg hover:bg-yellow-400/30 transition-colors duration-200 cursor-pointer" // Removed border-2 and border-yellow-600/50
            style={{
                ...spotStyle,
                backgroundColor: isCityWall ? 'rgba(100, 80, 60, 0.7)' : (image ? 'transparent' : 'rgba(139, 69, 19, 0.7)'),
            }}
            onClick={onClick}
        >
        </div>
    );
};

export default BuildingSpot;
</file>

<file path="src/components/city/BuildQueue.js">
// src/components/city/BuildQueue.js
import React, { useState, useEffect } from 'react';
import buildingConfig from '../../gameData/buildings.json';

// Dynamically import all building images
const buildingImages = {};
const buildingImageContext = require.context('../../images/buildings', false, /\.(png|jpe?g|svg)$/);
buildingImageContext.keys().forEach((item) => {
    const key = item.replace('./', '');
    buildingImages[key] = buildingImageContext(item);
});


const formatTime = (seconds) => {
    if (seconds < 0) seconds = 0;
    const h = Math.floor(seconds / 3600).toString().padStart(2, '0');
    const m = Math.floor((seconds % 3600) / 60).toString().padStart(2, '0');
    const s = Math.floor(seconds % 60).toString().padStart(2, '0');
    return `${h}:${m}:${s}`;
};

const QueueItem = ({ item, isFirst, onCancel }) => {
    const [timeLeft, setTimeLeft] = useState(0);

    useEffect(() => {
        if (!isFirst) return; // Only calculate time for the first item in the queue

        const calculateTimeLeft = () => {
            const endTime = item.endTime?.toDate ? item.endTime.toDate() : new Date(item.endTime);
            if (isNaN(endTime.getTime())) {
                setTimeLeft(0);
                return;
            }
            const remaining = Math.max(0, endTime.getTime() - Date.now());
            setTimeLeft(remaining / 1000);
        };

        calculateTimeLeft();
        const interval = setInterval(calculateTimeLeft, 1000);
        return () => clearInterval(interval);
    }, [item.endTime, isFirst]);

    const building = buildingConfig[item.buildingId];
    if (!building) return null;
    const imageSrc = buildingImages[building.image];

    return (
        <div className="relative w-16 h-16 bg-gray-700 border-2 border-gray-600 rounded-md flex-shrink-0" title={`${building.name} (Level ${item.level})`}>
            <img src={imageSrc} alt={building.name} className="w-full h-full object-contain p-1" />
            <span className="absolute top-0 right-0 bg-yellow-500 text-black text-xs font-bold px-1 rounded-bl-md z-10">
                ^{item.level}
            </span>
            {isFirst && (
                <div className="absolute bottom-0 left-0 right-0 bg-black bg-opacity-75 text-white text-xs text-center py-0.5 font-mono">
                    {formatTime(timeLeft)}
                </div>
            )}
            <button
                onClick={onCancel}
                className="absolute -top-2 -right-2 w-5 h-5 flex items-center justify-center bg-red-600 text-white rounded-full font-bold text-xs hover:bg-red-500 transition-colors z-10"
                title="Cancel Construction"
            >
                &times;
            </button>
        </div>
    );
};

const BuildQueue = ({ buildQueue, onCancel }) => {
    const queueCapacity = 5;
    const emptySlots = Array(Math.max(0, queueCapacity - (buildQueue?.length || 0))).fill(null);

    return (
        <div className="bg-gray-900 p-2 rounded-lg mb-4 flex items-center gap-3 border border-gray-700">
            <div className="w-16 h-16 bg-gray-700 rounded-lg flex items-center justify-center text-4xl flex-shrink-0" title="Construction">
                🔨
            </div>
            <div className="flex-grow flex items-center gap-3">
                {buildQueue && buildQueue.map((item, index) => (
                    <QueueItem key={`${item.buildingId}-${index}`} item={item} isFirst={index === 0} onCancel={() => onCancel(index)} />
                ))}
                {emptySlots.map((_, index) => (
                    <div key={`empty-${index}`} className="w-16 h-16 bg-gray-800 border-2 border-dashed border-gray-600 rounded-md flex items-center justify-center flex-shrink-0">
                        <img src={buildingImages['temple.png']} alt="Empty Slot" className="w-10 h-10 opacity-20" />
                    </div>
                ))}
            </div>
        </div>
    );
};

export default BuildQueue;
</file>

<file path="src/components/city/CaveMenu.js">
import React, { useState } from 'react';
import Modal from '../shared/Modal'; // Assuming you have a Modal component

const CaveMenu = ({ cityGameState, onClose, saveGameState, currentUser, worldId }) => {
    const [depositAmount, setDepositAmount] = useState('');
    const [withdrawAmount, setWithdrawAmount] = useState('');
    const [message, setMessage] = useState('');

    console.log("CaveMenu rendered. cityGameState:", cityGameState); // Debugging

    if (!cityGameState) {
        console.log("CaveMenu: cityGameState is null, showing loading modal."); // Debugging
        return <Modal message="Loading city data..." onClose={onClose} />;
    }

    const caveLevel = cityGameState.buildings.cave?.level || 0;
    const maxSilverStorage = caveLevel * 1000; // Example: 1000 silver per cave level
    const currentSilverInCave = cityGameState.cave?.silver || 0;

    const handleDeposit = async () => {
        const amount = parseInt(depositAmount, 10);
        if (isNaN(amount) || amount <= 0) {
            setMessage('Please enter a valid amount to deposit.');
            return;
        }

        if (cityGameState.resources.silver < amount) {
            setMessage('Not enough silver in your city to deposit.');
            return;
        }

        if (currentSilverInCave + amount > maxSilverStorage) {
            setMessage(`Cannot deposit. Cave storage limit is ${maxSilverStorage}.`);
            return;
        }

        try {
            const newGameState = { ...cityGameState };
            newGameState.resources.silver -= amount;
            newGameState.cave.silver = currentSilverInCave + amount;
            
            await saveGameState(newGameState);
            setMessage(`Successfully deposited ${amount} silver.`);
            setDepositAmount('');
        } catch (error) {
            console.error("Error depositing silver: ", error);
            setMessage('Failed to deposit silver. Please try again.');
        }
    };

    const handleWithdraw = async () => {
        const amount = parseInt(withdrawAmount, 10);
        if (isNaN(amount) || amount <= 0) {
            setMessage('Please enter a valid amount to withdraw.');
            return;
        }

        if (currentSilverInCave < amount) {
            setMessage('Not enough silver in the cave to withdraw.');
            return;
        }

        try {
            const newGameState = { ...cityGameState };
            newGameState.resources.silver += amount;
            newGameState.cave.silver = currentSilverInCave - amount;

            await saveGameState(newGameState);
            setMessage(`Successfully withdrew ${amount} silver.`);
            setWithdrawAmount('');
        } catch (error) {
            console.error("Error withdrawing silver: ", error);
            setMessage('Failed to withdraw silver. Please try again.');
        }
    };

    return (
        <Modal onClose={onClose} title="Cave">
            <div className="p-4 bg-gray-800 text-white rounded-lg shadow-lg">
                <h2 className="text-2xl font-bold mb-4 text-center text-yellow-400">Cave</h2>
                <p className="text-center mb-4">
                    Silver in Cave: <span className="font-semibold text-green-400">{currentSilverInCave}</span> / <span className="font-semibold text-blue-400">{maxSilverStorage}</span>
                </p>

                <div className="mb-6">
                    <h3 className="text-xl font-semibold mb-2 text-yellow-300">Deposit Silver</h3>
                    <input
                        type="number"
                        value={depositAmount}
                        onChange={(e) => setDepositAmount(e.target.value)}
                        placeholder="Amount to deposit"
                        className="w-full p-2 mb-2 rounded bg-gray-700 border border-gray-600 text-white placeholder-gray-400"
                    />
                    <button
                        onClick={handleDeposit}
                        className="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md transition duration-300 ease-in-out shadow-md"
                    >
                        Deposit
                    </button>
                </div>

                <div className="mb-6">
                    <h3 className="text-xl font-semibold mb-2 text-yellow-300">Withdraw Silver</h3>
                    <input
                        type="number"
                        value={withdrawAmount}
                        onChange={(e) => setWithdrawAmount(e.target.value)}
                        placeholder="Amount to withdraw"
                        className="w-full p-2 mb-2 rounded bg-gray-700 border border-gray-600 text-white placeholder-gray-400"
                    />
                    <button
                        onClick={handleWithdraw}
                        className="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-md transition duration-300 ease-in-out shadow-md"
                    >
                        Withdraw
                    </button>
                </div>

                {message && (
                    <p className="mt-4 p-2 bg-blue-700 text-white rounded text-center">
                        {message}
                    </p>
                )}
            </div>
        </Modal>
    );
};

export default CaveMenu;
</file>

<file path="src/components/city/CityHeader.js">
import React, { useState, useEffect } from 'react';
import { useAuth } from '../../contexts/AuthContext';
import { doc, writeBatch } from 'firebase/firestore';
import { signOut } from 'firebase/auth';
import { auth, db } from '../../firebase/config';

const CityHeader = ({ cityGameState, worldId, showMap, onCityNameChange, setMessage, onOpenCheats }) => {
    const { currentUser, userProfile } = useAuth();
    const [isEditingCityName, setIsEditingCityName] = useState(false);
    const [newCityName, setNewCityName] = useState(cityGameState.cityName);

    useEffect(() => {
        if (!isEditingCityName) {
            setNewCityName(cityGameState.cityName);
        }
    }, [cityGameState.cityName, isEditingCityName]);

    const handleCityNameSave = async () => {
        const trimmedName = newCityName.trim();
        if (!trimmedName || trimmedName === cityGameState.cityName) {
            setIsEditingCityName(false);
            return;
        }
        if (trimmedName.length > 20) {
            setMessage("City name cannot exceed 20 characters.");
            return;
        }

        const citySlotId = cityGameState.cityLocation?.slotId;
        if (!citySlotId) {
            setMessage("Error: City location is unknown.");
            return;
        }

        try {
            const batch = writeBatch(db);
            const gameDocRef = doc(db, `users/${currentUser.uid}/games`, worldId);
            const citySlotRef = doc(db, 'worlds', worldId, 'citySlots', citySlotId);

            batch.update(gameDocRef, { cityName: trimmedName });
            batch.update(citySlotRef, { cityName: trimmedName });

            await batch.commit();
            onCityNameChange(trimmedName); // Inform parent of the change
            setMessage("City name updated!");
        } catch (error) {
            console.error("Failed to update city name:", error);
            setMessage("Error updating city name.");
        } finally {
            setIsEditingCityName(false);
        }
    };

    const handleCityNameKeyDown = (e) => {
        if (e.key === 'Enter') handleCityNameSave();
        else if (e.key === 'Escape') setIsEditingCityName(false);
    };

    return (
        <header className="flex-shrink-0 flex flex-col sm:flex-row justify-between items-center p-4 bg-gray-800 shadow-lg border-b border-gray-700 z-10">
            <div>
                {isEditingCityName ? (
                    <input
                        type="text"
                        value={newCityName}
                        onChange={(e) => setNewCityName(e.target.value)}
                        onBlur={handleCityNameSave}
                        onKeyDown={handleCityNameKeyDown}
                        className="font-title text-3xl bg-gray-700 text-gray-200 border border-gray-500 rounded px-2"
                        autoFocus
                    />
                ) : (
                    <h1 
                        className="font-title text-3xl text-gray-300 cursor-pointer hover:bg-gray-700/50 rounded px-2"
                        onDoubleClick={() => setIsEditingCityName(true)}
                        title="Double-click to rename"
                    >
                        {cityGameState.cityName}
                    </h1>
                )}
                {cityGameState.god && <p className="text-lg text-yellow-400 font-semibold">Worshipping: {cityGameState.god}</p>}
                <p className="text-sm text-blue-300">{`${cityGameState.playerInfo.nation} (${cityGameState.playerInfo.religion})`}</p>
                <button onClick={showMap} className="text-sm text-blue-400 hover:text-blue-300 mt-1">← Return to Map</button>
            </div>
            <div className="text-center sm:text-right mt-2 sm:mt-0">
                <p className="text-xs text-gray-400">Player: <span className="font-mono">{userProfile?.username || currentUser?.email}</span></p>
                <div className="flex items-center justify-end space-x-4">
                    {userProfile?.is_admin && (
                        <button onClick={onOpenCheats} className="text-sm text-yellow-400 hover:text-yellow-300 mt-1">Admin Cheats</button>
                    )}
                    <button onClick={() => signOut(auth)} className="text-sm text-red-400 hover:text-red-300 mt-1">Logout</button>
                </div>
            </div>
        </header>
    );
};

export default CityHeader;
</file>

<file path="src/components/city/CityModals.js">
// src/components/city/CityModals.js
import React from 'react';

import AdminCheatMenu from './AdminCheatMenu';
import BarracksMenu from './BarracksMenu';
import ShipyardMenu from './ShipyardMenu';
import BuildingDetailsModal from './BuildingDetailsModal';
import SenateView from './SenateView';
import TempleMenu from './TempleMenu';
import CaveMenu from './CaveMenu';
import HospitalMenu from './HospitalMenu';
import { AcademyMenu } from './AcademyMenu'; // Changed to named import

const CityModals = ({
  cityGameState,
  worldId,
  currentUser,
  userProfile,
  isInstantBuild,
  getUpgradeCost,
  getFarmCapacity,
  getWarehouseCapacity,
  getHospitalCapacity,
  getProductionRates,
  calculateUsedPopulation,
  saveGameState,
  handleUpgrade,
  handleCancelBuild,
  handleTrainTroops,
  handleCancelTrain,
  handleStartResearch,
  handleCancelResearch,
  handleWorshipGod,
  handleCheat,
  handleHealTroops,
  modalState,
  openModal,
  closeModal
}) => {
  const {
    selectedBuildingId,
    isSenateViewOpen,
    isBarracksMenuOpen,
    isShipyardMenuOpen,
    isTempleMenuOpen,
    isCaveMenuOpen,
    isAcademyMenuOpen,
    isHospitalMenuOpen,
    isCheatMenuOpen
  } = modalState;

  if (!cityGameState) return null;

  const maxPopulation = getFarmCapacity(cityGameState.buildings?.farm?.level);
  const usedPopulation = calculateUsedPopulation(cityGameState.buildings, cityGameState.units);
  const availablePopulation = maxPopulation - usedPopulation;

  return (
    <>
      {selectedBuildingId && (
        <BuildingDetailsModal
          buildingId={selectedBuildingId}
          buildingData={cityGameState.buildings[selectedBuildingId]}
          onClose={() => closeModal('selectedBuildingId')}
          getProductionRates={getProductionRates}
          getWarehouseCapacity={getWarehouseCapacity}
          getFarmCapacity={getFarmCapacity}
          onOpenBarracks={() => { closeModal('selectedBuildingId'); openModal('isBarracksMenuOpen'); }}
          onOpenShipyard={() => { closeModal('selectedBuildingId'); openModal('isShipyardMenuOpen'); }}
        />
      )}
      {isSenateViewOpen && (
        <SenateView
          buildings={cityGameState.buildings}
          resources={cityGameState.resources}
          onUpgrade={handleUpgrade}
          getUpgradeCost={getUpgradeCost}
          onClose={() => closeModal('isSenateViewOpen')}
          usedPopulation={usedPopulation}
          maxPopulation={maxPopulation}
          buildQueue={cityGameState.buildQueue}
          onCancelBuild={handleCancelBuild}
        />
      )}
      {isBarracksMenuOpen && (
        <BarracksMenu
          resources={cityGameState.resources}
          availablePopulation={availablePopulation}
          onTrain={handleTrainTroops}
          onClose={() => closeModal('isBarracksMenuOpen')}
          buildings={cityGameState.buildings}
          unitQueue={cityGameState.unitQueue}
          onCancelTrain={handleCancelTrain}
          cityGameState={cityGameState}
        />
      )}
      {isShipyardMenuOpen && (
        <ShipyardMenu
          resources={cityGameState.resources}
          availablePopulation={availablePopulation}
          onTrain={handleTrainTroops}
          onClose={() => closeModal('isShipyardMenuOpen')}
          buildings={cityGameState.buildings}
          unitQueue={cityGameState.unitQueue}
          onCancelTrain={handleCancelTrain}
          cityGameState={cityGameState}
        />
      )}
      {isTempleMenuOpen && (
        <TempleMenu
          city={cityGameState}
          onWorship={handleWorshipGod}
          onClose={() => closeModal('isTempleMenuOpen')}
          favorData={cityGameState.worship || {}}
        />
      )}
      {isAcademyMenuOpen && (
        <AcademyMenu
          cityGameState={cityGameState}
          onResearch={handleStartResearch}
          onClose={() => closeModal('isAcademyMenuOpen')}
          researchQueue={cityGameState.researchQueue}
          onCancelResearch={handleCancelResearch}
        />
      )}
      {isCaveMenuOpen && (
        <CaveMenu
          cityGameState={cityGameState}
          onClose={() => closeModal('isCaveMenuOpen')}
          saveGameState={saveGameState}
          currentUser={currentUser}
          worldId={worldId}
        />
      )}
      {isHospitalMenuOpen && (
          <HospitalMenu
              cityGameState={cityGameState}
              onClose={() => closeModal('isHospitalMenuOpen')}
              onHeal={handleHealTroops}
              getHospitalCapacity={getHospitalCapacity}
          />
      )}
      {isCheatMenuOpen && userProfile?.is_admin && (
        <AdminCheatMenu
          onCheat={handleCheat}
          onClose={() => closeModal('isCheatMenuOpen')}
          isInstantBuildActive={isInstantBuild}
        />
      )}
    </>
  );
};

export default CityModals;
</file>

<file path="src/components/city/Cityscape.js">
// src/components/city/Cityscape.js
import React from 'react';
import BuildingSpot from './BuildingSpot';
import buildingLayout from './BuildingLayout.json';
import buildingConfig from '../../gameData/buildings.json'; // Import building config

const Cityscape = ({ buildings, onBuildingClick, buildingImages }) => {
  return (
    <div
      style={{
        width: '2000px', // Large canvas for the city
        height: '2000px',
        position: 'relative',
        background: `linear-gradient(to bottom, #2a623d 70%, #1e3a8a 70%)`, // 70% land, 30% sea
      }}
    >
      {buildingLayout.map((building) => {
        const buildingData = buildings[building.id];
        const level = buildingData?.level || 0;
        const config = buildingConfig[building.id]; // Get config for the building
        
        return (
          <BuildingSpot
            key={building.id}
            building={building}
            level={level}
            onClick={() => onBuildingClick(building.id)}
            image={config?.image ? buildingImages[config.image] : null} // Pass image URL
          />
        );
      })}
    </div>
  );
};

export default Cityscape;
</file>

<file path="src/components/city/CityViewContent.js">
// src/components/city/CityViewContent.js
import React, { useRef, useEffect, useCallback, useLayoutEffect, useState } from 'react';
import Cityscape from './Cityscape';
import SideInfoPanel from '../SideInfoPanel';
import buildingConfig from '../../gameData/buildings.json'; // Import building config

// Dynamically import all building images
const buildingImages = {};
const buildingImageContext = require.context('../../images/buildings', false, /\.(png|jpe?g|svg)$/);
buildingImageContext.keys().forEach((item) => {
    const key = item.replace('./', '');
    buildingImages[key] = buildingImageContext(item);
});

const CITYSCAPE_SIZE = 2000;

const CityViewContent = ({ cityGameState, handlePlotClick, onOpenPowers, gameSettings }) => {
    // Panning Logic (moved from CityView.js)
    const viewportRef = useRef(null);
    const cityContainerRef = useRef(null);
    const [pan, setPan] = useState({ x: 0, y: 0 });
    const [isPanning, setIsPanning] = useState(false);
    const [startPos, setStartPos] = useState({ x: 0, y: 0 });

    const clampPan = useCallback((newPan) => {
        if (!viewportRef.current) return { x: 0, y: 0 };
        const { clientWidth, clientHeight } = viewportRef.current;
        const minX = clientWidth - CITYSCAPE_SIZE;
        const minY = clientHeight - CITYSCAPE_SIZE;
        return {
            x: Math.max(minX, Math.min(0, newPan.x)),
            y: Math.max(minY, Math.min(0, newPan.y)),
        };
    }, []);

    useLayoutEffect(() => {
        if (!viewportRef.current) return;
        const { clientWidth, clientHeight } = viewportRef.current;
        setPan(clampPan({ x: (clientWidth - CITYSCAPE_SIZE) / 2, y: (clientHeight - CITYSCAPE_SIZE) / 2 }));
    }, [clampPan]);

    useEffect(() => {
        const container = cityContainerRef.current;
        if (container) container.style.transform = `translate(${pan.x}px, ${pan.y}px)`;
    }, [pan]);

    const handleMouseDown = useCallback((e) => {
        if (e.button !== 0) return;
        e.preventDefault();
        setStartPos({ x: e.clientX - pan.x, y: e.clientY - pan.y });
        setIsPanning(true);
    }, [pan]);

    useEffect(() => {
        const handleMouseMove = (e) => {
            if (!isPanning) return;
            setPan(clampPan({ x: e.clientX - startPos.x, y: e.clientY - startPos.y }));
        };
        const handleMouseUp = () => setIsPanning(false);
        if (isPanning) {
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp);
        }
        return () => {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        };
    }, [isPanning, startPos, clampPan]);

    if (!gameSettings.showVisuals) {
        return (
            <main className="flex-grow w-full h-full relative overflow-y-auto p-4">
                <h2 className="text-2xl font-bold mb-4">City Buildings</h2>
                <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
                    {Object.entries(cityGameState.buildings).map(([id, data]) => {
                        if (data.level > 0) {
                            return (
                                <div key={id} className="bg-gray-800 p-3 rounded-lg cursor-pointer hover:bg-gray-700" onClick={() => handlePlotClick(id)}>
                                    <p className="font-bold text-lg text-yellow-400">{buildingConfig[id]?.name}</p>
                                    <p>Level {data.level}</p>
                                </div>
                            );
                        }
                        return null;
                    })}
                </div>
                 <SideInfoPanel 
                    gameState={cityGameState} 
                    className="absolute top-1/2 right-4 transform -translate-y-1/2 z-20" 
                    onOpenPowers={onOpenPowers}
                />
            </main>
        );
    }

    return (
        <main className="flex-grow w-full h-full relative overflow-hidden cursor-grab" ref={viewportRef} onMouseDown={handleMouseDown}>
            <div ref={cityContainerRef} style={{ transformOrigin: '0 0' }}>
                <Cityscape buildings={cityGameState.buildings} onBuildingClick={handlePlotClick} buildingImages={buildingImages} />
            </div>
            <SideInfoPanel 
                gameState={cityGameState} 
                className="absolute top-1/2 right-4 transform -translate-y-1/2 z-20" 
                onOpenPowers={onOpenPowers}
            />
        </main>
    );
};

export default CityViewContent;
</file>

<file path="src/components/city/DivinePowers.css">
/* src/components/city/DivinePowers.css */
.divine-powers-modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(0, 0, 0, 0.7);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
}

.divine-powers-modal-content {
    background-color: #2d3748;
    border: 2px solid #a0aec0;
    border-radius: 8px;
    padding: 20px;
    width: 90%;
    max-width: 600px;
}

.divine-powers-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    color: #f7fafc;
    font-family: 'IM Fell English SC', serif;
}

.divine-powers-header h2 {
    font-size: 2rem;
}

.close-button {
    background: none;
    border: none;
    color: #f7fafc;
    font-size: 2rem;
    cursor: pointer;
}

.powers-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 15px;
}

.power-card {
    background-color: #4a5568;
    border-radius: 8px;
    padding: 15px;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
}

.power-card h3 {
    font-size: 1.25rem;
    color: #f7fafc;
    font-weight: bold;
    margin-bottom: 10px;
}

.power-card p {
    color: #cbd5e0;
    font-size: 0.9rem;
    flex-grow: 1;
}

.power-cost {
    color: #a0aec0;
    font-style: italic;
    margin-top: 15px;
}

.cast-spell-button {
    background-color: #4299e1;
    color: white;
    padding: 10px 15px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    margin-top: 10px;
    transition: background-color 0.3s;
}

.cast-spell-button:hover:not(:disabled) {
    background-color: #3182ce;
}

.cast-spell-button:disabled {
    background-color: #718096;
    cursor: not-allowed;
}
</file>

<file path="src/components/city/DivinePowers.js">
// src/components/city/DivinePowers.js
import React from 'react';
import godsConfig from '../../gameData/gods.json';
import './DivinePowers.css';

const DivinePowers = ({ godName, playerReligion, favor, onCastSpell, onClose, targetType = 'self' }) => {
    const getGodDetails = (name, religion) => {
        if (!name || !religion) return null;
        const religionKey = religion.toLowerCase();
        const pantheon = godsConfig[religionKey];
        if (!pantheon) return null;
        return Object.values(pantheon).find(g => g.name === name);
    };

    const godDetails = getGodDetails(godName, playerReligion);

    if (!godDetails) {
        return null;
    }

    const availablePowers = godDetails.powers.filter(power => {
        return power.effect.target === targetType || power.effect.target === 'both';
    });

    return (
        <div className="divine-powers-modal-overlay" onClick={onClose}>
            <div className="divine-powers-modal-content" onClick={e => e.stopPropagation()}>
                <div className="divine-powers-header">
                    <h2>{godDetails.name}'s Powers ({targetType === 'self' ? 'On Your City' : 'On Another City'})</h2>
                    <button onClick={onClose} className="close-button">&times;</button>
                </div>
                {availablePowers.length > 0 ? (
                    <div className="powers-grid">
                        {availablePowers.map(power => (
                            <div key={power.name} className="power-card">
                                <h3>{power.name}</h3>
                                <p>{power.description}</p>
                                <div className="power-cost">
                                    Cost: {power.favorCost} Favor
                                </div>
                                <button
                                    onClick={() => onCastSpell(power)}
                                    disabled={favor < power.favorCost}
                                    className="cast-spell-button"
                                >
                                    Cast Spell
                                </button>
                            </div>
                        ))}
                    </div>
                ) : (
                    <p className="text-gray-400 text-center">No {targetType === 'self' ? 'self-targeted' : 'targeted'} spells available for {godDetails.name}.</p>
                )}
            </div>
        </div>
    );
};

export default DivinePowers;
</file>

<file path="src/components/city/HospitalMenu.js">
// src/components/city/HospitalMenu.js
import React, { useState, useMemo } from 'react';
import unitConfig from '../../gameData/units.json';
import UnitQueue from './UnitQueue';

const unitImages = {};
const imageContext = require.context('../../images', false, /\.(png|jpe?g|svg)$/);
imageContext.keys().forEach((item) => {
    const key = item.replace('./', '');
    unitImages[key] = imageContext(item);
});

const HospitalMenu = ({ cityGameState, onClose, onHeal, getHospitalCapacity }) => {
    const [healAmounts, setHealAmounts] = useState({});

    const woundedUnits = cityGameState.wounded || {};
    const hospitalLevel = cityGameState.buildings.hospital?.level || 0;
    const capacity = getHospitalCapacity(hospitalLevel);
    const totalWounded = Object.values(woundedUnits).reduce((sum, count) => sum + count, 0);

    const handleAmountChange = (unitId, value) => {
        const max = woundedUnits[unitId] || 0;
        const amount = Math.max(0, Math.min(max, parseInt(value, 10) || 0));
        setHealAmounts(prev => ({ ...prev, [unitId]: amount }));
    };

    const totalCost = useMemo(() => {
        return Object.entries(healAmounts).reduce((acc, [unitId, amount]) => {
            const unit = unitConfig[unitId];
            if (unit && unit.heal_cost) {
                acc.wood += (unit.heal_cost.wood || 0) * amount;
                acc.stone += (unit.heal_cost.stone || 0) * amount;
                acc.silver += (unit.heal_cost.silver || 0) * amount;
            }
            return acc;
        }, { wood: 0, stone: 0, silver: 0 });
    }, [healAmounts]);

    const canAfford = cityGameState.resources.wood >= totalCost.wood &&
                      cityGameState.resources.stone >= totalCost.stone &&
                      cityGameState.resources.silver >= totalCost.silver;

    const handleHeal = () => {
        const unitsToHeal = Object.entries(healAmounts).filter(([, amount]) => amount > 0);
        if (unitsToHeal.length > 0) {
            onHeal(Object.fromEntries(unitsToHeal));
            setHealAmounts({});
        }
    };

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            <div className="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-4xl border-2 border-gray-600 flex flex-col max-h-[90vh]" onClick={e => e.stopPropagation()}>
                <div className="flex justify-between items-center mb-4">
                    <h3 className="font-title text-3xl text-white">Hospital (Level {hospitalLevel})</h3>
                    <button onClick={onClose} className="text-gray-400 text-3xl leading-none hover:text-white">&times;</button>
                </div>
                <p className="text-gray-400 mb-4">Capacity: {totalWounded} / {capacity}</p>

                <div className="flex-grow overflow-y-auto pr-2">
                    <h4 className="text-xl font-semibold text-yellow-400 mb-2">Wounded Units</h4>
                    {Object.keys(woundedUnits).length > 0 ? (
                        <div className="space-y-3">
                            {Object.entries(woundedUnits).map(([unitId, count]) => {
                                if (count === 0) return null;
                                const unit = unitConfig[unitId];
                                return (
                                    <div key={unitId} className="bg-gray-700 p-3 rounded-lg flex items-center justify-between">
                                        <div className="flex items-center gap-4">
                                            <img src={unitImages[unit.image]} alt={unit.name} className="w-12 h-12 object-contain" />
                                            <div>
                                                <p className="font-bold text-white">{unit.name}</p>
                                                <p className="text-sm text-gray-400">Wounded: {count}</p>
                                            </div>
                                        </div>
                                        <div className="flex items-center gap-3">
                                            <input
                                                type="number"
                                                value={healAmounts[unitId] || ''}
                                                onChange={(e) => handleAmountChange(unitId, e.target.value)}
                                                className="bg-gray-800 text-white rounded p-2 w-24 text-center"
                                                placeholder="Amount"
                                                max={count}
                                                min="0"
                                            />
                                            <div className="text-xs text-gray-300">
                                                <p>Cost/unit:</p>
                                                <p>W: {unit.heal_cost.wood}, S: {unit.heal_cost.stone}, Ag: {unit.heal_cost.silver}</p>
                                                <p>Time/unit: {unit.heal_time}s</p>
                                            </div>
                                        </div>
                                    </div>
                                );
                            })}
                        </div>
                    ) : (
                        <p className="text-gray-500 text-center py-8">No wounded units.</p>
                    )}
                </div>
                
                <div className="mt-4 pt-4 border-t border-gray-600">
                    <div className="flex justify-between items-center">
                        <div>
                            <p className="font-bold text-lg">Total Cost:</p>
                            <p className="text-sm text-gray-300">
                                Wood: {totalCost.wood}, Stone: {totalCost.stone}, Silver: {totalCost.silver}
                            </p>
                        </div>
                        <button
                            onClick={handleHeal}
                            disabled={!canAfford || Object.keys(healAmounts).length === 0 || (cityGameState.healQueue || []).length >= 5}
                            className={`py-2 px-6 text-lg rounded-lg btn ${canAfford && Object.keys(healAmounts).length > 0 && (cityGameState.healQueue || []).length < 5 ? 'btn-confirm' : 'btn-disabled'}`}
                        >
                            { (cityGameState.healQueue || []).length >= 5 ? 'Queue Full' : 'Heal Selected'}
                        </button>
                    </div>
                </div>

                <UnitQueue unitQueue={cityGameState.healQueue || []} onCancel={() => {}} />
            </div>
        </div>
    );
};

export default HospitalMenu;
</file>

<file path="src/components/city/ResearchQueue.js">
// src/components/city/ResearchQueue.js
import React, { useState, useEffect } from 'react';
import researchConfig from '../../gameData/research.json';

const formatTime = (seconds) => {
    if (seconds < 0) seconds = 0;
    const h = Math.floor(seconds / 3600).toString().padStart(2, '0');
    const m = Math.floor((seconds % 3600) / 60).toString().padStart(2, '0');
    const s = Math.floor(seconds % 60).toString().padStart(2, '0');
    return `${h}:${m}:${s}`;
};

const ResearchQueueItem = ({ item, onCancel }) => {
    const [timeLeft, setTimeLeft] = useState(0);

    useEffect(() => {
        const calculateTimeLeft = () => {
            const endTime = item.endTime?.toDate ? item.endTime.toDate() : new Date(item.endTime);
            if (isNaN(endTime.getTime())) {
                setTimeLeft(0);
                return;
            }
            const remaining = Math.max(0, endTime.getTime() - Date.now());
            setTimeLeft(remaining / 1000);
        };

        calculateTimeLeft();
        const interval = setInterval(calculateTimeLeft, 1000);
        return () => clearInterval(interval);
    }, [item.endTime]);

    const research = researchConfig[item.researchId];

    return (
        <div className="flex justify-between items-center bg-gray-600 p-2 rounded">
            <span className="font-semibold">{research.name}</span>
            <div className="flex items-center gap-4">
                <span className="font-mono text-yellow-300">{formatTime(timeLeft)}</span>
                <button 
                    onClick={onCancel} 
                    className="text-red-400 hover:text-red-300 font-bold text-xl leading-none px-2 rounded-full"
                    title="Cancel Research"
                >
                    &times;
                </button>
            </div>
        </div>
    );
};

const ResearchQueue = ({ researchQueue, onCancel }) => {
    if (!researchQueue || researchQueue.length === 0) {
        return (
            <div className="bg-gray-900 p-3 rounded-lg mb-4">
                <h4 className="text-lg font-semibold text-gray-400 text-center">Research queue is empty.</h4>
            </div>
        );
    }

    return (
        <div className="bg-gray-900 p-3 rounded-lg mb-4">
            <h4 className="text-lg font-semibold text-yellow-400 mb-2">Research Queue ({researchQueue.length}/5)</h4>
            <div className="space-y-2">
                {researchQueue.map((item, index) => (
                    <ResearchQueueItem key={`${item.researchId}-${index}`} item={item} onCancel={() => onCancel(index)} />
                ))}
            </div>
        </div>
    );
};

export default ResearchQueue;
</file>

<file path="src/components/city/ResourceBar.js">
import React from 'react';
import woodImage from '../../images/resources/wood.png';
import stoneImage from '../../images/resources/stone.png';
import silverImage from '../../images/resources/silver.png';
import populationImage from '../../images/resources/population.png';

const ResourceBar = ({ resources, productionRates, availablePopulation }) => {
    return (
        <div className="grid grid-cols-2 sm:grid-cols-5 gap-4 p-4 flex-shrink-0 z-10">
            <div className="bg-gray-800 p-3 rounded-lg flex items-center border border-gray-700">
                <img src={woodImage} alt="Wood" className="resource-icon rounded"/>
                <div><span className="font-bold text-lg text-yellow-300">{Math.floor(resources.wood).toLocaleString()}</span><span className="text-xs text-gray-400"> (+{productionRates.wood}/hr)</span></div>
            </div>
            <div className="bg-gray-800 p-3 rounded-lg flex items-center border border-gray-700">
                <img src={stoneImage} alt="Stone" className="resource-icon rounded"/>
                <div><span className="font-bold text-lg text-gray-300">{Math.floor(resources.stone).toLocaleString()}</span><span className="text-xs text-gray-400"> (+{productionRates.stone}/hr)</span></div>
            </div>
            <div className="bg-gray-800 p-3 rounded-lg flex items-center border border-gray-700">
                <img src={silverImage} alt="Silver" className="resource-icon rounded"/>
                <div><span className="font-bold text-lg text-blue-300">{Math.floor(resources.silver).toLocaleString()}</span><span className="text-xs text-gray-400"> (+{productionRates.silver}/hr)</span></div>
            </div>
            <div className="bg-gray-800 p-3 rounded-lg flex items-center border border-gray-700">
                <img src={populationImage} alt="Population" className="resource-icon rounded"/>
                <div><span className="font-bold text-lg text-red-400">{availablePopulation.toLocaleString()}</span><span className="text-xs text-gray-400"> Available Pop.</span></div>
            </div>
        </div>
    );
};

export default ResourceBar;
</file>

<file path="src/components/city/SenateView.js">
// src/components/city/SenateView.js
import React, { useState } from 'react';
import buildingConfig from '../../gameData/buildings.json';
import BuildQueue from './BuildQueue';

// Dynamically import all building images
const buildingImages = {};
const buildingImageContext = require.context('../../images/buildings', false, /\.(png|jpe?g|svg)$/);
buildingImageContext.keys().forEach((item) => {
    const key = item.replace('./', '');
    buildingImages[key] = buildingImageContext(item);
});

const BuildingCard = ({ id, config, level, cost, canAfford, onUpgrade, isQueueFull }) => {
    const buttonText = level === 0 ? 'Build' : `Expand to ${level + 1}`;
    let disabledReason = '';
    if (isQueueFull) disabledReason = 'Queue Full';
    else if (!canAfford) disabledReason = 'Not enough resources/pop';

    return (
        <div className="bg-gray-700/80 border-2 border-gray-600 rounded-lg p-2 w-48 text-center flex flex-col items-center relative shadow-lg">
            {/* Connector line to parent row */}
            <div className="absolute -top-6 left-1/2 -translate-x-1/2 w-0.5 h-6 bg-gray-500/50"></div>

            <h4 className="font-bold text-yellow-400 text-base">{config.name}</h4>
            <p className="text-sm text-gray-300 font-semibold">Level {level}</p>
            <img src={buildingImages[config.image]} alt={config.name} className="w-20 h-20 object-contain my-1" />
            
            <div className="text-xs text-gray-400 mb-2">
                <span>{cost.wood}W</span>, <span>{cost.stone}S</span>, <span>{cost.silver}Ag</span>, <span>{cost.population}P</span>
            </div>

            <button
                onClick={() => onUpgrade(id)}
                disabled={!canAfford || isQueueFull}
                className={`w-full py-1.5 rounded font-bold text-sm transition-colors ${!canAfford || isQueueFull ? 'btn-disabled' : 'btn-upgrade'}`}
            >
                {disabledReason || buttonText}
            </button>
        </div>
    );
};

const SenateView = ({ buildings, resources, onUpgrade, onDemolish, getUpgradeCost, onClose, usedPopulation, maxPopulation, buildQueue = [], onCancelBuild, setMessage }) => {
    const [activeTab, setActiveTab] = useState('upgrade');
    
    const buildingRows = [
        ['senate'],
        ['timber_camp', 'farm', 'quarry', 'warehouse'],
        ['silver_mine', 'barracks', 'temple', 'market'],
        ['shipyard', 'academy', 'city_wall', 'cave']
    ];

    const isBuildingInQueue = (buildingId) => (buildQueue || []).some(task => task.buildingId === buildingId);

    return (
        <div className="fixed inset-0 bg-black bg-opacity-75 flex justify-center items-center z-30">
            <div className="bg-gray-800 text-white p-6 rounded-lg shadow-xl w-full max-w-6xl max-h-[90vh] flex flex-col">
                <div className="flex justify-between items-center border-b border-gray-600 pb-3 mb-4">
                    <h2 className="text-3xl font-bold font-title text-yellow-300">Senate</h2>
                    <button onClick={onClose} className="text-gray-400 hover:text-white text-2xl">&times;</button>
                </div>
                
                <BuildQueue buildQueue={buildQueue} onCancel={onCancelBuild} />
                
                <div className='flex justify-between items-center mb-4 p-3 bg-gray-900 rounded-lg'>
                    <p className="text-lg">Population: <span className="font-bold text-green-400">{maxPopulation - usedPopulation}</span> / {maxPopulation}</p>
                    <div className="flex gap-4">
                        <p>Wood: <span className='font-bold text-yellow-300'>{Math.floor(resources.wood)}</span></p>
                        <p>Stone: <span className='font-bold text-gray-300'>{Math.floor(resources.stone)}</span></p>
                        <p>Silver: <span className='font-bold text-blue-300'>{Math.floor(resources.silver)}</span></p>
                    </div>
                </div>

                <div className="flex border-b border-gray-600 mb-4">
                    <button onClick={() => setActiveTab('upgrade')} className={`flex-1 p-2 text-lg font-bold transition-colors ${activeTab === 'upgrade' ? 'bg-gray-700 text-white' : 'bg-gray-800 text-gray-400 hover:bg-gray-700'}`}>Upgrade</button>
                    <button onClick={() => setActiveTab('demolish')} className={`flex-1 p-2 text-lg font-bold transition-colors ${activeTab === 'demolish' ? 'bg-gray-700 text-white' : 'bg-gray-800 text-gray-400 hover:bg-gray-700'}`}>Demolish</button>
                </div>

                <div className="overflow-y-auto pr-2">
                    {activeTab === 'upgrade' && (
                        <div className="flex flex-col items-center space-y-12 py-6">
                            {buildingRows.map((row, rowIndex) => (
                                <div key={rowIndex} className="flex justify-center items-start gap-6 relative">
                                    {row.length > 1 && rowIndex > 0 && <div className="absolute -top-9 left-0 right-0 h-0.5 bg-gray-500/50 z-0 w-3/4 mx-auto"></div>}
                                    {row.map(id => {
                                        const config = buildingConfig[id];
                                        if (config.constructible === false && id !== 'senate') return null;
                                        const level = buildings[id]?.level || 0;
                                        const cost = getUpgradeCost(id, level + 1);
                                        const canAfford = resources.wood >= cost.wood && resources.stone >= cost.stone && resources.silver >= cost.silver && (maxPopulation - usedPopulation >= cost.population);
                                        const isQueueFull = (buildQueue || []).length >= 5;

                                        return (
                                            <BuildingCard 
                                                key={id} 
                                                id={id}
                                                config={config}
                                                level={level}
                                                cost={cost}
                                                canAfford={canAfford}
                                                onUpgrade={onUpgrade}
                                                isQueueFull={isQueueFull}
                                            />
                                        );
                                    })}
                                </div>
                            ))}
                        </div>
                    )}
                    {activeTab === 'demolish' && (
                         <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                            {Object.entries(buildings)
                                .filter(([id, data]) => data.level > 0 && buildingConfig[id].constructible !== false && id !== 'senate')
                                .map(([id, data]) => {
                                    const config = buildingConfig[id];
                                    const inQueue = isBuildingInQueue(id);
                                    return (
                                        <div key={id} className="bg-gray-700 p-4 rounded-lg flex justify-between items-center">
                                            <div>
                                                <h4 className="text-xl font-semibold text-yellow-400">{config.name}</h4>
                                                <p className="text-sm text-gray-300">Level {data.level}</p>
                                            </div>
                                            <button 
                                                onClick={() => onDemolish(id, setMessage)}
                                                disabled={inQueue || (buildQueue || []).length >= 5}
                                                className={`py-2 px-4 rounded font-bold ${inQueue || (buildQueue || []).length >= 5 ? 'btn-disabled' : 'btn-danger'}`}
                                            >
                                                {inQueue ? 'In Queue' : 'Demolish'}
                                            </button>
                                        </div>
                                    );
                                })
                            }
                        </div>
                    )}
                </div>
            </div>
        </div>
    );
};

export default SenateView;
</file>

<file path="src/components/city/ShipyardMenu.js">
// src/components/city/ShipyardMenu.js
import React, { useState, useEffect } from 'react';
import unitConfig from '../../gameData/units.json';
import UnitQueue from './UnitQueue';

// Dynamically import all unit images
const unitImages = {};
const imageContext = require.context('../../images', false, /\.(png|jpe?g|svg)$/);
imageContext.keys().forEach((item) => {
    const key = item.replace('./', '');
    unitImages[key] = imageContext(item);
});

const UnitStats = ({ unit }) => (
    <div className="w-1/2 bg-gray-900 p-4 rounded-lg space-y-2">
        <h5 className="font-bold text-lg text-yellow-300 mb-3">Unit Information</h5>
        <div className="flex items-center justify-between text-sm"><span>⚔️ Attack</span><span className="font-bold">{unit.attack}</span></div>
        <div className="flex items-center justify-between text-sm"><span>🛡️ Defense</span><span className="font-bold">{unit.defense}</span></div>
        <div className="flex items-center justify-between text-sm"><span>⛵ Speed</span><span className="font-bold">{unit.speed}</span></div>
        {unit.capacity > 0 && <div className="flex items-center justify-between text-sm"><span>📦 Capacity</span><span className="font-bold">{unit.capacity}</span></div>}
    </div>
);

const ShipyardMenu = ({ resources, availablePopulation, onTrain, onClose, cityGameState, unitQueue, onCancelTrain }) => {
    const navalUnits = Object.keys(unitConfig).filter(id => unitConfig[id].type === 'naval');
    const [selectedUnitId, setSelectedUnitId] = useState(navalUnits[0] || null);
    const [trainAmount, setTrainAmount] = useState(1);
    
    useEffect(() => {
        setTrainAmount(1);
    }, [selectedUnitId]);

    if (!selectedUnitId) {
        // You might want a better placeholder if no naval units exist in your gameData
        return <div className="text-white">Build a shipyard to see available units.</div>
    }

    const selectedUnit = unitConfig[selectedUnitId];
    const cityUnits = cityGameState?.units || {};
    const navalUnitQueue = (unitQueue || []).filter(item => unitConfig[item.unitId]?.type === 'naval');

    const totalCost = {
        wood: selectedUnit.cost.wood * trainAmount,
        stone: selectedUnit.cost.stone * trainAmount,
        silver: selectedUnit.cost.silver * trainAmount,
        population: selectedUnit.cost.population * trainAmount,
    };

    const canAfford = resources.wood >= totalCost.wood &&
                    resources.stone >= totalCost.stone &&
                    resources.silver >= totalCost.silver &&
                    availablePopulation >= totalCost.population;

    const handleTrain = () => {
        if(trainAmount > 0) onTrain(selectedUnitId, trainAmount);
    };

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            <div className="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-4xl border-2 border-gray-600 flex flex-col max-h-[90vh]" onClick={e => e.stopPropagation()}>
                <div className="flex justify-between items-center mb-4">
                    <h3 className="font-title text-3xl text-white">Shipyard</h3>
                    <button onClick={onClose} className="text-gray-400 text-3xl leading-none hover:text-white">&times;</button>
                </div>

                <div className="flex-grow flex gap-4 overflow-y-auto">
                    {/* Left Panel: Unit Selection */}
                    <div className="w-1/3 flex flex-col gap-2">
                        {navalUnits.map(unitId => {
                            const unit = unitConfig[unitId];
                            const isSelected = selectedUnitId === unitId;
                            return (
                                <button
                                    key={unitId}
                                    onClick={() => setSelectedUnitId(unitId)}
                                    className={`flex items-center p-2 rounded border-2 transition-colors w-full ${isSelected ? 'bg-gray-600 border-yellow-500' : 'bg-gray-700 border-gray-600 hover:border-yellow-400'}`}
                                >
                                    <img src={unitImages[unit.image]} alt={unit.name} className="w-12 h-12 mr-3 object-contain" />
                                    <div>
                                        <p className="font-bold text-left text-white">{unit.name}</p>
                                        <p className="text-sm text-left text-gray-400">In City: {cityUnits[unitId] || 0}</p>
                                    </div>
                                </button>
                            );
                        })}
                    </div>

                    {/* Right Panel: Details */}
                    <div className="w-2/3 flex flex-col gap-4">
                        <div className="bg-gray-700 p-4 rounded-lg">
                            <h4 className="font-title text-2xl text-yellow-400">{selectedUnit.name}</h4>
                            <p className="text-gray-400 italic mt-1">{selectedUnit.description}</p>
                        </div>
                        <div className="flex gap-4">
                            <div className="w-1/2 bg-gray-900 p-4 rounded-lg space-y-1">
                                <h5 className="font-bold text-lg text-yellow-300 mb-2">Cost (Total)</h5>
                                <p className="text-sm text-gray-300">Wood: {selectedUnit.cost.wood} ({totalCost.wood})</p>
                                <p className="text-sm text-gray-300">Stone: {selectedUnit.cost.stone} ({totalCost.stone})</p>
                                <p className="text-sm text-gray-300">Silver: {selectedUnit.cost.silver} ({totalCost.silver})</p>
                                <p className="text-sm text-gray-300">Population: {selectedUnit.cost.population} ({totalCost.population})</p>
                                <p className="text-sm text-gray-300">Time per unit: {selectedUnit.cost.time}s</p>
                            </div>
                            <UnitStats unit={selectedUnit} />
                        </div>
                        <div className="bg-gray-700 p-4 rounded-lg flex items-center justify-between">
                            <input
                                type="number"
                                value={trainAmount}
                                onChange={(e) => setTrainAmount(Math.max(1, parseInt(e.target.value, 10) || 1))}
                                className="bg-gray-800 text-white rounded p-2 w-24"
                            />
                            <button
                                onClick={handleTrain}
                                disabled={!canAfford || (unitQueue || []).length >= 5}
                                className={`py-2 px-6 text-lg rounded-lg btn ${(canAfford && (unitQueue || []).length < 5) ? 'btn-confirm' : 'btn-disabled'}`}
                            >
                                {(unitQueue || []).length >= 5 ? 'Queue Full' : 'Build'}
                            </button>
                        </div>
                    </div>
                </div>

                <UnitQueue unitQueue={navalUnitQueue} onCancel={onCancelTrain} />
            </div>
        </div>
    );
};

export default ShipyardMenu;
</file>

<file path="src/components/city/TempleMenu.js">
import React, { useState } from 'react';
import godsConfig from '../../gameData/gods.json';

// Dynamically import all images from the images/gods folder
const images = require.context('../../images/gods', false, /\.(png|jpe?g|svg)$/);
const imageMap = images.keys().reduce((acc, item) => {
    const key = item.replace('./', '');
    acc[key] = images(item);
    return acc;
}, {});

const TempleMenu = ({ city, onWorship, onClose, favorData }) => {
    const playerReligion = city.playerInfo.religion;
    const currentGod = city.god;
    
    const availableGods = (playerReligion && godsConfig[playerReligion.toLowerCase()]) || {};
    const firstGodName = Object.keys(availableGods)[0] || null;
    const [selectedGodName, setSelectedGodName] = useState(currentGod || firstGodName);

    const selectedGodDetails = selectedGodName ? availableGods[selectedGodName] : null;

    // --- NEW FAVOR DISPLAY LOGIC ---
    const favor = selectedGodName ? (favorData[selectedGodName] || 0) : 0;
    const templeLevel = city.buildings.temple?.level || 0;
    const maxFavor = templeLevel > 0 ? 100 + (templeLevel * 20) : 0;
    const favorPercentage = maxFavor > 0 ? (favor / maxFavor) * 100 : 0;
    // --- END ---

    const buttonDisabled = !selectedGodName || selectedGodName === currentGod;
    let buttonText;
    if (currentGod && selectedGodName === currentGod) {
        buttonText = `Currently Worshipping ${currentGod}`;
    } else if (selectedGodName) {
        buttonText = `Worship ${selectedGodName}`;
    } else {
        buttonText = "Select a God";
    }

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            <div className="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-4xl border-2 border-yellow-600 text-white" onClick={e => e.stopPropagation()}>
                <div className="flex justify-between items-center mb-4">
                    <h3 className="font-title text-3xl">Temple in {city.name}</h3>
                    <button onClick={onClose} className="text-gray-400 text-3xl leading-none hover:text-white">&times;</button>
                </div>

                <div className="flex gap-6">
                    {/* Left Sidebar for God Selection */}
                    <div className="flex flex-col gap-2 p-2 bg-gray-900 border border-gray-700 rounded-lg">
                        {Object.values(availableGods).map(god => (
                            <button
                                key={god.name}
                                onClick={() => setSelectedGodName(god.name)}
                                className={`w-20 h-20 flex items-center justify-center rounded-lg overflow-hidden transition-all border-2 ${selectedGodName === god.name ? 'bg-gray-700 border-yellow-400' : 'bg-gray-800 border-gray-600 hover:bg-gray-700'}`}
                                title={god.name}
                            >
                                <img src={imageMap[god.image]} alt={god.name} className="w-full h-full object-cover" />
                            </button>
                        ))}
                    </div>

                    {/* Main Content Area for God Details */}
                    <div className="flex-1 bg-gray-900 border border-gray-700 rounded-lg p-4">
                        {selectedGodDetails ? (
                            <>
                                <div className="flex items-center gap-4 mb-4">
                                    <div className="w-32 h-32 p-1 bg-gray-800 rounded-full border-4 border-stone-500 flex-shrink-0 overflow-hidden">
                                        <img src={imageMap[selectedGodDetails.image]} alt={selectedGodDetails.name} className="w-full h-full object-cover rounded-full" />
                                    </div>
                                    <div>
                                        <h4 className="font-title text-4xl text-yellow-400">{selectedGodDetails.name}</h4>
                                        <p className="text-gray-400">{selectedGodDetails.description}</p>
                                    </div>
                                </div>

                                {/* Favor Bar */}
                                <div className="mt-4">
                                    <h5 className="text-lg font-bold mb-2">Favor for {selectedGodName}</h5>
                                    <div className="bg-gray-700 rounded-full h-6 border border-gray-600">
                                        <div
                                            className="bg-blue-500 h-full rounded-full text-center text-white text-sm flex items-center justify-center transition-all duration-500"
                                            style={{ width: `${favorPercentage}%` }}
                                        >
                                            <span>{Math.floor(favor)} / {maxFavor}</span>
                                        </div>
                                    </div>
                                    <p className="text-xs text-gray-500 text-center mt-1">Favor increases over time based on this city's Temple level.</p>
                                </div>

                                <div className="grid grid-cols-2 gap-4 mt-6">
                                    <div>
                                        <h5 className="text-lg font-bold mb-2 text-yellow-500">Divine Powers</h5>
                                        <ul className="list-disc list-inside text-gray-300">
                                            {selectedGodDetails.powers.map(power => <li key={power.name}>{power.name}</li>)}
                                        </ul>
                                    </div>
                                    <div>
                                        <h5 className="text-lg font-bold mb-2 text-yellow-500">Mythical Units</h5>
                                        <ul className="list-disc list-inside text-gray-300">
                                            {selectedGodDetails.mythical_units.map(unit => <li key={unit}>{unit}</li>)}
                                        </ul>
                                    </div>
                                </div>
                            </>
                        ) : (
                            <p className="text-center p-10">Select a god to view their details.</p>
                        )}
                    </div>
                </div>

                <div className="mt-6">
                    <button
                        onClick={() => onWorship(selectedGodName)}
                        disabled={buttonDisabled}
                        className={`w-full py-3 btn text-lg ${buttonDisabled ? 'btn-disabled' : 'btn-confirm'}`}
                    >
                        {buttonText}
                    </button>
                </div>
            </div>
        </div>
    );
};

export default TempleMenu;
</file>

<file path="src/components/city/UnitQueue.js">
// src/components/city/UnitQueue.js
import React from 'react';
import unitConfig from '../../gameData/units.json';

// Dynamically import all unit images
const unitImages = {};
const imageContext = require.context('../../images', false, /\.(png|jpe?g|svg)$/);
imageContext.keys().forEach((item) => {
    const key = item.replace('./', '');
    unitImages[key] = imageContext(item);
});


const UnitQueueItem = ({ item, onCancel }) => {
    const unit = unitConfig[item.unitId];
    if (!unit) return null;

    const imageSrc = unitImages[unit.image];

    return (
        <div className="relative w-16 h-16 bg-gray-700 border-2 border-gray-600 rounded-md flex-shrink-0" title={`${item.amount}x ${unit.name}`}>
            <img src={imageSrc} alt={unit.name} className="w-full h-full object-contain p-1" />
            <span className="absolute bottom-0 right-0 text-white bg-black bg-opacity-75 px-1.5 py-0.5 text-xs font-bold rounded-tl-md rounded-br-md">{item.amount}</span>
            <button
                onClick={onCancel}
                className="absolute -top-2 -right-2 w-5 h-5 flex items-center justify-center bg-red-600 text-white rounded-full font-bold text-xs hover:bg-red-500 transition-colors z-10"
                title="Cancel Training"
            >
                &times;
            </button>
        </div>
    );
};


const UnitQueue = ({ unitQueue, onCancel }) => {
    if (!unitQueue || unitQueue.length === 0) {
        return (
            <div className="mt-auto pt-4">
                 <h4 className="text-lg font-semibold text-yellow-400 mb-2">In Training (0/5)</h4>
                 <div className="flex space-x-3 bg-gray-900 p-2 rounded-lg h-24 items-center justify-center">
                    <p className="text-gray-500">Queue is empty.</p>
                 </div>
            </div>
        );
    }

    return (
        <div className="mt-auto pt-4">
            <h4 className="text-lg font-semibold text-yellow-400 mb-2">In Training ({unitQueue.length}/5)</h4>
            <div className="flex space-x-3 bg-gray-900 p-2 rounded-lg overflow-x-auto h-24 items-center">
                {unitQueue.map((item, index) => (
                    <UnitQueueItem key={`${item.unitId}-${index}`} item={item} onCancel={() => onCancel(index)} />
                ))}
            </div>
        </div>
    );
};

export default UnitQueue;
</file>

<file path="src/components/city/WorshipDisplay.js">
// src/components/city/WorshipDisplay.js
import React from 'react';
import godsConfig from '../../gameData/gods.json';

// Dynamically import all images from the images/gods folder
const images = require.context('../../images/gods', false, /\.(png|jpe?g|svg)$/);
const imageMap = images.keys().reduce((acc, item) => {
    const key = item.replace('./', '');
    acc[key] = images(item);
    return acc;
}, {});


const WorshipDisplay = ({ godName, playerReligion, worship, buildings, onOpenPowers }) => {

    const getGodDetails = (name, religion) => {
        if (!name || !religion) return null;
        const religionKey = religion.toLowerCase();
        const pantheon = godsConfig[religionKey];
        if (!pantheon) return null;
        return Object.values(pantheon).find(g => g.name === name);
    };

    const godDetails = getGodDetails(godName, playerReligion);

    const favor = godName && worship ? (worship[godName] || 0) : 0;
    const templeLevel = buildings?.temple?.level || 0;
    const maxFavor = templeLevel > 0 ? 100 + (templeLevel * 20) : 0;

    return (
        <div className="bg-gray-800 rounded-lg shadow-lg p-4 border-2 border-yellow-500 w-48 mb-4">
            <h3 className="font-title text-xl text-yellow-300 text-center mb-2">Worshipping</h3>
            {godName && godDetails ? (
                <div className="text-center">
                    <img src={imageMap[godDetails.image]} alt={godDetails.name} className="w-24 h-24 mx-auto rounded-full border-4 border-yellow-500" />
                    <p className="text-lg font-bold text-white mt-2">{godName}</p>
                    <p className="text-sm text-blue-300 mt-2">Favor: {Math.floor(favor)} / {maxFavor}</p>
                    <button onClick={onOpenPowers} className="btn btn-primary w-full mt-4 py-1">View Spells</button>
                </div>
            ) : (
                <p className="text-gray-400 text-center text-sm">Build a Temple to worship a god.</p>
            )}
        </div>
    );
};

export default WorshipDisplay;
</file>

<file path="src/components/icons/EyeIcon.js">
import React from 'react';

const EyeIcon = (props) => (
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    strokeWidth="2"
    strokeLinecap="round"
    strokeLinejoin="round"
    {...props}
  >
    <path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z" />
    <circle cx="12" cy="12" r="3" />
  </svg>
);

export default EyeIcon;
</file>

<file path="src/components/icons/EyeOffIcon.js">
import React from 'react';

const EyeOffIcon = (props) => (
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    strokeWidth="2"
    strokeLinecap="round"
    strokeLinejoin="round"
    {...props}
  >
    <path d="M9.88 9.88a3 3 0 1 0 4.24 4.24" />
    <path d="M10.73 5.08A10.43 10.43 0 0 1 12 5c7 0 10 7 10 7a13.16 13.16 0 0 1-1.67 2.68" />
    <path d="M6.61 6.61A13.526 13.526 0 0 0 2 12s3 7 10 7a9.74 9.74 0 0 0 5.39-1.61" />
    <line x1="2" x2="22" y1="2" y2="22" />
  </svg>
);

export default EyeOffIcon;
</file>

<file path="src/components/map/AllianceModal.css">
.alliance-modal {
    @apply bg-gray-800 text-white rounded-lg shadow-xl w-full max-w-4xl border-2 border-gray-600 flex flex-col;
    height: 80vh;
}

.alliance-modal-header {
    @apply flex justify-between items-center p-4 border-b border-gray-700;
}

.alliance-modal-header .close-button {
    @apply text-gray-400 text-3xl leading-none hover:text-white;
}

.alliance-modal-tabs {
    @apply flex border-b border-gray-700;
}

.alliance-modal-tabs button {
    @apply px-6 py-3 text-gray-400 hover:bg-gray-700 hover:text-white focus:outline-none;
}

.alliance-modal-tabs button.active {
    @apply bg-gray-700 text-white border-b-2 border-blue-500;
}

.alliance-modal-content {
    @apply p-6 overflow-y-auto;
}
</file>

<file path="src/components/map/AllianceModal.js">
// src/components/map/AllianceModal.js
import React, { useState } from 'react';
import { useGame } from '../../contexts/GameContext';
import AllianceOverview from '../alliance/AllianceOverview';
import AllianceMembers from '../alliance/AllianceMembers';
import AllianceResearch from '../alliance/AllianceResearch';
import AllianceDiplomacy from '../alliance/AllianceDiplomacy';
import './AllianceModal.css';

const AllianceModal = ({ onClose }) => {
    const { playerAlliance } = useGame();
    const [activeTab, setActiveTab] = useState('overview');

    // This modal will now only render if the player is in an alliance.
    // The decision to show the creation modal is handled in MapView.
    if (!playerAlliance) {
        return null;
    }

    const renderTabContent = () => {
        switch (activeTab) {
            case 'overview':
                return <AllianceOverview />;
            case 'members':
                return <AllianceMembers />;
            case 'research':
                return <AllianceResearch />;
            case 'diplomacy':
                return <AllianceDiplomacy />;
            default:
                return <AllianceOverview />;
        }
    };

    return (
        <div className="fixed inset-0 bg-black bg-opacity-70 z-50 flex items-center justify-center" onClick={onClose}>
            <div className="alliance-modal" onClick={e => e.stopPropagation()}>
                <div className="alliance-modal-header">
                    <h2 className="font-title text-3xl">{playerAlliance.name} [{playerAlliance.tag}]</h2>
                    <button onClick={onClose} className="close-button">&times;</button>
                </div>
                <div className="alliance-modal-tabs">
                    <button onClick={() => setActiveTab('overview')} className={activeTab === 'overview' ? 'active' : ''}>Overview</button>
                    <button onClick={() => setActiveTab('members')} className={activeTab === 'members' ? 'active' : ''}>Members</button>
                    <button onClick={() => setActiveTab('research')} className={activeTab === 'research' ? 'active' : ''}>Research</button>
                    <button onClick={() => setActiveTab('diplomacy')} className={activeTab === 'diplomacy' ? 'active' : ''}>Diplomacy</button>
                </div>
                <div className="alliance-modal-content">
                    {renderTabContent()}
                </div>
            </div>
        </div>
    );
};

export default AllianceModal;
</file>

<file path="src/components/map/Countdown.js">
import React, { useState, useEffect } from 'react';

// Countdown component displays a live countdown to an arrival time.
const Countdown = ({ arrivalTime }) => {
    const [timeLeft, setTimeLeft] = useState('');

    useEffect(() => {
        const calculateTimeLeft = () => {
            // Ensure arrivalTime is a valid Firestore Timestamp object with toDate() method
            if (!arrivalTime?.toDate) {
                setTimeLeft('Invalid Date');
                return;
            }
            const now = new Date();
            const arrival = arrivalTime.toDate();
            const difference = arrival - now;

            if (difference > 0) {
                // Calculate hours, minutes, and seconds remaining
                const hours = Math.floor((difference / (1000 * 60 * 60)));
                const minutes = Math.floor((difference / 1000 / 60) % 60);
                const seconds = Math.floor((difference / 1000) % 60);
                // Format time to HH:MM:SS
                setTimeLeft(`${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`);
            } else {
                setTimeLeft('Arrived'); // Display 'Arrived' when time is up
            }
        };

        calculateTimeLeft(); // Initial calculation
        const interval = setInterval(calculateTimeLeft, 1000); // Update every second

        // Cleanup function to clear the interval when the component unmounts
        return () => clearInterval(interval);
    }, [arrivalTime]); // Recalculate if arrivalTime changes

    return <span>{timeLeft}</span>;
};

export default Countdown;
</file>

<file path="src/components/map/FarmingVillageModal.js">
// spolkip/grepowannabe/GrepoWannaBe-5544cda57432422293cb198ff3dc712e3b3b7cd2/src/components/map/FarmingVillageModal.js
import React, { useState, useEffect } from 'react';
import Countdown from './Countdown';
import { db } from '../../firebase/config';
import { doc, runTransaction, serverTimestamp, onSnapshot} from 'firebase/firestore'; // Added getDoc
import { useAuth } from '../../contexts/AuthContext';
import { useGame } from '../../contexts/GameContext';
import resourceImage from '../../images/resources/resources.png';
import woodImage from '../../images/resources/wood.png';
import stoneImage from '../../images/resources/stone.png';
import silverImage from '../../images/resources/silver.png';

const FarmingVillageModal = ({ village: initialVillage, onClose, worldId }) => {
    const { currentUser } = useAuth();
    const { gameState, setGameState } = useGame();
    const [village, setVillage] = useState(initialVillage);
    const [baseVillageData, setBaseVillageData] = useState(initialVillage); // Initialize with prop to prevent loading bug
    const [isProcessing, setIsProcessing] = useState(false);
    const [message, setMessage] = useState('');
    const [timeSinceCollection, setTimeSinceCollection] = useState(Infinity);
    const [activeTab, setActiveTab] = useState('demand');
    const [tradeAmount, setTradeAmount] = useState(0);

    const resourceImages = {
        wood: woodImage,
        stone: stoneImage,
        silver: silverImage,
    };

    // Listen for real-time updates on BOTH player's conquered village and the base village data
    useEffect(() => {
        if (!worldId || !village?.id || !currentUser) return;

        // Listener for player-specific data
        const playerVillageRef = doc(db, 'users', currentUser.uid, 'games', worldId, 'conqueredVillages', village.id);
        const unsubscribePlayerVillage = onSnapshot(playerVillageRef, (docSnap) => {
            if (docSnap.exists()) {
                // Merge player-specific updates into the main village state
                setVillage(prev => ({ ...prev, ...docSnap.data() }));
            }
        });

        // Listener for base village data (for real-time resource updates)
        const baseVillageRef = doc(db, 'worlds', worldId, 'villages', village.id);
        const unsubscribeBaseVillage = onSnapshot(baseVillageRef, (docSnap) => {
            if (docSnap.exists()) {
                setBaseVillageData(docSnap.data());
            }
        });

        return () => {
            unsubscribePlayerVillage();
            unsubscribeBaseVillage();
        };
    }, [worldId, village.id, currentUser]);

    const demandOptions = [
        { name: '5 minutes', duration: 300, multiplier: 0.125 },
        { name: '40 minutes', duration: 2400, multiplier: 1 },
        { name: '2 hours', duration: 7200, multiplier: 3 },
        { name: '4 hours', duration: 14400, multiplier: 4 },
    ];

    useEffect(() => {
        if (village && village.lastCollected) {
            const updateTimer = () => {
                const lastCollectedTime = village.lastCollected.toDate().getTime();
                const since = Math.floor((Date.now() - lastCollectedTime) / 1000);
                setTimeSinceCollection(since);
            };
            updateTimer();
            const interval = setInterval(updateTimer, 1000);
            return () => clearInterval(interval);
        }
    }, [village]);

    const getUpgradeCost = (level) => {
        return {
            wood: Math.floor(200 * Math.pow(1.6, level - 1)),
            stone: Math.floor(200 * Math.pow(1.6, level - 1)),
            silver: Math.floor(100 * Math.pow(1.8, level - 1)),
        };
    };

    const handleDemand = async (option) => {
        if (isProcessing || !baseVillageData) return;
        setIsProcessing(true);
        setMessage('');

        const playerVillageRef = doc(db, 'users', currentUser.uid, 'games', worldId, 'conqueredVillages', village.id);
        const gameDocRef = doc(db, 'users', currentUser.uid, 'games', worldId);

        try {
            await runTransaction(db, async (transaction) => {
                const playerVillageDoc = await transaction.get(playerVillageRef);
                const gameDoc = await transaction.get(gameDocRef);

                if (!playerVillageDoc.exists() || !gameDoc.exists()) throw new Error("Your village or game state not found.");

                const villageData = playerVillageDoc.data();
                const gameData = gameDoc.data();

                const lastCollectedTime = villageData.lastCollected?.toDate().getTime() || 0;
                if (Date.now() < lastCollectedTime + option.duration * 1000) {
                    throw new Error('Not enough time has passed for this demand option.');
                }

                const newResources = { ...gameData.resources };
                const warehouseCapacity = 1000 * Math.pow(1.5, gameData.buildings.warehouse.level - 1);

                const yieldAmount = {
                    wood: Math.floor((baseVillageData.demandYield.wood || 0) * option.multiplier * villageData.level),
                    stone: Math.floor((baseVillageData.demandYield.stone || 0) * option.multiplier * villageData.level),
                    silver: Math.floor((baseVillageData.demandYield.silver || 0) * option.multiplier * villageData.level),
                }

                for (const [resource, amount] of Object.entries(yieldAmount)) {
                    newResources[resource] = Math.min(warehouseCapacity, (newResources[resource] || 0) + amount);
                }

                transaction.update(gameDocRef, { resources: newResources });
                transaction.update(playerVillageRef, { lastCollected: serverTimestamp() });
            });

            setMessage(`Successfully demanded resources!`);

        } catch (error) {
            setMessage(`Failed to demand resources: ${error.message}`);
        } finally {
            setIsProcessing(false);
        }
    };

    const handleUpgrade = async () => {
        if (isProcessing) return;
        setIsProcessing(true);
        setMessage('');

        const playerVillageRef = doc(db, 'users', currentUser.uid, 'games', worldId, 'conqueredVillages', village.id);
        const gameDocRef = doc(db, 'users', currentUser.uid, 'games', worldId);
        const nextLevel = village.level + 1;
        const cost = getUpgradeCost(nextLevel);

        try {
            const newGameState = await runTransaction(db, async (transaction) => {
                const playerVillageDoc = await transaction.get(playerVillageRef);
                const gameDoc = await transaction.get(gameDocRef);

                if (!playerVillageDoc.exists() || !gameDoc.exists()) {
                    throw new Error("Your village or game state could not be found.");
                }

                const gameData = gameDoc.data();
                if (gameData.resources.wood < cost.wood || gameData.resources.stone < cost.stone || gameData.resources.silver < cost.silver) {
                    throw new Error("Not enough resources in your city to upgrade the village.");
                }

                const newResources = {
                    wood: gameData.resources.wood - cost.wood,
                    stone: gameData.resources.stone - cost.stone,
                    silver: gameData.resources.silver - cost.silver,
                };

                transaction.update(gameDocRef, { resources: newResources });
                transaction.update(playerVillageRef, { level: nextLevel });

                return { ...gameData, resources: newResources };
            });

            setGameState(newGameState);
            setMessage(`Successfully upgraded village to level ${nextLevel}!`);

        } catch (error) {
            console.error("Error upgrading village: ", error);
            setMessage(`Failed to upgrade village: ${error.message}`);
        } finally {
            setIsProcessing(false);
        }
    };

    const handleTrade = async () => {
        if (isProcessing || !baseVillageData || tradeAmount <= 0) return;
        setIsProcessing(true);
        setMessage('');
    
        const gameDocRef = doc(db, 'users', currentUser.uid, 'games', worldId);
        const villageRef = doc(db, 'worlds', worldId, 'villages', village.id);
    
        try {
            await runTransaction(db, async (transaction) => {
                const gameDoc = await transaction.get(gameDocRef);
                const villageDoc = await transaction.get(villageRef);
    
                if (!gameDoc.exists() || !villageDoc.exists()) throw new Error("Game state or village data not found.");
    
                const gameData = gameDoc.data();
                const villageData = villageDoc.data();
    
                const resourceToGive = villageData.demands;
                const resourceToGet = villageData.supplies;
                const amountToGet = Math.floor(tradeAmount / villageData.tradeRatio);
    
                if (gameData.resources[resourceToGive] < tradeAmount) {
                    throw new Error(`Not enough ${resourceToGive} to trade.`);
                }
                if (villageData.resources[resourceToGet] < amountToGet) {
                    throw new Error(`The village does not have enough ${resourceToGet} to trade.`);
                }
    
                const newPlayerResources = { ...gameData.resources };
                newPlayerResources[resourceToGive] -= tradeAmount;
                newPlayerResources[resourceToGet] += amountToGet;
    
                const newVillageResources = { ...villageData.resources };
                newVillageResources[resourceToGive] += tradeAmount;
                newVillageResources[resourceToGet] -= amountToGet;
    
                transaction.update(gameDocRef, { resources: newPlayerResources });
                transaction.update(villageRef, { resources: newVillageResources });
            });
    
            setMessage(`Successfully traded ${tradeAmount} ${baseVillageData.demands} for ${Math.floor(tradeAmount / baseVillageData.tradeRatio)} ${baseVillageData.supplies}.`);
            setTradeAmount(0);
        } catch (error) {
            setMessage(`Trade failed: ${error.message}`);
        } finally {
            setIsProcessing(false);
        }
    };

    const cost = getUpgradeCost(village.level + 1);
    const canAffordUpgrade = gameState && gameState.resources.wood >= cost.wood && gameState.resources.stone >= cost.stone && gameState.resources.silver >= cost.silver;

    const maxTradeAmount = baseVillageData && gameState ? Math.min(gameState.resources[baseVillageData.demands], Math.floor(baseVillageData.resources[baseVillageData.supplies] * baseVillageData.tradeRatio)) : 0;

    return (
        <div
            className="fixed inset-0 z-50 flex items-center justify-center pointer-events-none"
            onClick={onClose}
        >
            <div
                className="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-4xl text-center border border-gray-600 pointer-events-auto"
                onClick={e => e.stopPropagation()}
            >
                <h2 className="text-2xl font-bold mb-4 text-center text-yellow-400">{`Farming Village: ${baseVillageData?.name || village.name} (Level ${village.level})`}</h2>
                <div className="flex border-b border-gray-600 mb-4">
                    <button onClick={() => setActiveTab('demand')} className={`flex-1 p-2 text-lg font-bold transition-colors ${activeTab === 'demand' ? 'bg-gray-700 text-white' : 'bg-gray-800 text-gray-400 hover:bg-gray-700'}`}>Demand</button>
                    <button onClick={() => setActiveTab('trade')} className={`flex-1 p-2 text-lg font-bold transition-colors ${activeTab === 'trade' ? 'bg-gray-700 text-white' : 'bg-gray-800 text-gray-400 hover:bg-gray-700'}`}>Trade</button>
                    <button onClick={() => setActiveTab('upgrade')} className={`flex-1 p-2 text-lg font-bold transition-colors ${activeTab === 'upgrade' ? 'bg-gray-700 text-white' : 'bg-gray-800 text-gray-400 hover:bg-gray-700'}`}>Upgrade</button>
                </div>
                <div className="p-4 text-white">
                    {activeTab === 'demand' && (
                        <div>
                            <h4 className="font-bold text-lg text-center mb-2">Demand Resources</h4>
                            <p className="text-center text-gray-400 text-sm mb-4">Choose an option to demand resources. Shorter times yield fewer resources.</p>
                            <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                                {demandOptions.map(option => {
                                    const isAvailable = timeSinceCollection >= option.duration;
                                    const currentYield = {
                                        wood: baseVillageData ? Math.floor((baseVillageData.demandYield?.wood || 0) * option.multiplier * village.level) : 0,
                                        stone: baseVillageData ? Math.floor((baseVillageData.demandYield?.stone || 0) * option.multiplier * village.level) : 0,
                                        silver: baseVillageData ? Math.floor((baseVillageData.demandYield?.silver || 0) * option.multiplier * village.level) : 0
                                    };
                                    return (
                                        <div key={option.name} className="bg-gray-900 border border-gray-700 p-2 rounded-lg text-center flex flex-col justify-between shadow-md">
                                            <div className="relative h-16 mb-2 flex justify-center items-center">
                                                <img src={resourceImage} alt="resources" className="w-16 h-16"/>
                                            </div>
                                            <div className="text-xs space-y-1 mb-2 text-left">
                                                <p className="flex justify-between px-1"><span>Wood:</span> <span className="font-bold text-yellow-300">{currentYield.wood}</span></p>
                                                <p className="flex justify-between px-1"><span>Stone:</span> <span className="font-bold text-gray-300">{currentYield.stone}</span></p>
                                                <p className="flex justify-between px-1"><span>Silver:</span> <span className="font-bold text-blue-300">{currentYield.silver}</span></p>
                                            </div>
                                            <div className="mt-auto">
                                                {isAvailable ? (
                                                    <button
                                                        onClick={() => handleDemand(option)}
                                                        disabled={isProcessing}
                                                        className="btn btn-confirm w-full text-sm py-1"
                                                    >
                                                        Demand ({option.name})
                                                    </button>
                                                ) : (
                                                    <div className="text-center text-sm py-1 px-2 bg-gray-800 rounded">
                                                        <div className="font-mono text-red-400">
                                                            <Countdown arrivalTime={{ toDate: () => new Date(village.lastCollected.toDate().getTime() + option.duration * 1000) }} />
                                                        </div>
                                                    </div>
                                                )}
                                            </div>
                                        </div>
                                    )
                                })}
                            </div>
                        </div>
                    )}
                    {activeTab === 'trade' && (
                         <div>
                            <h4 className="font-bold text-lg text-center mb-2">Trade with Village</h4>
                            {baseVillageData ? (
                                <>
                                    <div className="flex justify-center items-center space-x-4 my-4">
                                        <div className="flex flex-col items-center">
                                            <span className="text-sm text-gray-400 capitalize">You Give</span>
                                            <img src={resourceImages[baseVillageData.demands]} alt={baseVillageData.demands} className="w-12 h-12" />
                                        </div>
                                        <span className="text-3xl text-gray-400 font-bold">&rarr;</span>
                                        <div className="flex flex-col items-center">
                                            <span className="text-sm text-gray-400 capitalize">You Receive</span>
                                            <img src={resourceImages[baseVillageData.supplies]} alt={baseVillageData.supplies} className="w-12 h-12" />
                                        </div>
                                    </div>
                                    <p className="text-center text-gray-400 text-sm mb-4">
                                        Trade Ratio: {baseVillageData.tradeRatio}:1
                                    </p>
                                    <div className="bg-gray-700 p-4 rounded-lg">
                                        <div className="flex justify-between items-center mb-2">
                                            <span className="capitalize">Your {baseVillageData.demands}: {Math.floor(gameState.resources[baseVillageData.demands] || 0)}</span>
                                            <span className="capitalize">Village's {baseVillageData.supplies}: {Math.floor(baseVillageData.resources[baseVillageData.supplies] || 0)}</span>
                                        </div>
                                        <input
                                            type="range"
                                            min="0"
                                            max={maxTradeAmount}
                                            value={tradeAmount}
                                            onChange={(e) => setTradeAmount(Number(e.target.value))}
                                            className="w-full"
                                        />
                                        <div className="flex justify-between items-center mt-2">
                                            <span className="capitalize">You give: <span className="font-bold text-red-400">{tradeAmount} {baseVillageData.demands}</span></span>
                                            <span className="capitalize">You receive: <span className="font-bold text-green-400">{Math.floor(tradeAmount / baseVillageData.tradeRatio)} {baseVillageData.supplies}</span></span>
                                        </div>
                                        <button
                                            onClick={handleTrade}
                                            disabled={isProcessing || tradeAmount <= 0 || maxTradeAmount <= 0}
                                            className="btn btn-confirm w-full mt-4 py-2"
                                        >
                                            Trade
                                        </button>
                                    </div>
                                </>
                            ) : (
                                <p className="text-center text-gray-400 p-8">Loading trade information...</p>
                            )}
                        </div>
                    )}
                     {activeTab === 'upgrade' && (
                        <div>
                            <p className="mb-4 text-center">Invest resources to upgrade this village for better yields.</p>
                            <div className="bg-gray-700 p-3 rounded-lg mb-4">
                                <h4 className="font-bold text-lg">Cost to Upgrade to Level {village.level + 1}:</h4>
                                <div className="flex justify-center space-x-4 mt-2 text-yellow-300">
                                    <span>🪵 {cost.wood}</span>
                                    <span>🪨 {cost.stone}</span>
                                    <span>⚪️ {cost.silver}</span>
                                </div>
                            </div>
                            <button
                                onClick={handleUpgrade}
                                disabled={isProcessing || !canAffordUpgrade}
                                className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded w-40 transition duration-300 disabled:bg-gray-500 disabled:cursor-not-allowed"
                            >
                                {isProcessing ? 'Processing...' : 'Upgrade Village'}
                            </button>
                        </div>
                    )}
                    {message && <p className="text-green-400 mt-4 text-center">{message}</p>}
                </div>
                 <button
                    onClick={onClose}
                    className="btn btn-primary px-6 py-2 mt-4"
                >
                    Close
                </button>
            </div>
        </div>
    );
};

export default FarmingVillageModal;
</file>

<file path="src/components/map/MapGrid.js">
// src/components/map/MapGrid.js
import React from 'react';
import { WaterTile, LandTile, CitySlotTile, FarmingVillageTile } from './Tiles';
import MovementIndicator from './MovementIndicator';

const TILE_SIZE = 32;
const defaultSettings = { animations: true, showVisuals: true, showGrid: true };

const MapGrid = ({ mapGrid, worldState, pan, zoom, viewportSize, onCitySlotClick, onVillageClick, isPlacingDummyCity, movements, combinedSlots, villages, playerAlliance, conqueredVillages, gameSettings = defaultSettings }) => {
    if (!mapGrid || !worldState?.islands || viewportSize.width === 0) return null;

    const scaledTileSize = TILE_SIZE * zoom;
    const startCol = Math.max(0, Math.floor(-pan.x / scaledTileSize));
    const endCol = Math.min(worldState.width, Math.ceil((-pan.x + viewportSize.width) / scaledTileSize));
    const startRow = Math.max(0, Math.floor(-pan.y / scaledTileSize));
    const endRow = Math.min(worldState.height, Math.ceil((-pan.y + viewportSize.height) / scaledTileSize));

    const visibleTiles = [];

    for (let y = startRow; y < endRow; y++) {
        for (let x = startCol; x < endCol; x++) {
            const tile = mapGrid[y][x];
            let tileContent;
            switch (tile.type) {
                case 'city_slot':
                    tileContent = <CitySlotTile slotData={tile.data} onClick={onCitySlotClick} isPlacingDummyCity={isPlacingDummyCity} playerAlliance={playerAlliance} gameSettings={gameSettings} />;
                    break;
                case 'village':
                    tileContent = <FarmingVillageTile villageData={tile.data} onClick={onVillageClick} conqueredVillages={conqueredVillages} gameSettings={gameSettings} />;
                    break;
                case 'land':
                    tileContent = <LandTile gameSettings={gameSettings} />;
                    break;
                default:
                    tileContent = <WaterTile gameSettings={gameSettings} />;
                    break;
            }
            visibleTiles.push(
                <div
                    key={`tile-${x}-${y}`}
                    className="map-tile"
                    style={{ position: 'absolute', left: x * TILE_SIZE, top: y * TILE_SIZE, width: TILE_SIZE, height: TILE_SIZE }}
                >
                    {tileContent}
                </div>
            );
        }
    }

    if (gameSettings.animations) {
        movements.forEach(movement => {
            visibleTiles.push(
                <MovementIndicator
                    key={`movement-${movement.id}`}
                    movement={movement}
                    citySlots={{...combinedSlots, ...villages}}
                    allMovements={movements}
                />
            );
        });
    }

    return <>{visibleTiles}</>;
};

export default MapGrid;
</file>

<file path="src/components/map/MapModals.js">
// src/components/map/MapModals.js
import React from 'react';
import OtherCityModal from './OtherCityModal';
import FarmingVillageModal from './FarmingVillageModal';
import MovementModal from './MovementModal';
import MovementsPanel from './MovementsPanel';
import ReportsView from '../ReportsView';
import MessagesView from '../messaging/MessagesView';
import AllianceCreation from '../alliance/AllianceCreation';

const MapModals = ({
    modalState,
    closeModal,
    gameState,
    playerCity,
    travelTimeInfo,
    handleSendMovement,
    setMessage,
    goToCoordinates,
    handleActionClick,
    worldId,
    movements,
    combinedSlots,
    villages,
    handleRushMovement,
    userProfile,
    onCastSpell
}) => {
    return (
        <>
            {modalState.selectedCity && (
                <OtherCityModal
                    city={modalState.selectedCity}
                    playerCity={playerCity}
                    travelTimeInfo={travelTimeInfo}
                    onSendMovement={handleSendMovement}
                    onClose={() => closeModal('city')}
                    onAction={handleActionClick}
                    gameState={gameState}
                    onCastSpell={onCastSpell}
                    isVillageTarget={modalState.selectedCity?.isVillageTarget}
                />
            )}
            {modalState.selectedVillage && (
                <FarmingVillageModal
                    village={modalState.selectedVillage}
                    onClose={() => closeModal('village')}
                    onActionClick={handleActionClick}
                    playerCity={playerCity}
                    worldId={worldId}
                />
            )}
            {modalState.actionDetails && (
                <MovementModal
                    mode={modalState.actionDetails.mode}
                    targetCity={modalState.actionDetails.city}
                    onClose={() => closeModal('action')}
                    onSend={handleSendMovement}
                    playerCity={playerCity}
                    gameState={gameState}
                    travelTimeInfo={travelTimeInfo}
                    setMessage={setMessage}
                />
            )}
            {modalState.isMovementsPanelOpen && (
                <MovementsPanel
                    movements={movements}
                    onClose={() => closeModal('movements')}
                    combinedSlots={combinedSlots}
                    villages={villages}
                    goToCoordinates={goToCoordinates}
                    onRush={handleRushMovement}
                    isAdmin={userProfile?.is_admin}
                />
            )}
            {modalState.isReportsPanelOpen && (
                <ReportsView onClose={() => closeModal('reports')} />
            )}
            {modalState.isMessagesPanelOpen && (
                <MessagesView 
                    onClose={() => closeModal('messages')} 
                    initialRecipientId={modalState.actionDetails?.city?.ownerId}
                    initialRecipientUsername={modalState.actionDetails?.city?.ownerUsername}
                />
            )}
            {modalState.isAllianceCreationOpen && (
                <AllianceCreation onClose={() => closeModal('allianceCreation')} />
            )}
        </>
    );
};

export default MapModals;
</file>

<file path="src/components/map/MovementIndicator.js">
import React from 'react';
import { motion } from 'framer-motion';

const TILE_SIZE = 32; // Assuming TILE_SIZE is consistent across map components
// Import unitConfig if needed for unit details, but it's not directly used in rendering here.
// import unitConfig from '../../gameData/units.json'; 

// MovementIndicator component visually represents ongoing troop movements on the map.
const MovementIndicator = React.memo(({ movement, citySlots, allMovements = [] }) => {
    // Ensure movement and citySlots data are available
    if (!movement || !citySlots) return null;

    const originCity = citySlots[movement.originCityId];
    const targetCity = citySlots[movement.targetCityId];
    
    // Ensure both origin and target cities exist in citySlots
    if (!originCity || !targetCity) return null;

    // Calculate departure and arrival times, defaulting to now if not available
    const departureTime = movement.departureTime?.toDate().getTime() || Date.now();
    const arrivalTime = movement.arrivalTime?.toDate().getTime() || Date.now();
    const now = Date.now();
    
    // Calculate movement progress (0 to 1)
    let progress = 0;
    if (now < departureTime) progress = 0; // Movement hasn't started
    else if (now > arrivalTime) progress = 1; // Movement has arrived
    else progress = (now - departureTime) / (arrivalTime - departureTime); // Calculate current progress

    // Calculate pixel coordinates for origin and target cities
    const originX = originCity.x * TILE_SIZE + TILE_SIZE / 2;
    const originY = originCity.y * TILE_SIZE + TILE_SIZE / 2;
    const targetX = targetCity.x * TILE_SIZE + TILE_SIZE / 2;
    const targetY = targetCity.y * TILE_SIZE + TILE_SIZE / 2;

    // Calculate current position of the indicator based on progress
    const currentX = originX + (targetX - originX) * progress;
    const currentY = originY + (targetY - originY) * progress;

    // Calculate remaining travel time in seconds for animation duration
    const remainingTime = Math.max(0, (arrivalTime - now) / 1000);
    
    // Calculate size of the indicator based on total units (visual representation of army size)
    // unitConfig would be needed here if calculating totalUnits based on individual unit sizes
    const totalUnits = movement.units ? Object.values(movement.units).reduce((sum, count) => sum + count, 0) : 0;
    const size = Math.min(24, 8 + Math.sqrt(totalUnits) * 2); // Cap size at 24px

    // Define configurations for different movement types (color, icon, line color)
    const movementTypes = {
        attack: { color: '#ef4444', icon: '⚔️', lineColor: '#ef4444' },
        reinforce: { color: '#3b82f6', icon: '🛡️', lineColor: '#3b82f6' },
        scout: { color: '#10b981', icon: '👁️', lineColor: '#10b981' },
        trade: { color: '#f59e0b', icon: '💰', lineColor: '#f59e0b' },
        default: { color: '#6b7280', icon: '➡️', lineColor: '#6b7280' }
    };

    const config = movementTypes[movement.type] || movementTypes.default; // Get config for current movement type

    // Find overlapping movements (going between same cities) to adjust line appearance
    const overlappingMovements = (Array.isArray(allMovements)) ? allMovements.filter(m => {
        if (!m || m.id === movement.id) return false; // Exclude self and invalid movements
        return (
            (m.originCityId === movement.originCityId && m.targetCityId === movement.targetCityId) ||
            (m.originCityId === movement.targetCityId && m.targetCityId === movement.originCityId)
        );
    }) : [];

    // Calculate blended color for overlapping movements (simple average of RGB)
    const getBlendedColor = () => {
        if (overlappingMovements.length === 0) return config.lineColor;
        
        const colors = [config.lineColor];
        overlappingMovements.forEach(m => {
            if (!m) return;
            const otherConfig = movementTypes[m.type] || movementTypes.default;
            colors.push(otherConfig.lineColor);
        });

        const blended = colors.reduce((acc, color) => {
            if (!color) return acc;
            const hex = color.replace('#', '');
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);
            return {
                r: acc.r + r,
                g: acc.g + g,
                b: acc.b + b,
                count: acc.count + 1
            };
        }, { r: 0, g: 0, b: 0, count: 0 });

        const avgR = Math.round(blended.r / blended.count);
        const avgG = Math.round(blended.g / blended.count);
        const avgB = Math.round(blended.b / blended.count);

        return `#${avgR.toString(16).padStart(2, '0')}${avgG.toString(16).padStart(2, '0')}${avgB.toString(16).padStart(2, '0')}`;
    };

    const lineColor = getBlendedColor();
    const lineWidth = 3 + (overlappingMovements.length * 1.5); // Thicker line for more overlaps

    return (
        <>
            {/* Movement line - shown for all movement types */}
            <div 
                className="absolute z-20"
                style={{
                    left: originX,
                    top: originY,
                    width: Math.sqrt(Math.pow(targetX - originX, 2) + Math.pow(targetY - originY, 2)), // Length of the line
                    height: lineWidth,
                    backgroundColor: lineColor,
                    opacity: 0.7,
                    transformOrigin: '0 0', // Rotate from the origin city
                    transform: `rotate(${Math.atan2(targetY - originY, targetX - originX)}rad)`, // Rotate to point towards target
                }}
            />
            
            {/* Movement indicator (animated dot/icon) */}
            <motion.div
                className="absolute z-30 flex items-center justify-center"
                style={{
                    left: currentX - size / 2, // Center the indicator
                    top: currentY - size / 2, // Center the indicator
                    width: size,
                    height: size,
                    backgroundColor: `${config.color}80`, // 50% opacity background
                    borderRadius: '50%', // Make it a circle
                    border: `2px solid ${config.color}`, // Solid border
                    fontSize: size * 0.6, // Adjust icon size based on indicator size
                }}
                // Animate the position from origin to target based on remaining time
                animate={{
                    x: [0, (targetX - originX) * (1 - progress)],
                    y: [0, (targetY - originY) * (1 - progress)],
                }}
                transition={{
                    duration: remainingTime, // Duration is remaining time
                    ease: "linear" // Linear movement
                }}
                whileHover={{ scale: 1.2 }} // Scale up on hover
            >
                {config.icon} {/* Display movement type icon */}
            </motion.div>
        </>
    );
});

export default MovementIndicator;
</file>

<file path="src/components/map/MovementItem.js">
// src/components/map/MovementItem.js
import React from 'react';
import Countdown from './Countdown'; // Import Countdown component
import unitConfig from '../../gameData/units.json'; // Import unit configuration

// MovementItem component displays details of a single troop movement.
const MovementItem = ({ movement, citySlots, onRush, isAdmin }) => {
    // Destructure currentUser from useAuth, assuming it's available in the parent context
    // For this standalone component, we'll assume currentUser is passed as a prop for simplicity
    // or fetched from a context within this component if it were truly standalone.
    // For now, let's assume it's passed from MapView.
    const currentUser = movement.originOwnerId; // Simplified for display, actual check is in parent

    const originCity = citySlots[movement.originCityId];
    const targetId = movement.targetCityId || movement.targetVillageId;
    const targetCity = citySlots[targetId];

    const isOutgoing = movement.originOwnerId === currentUser; // Determine if movement is outgoing for current user

    // Helper function to render details of units and resources involved in the movement
    const renderDetails = () => {
        let details = [];
        if (movement.units) {
            const units = Object.entries(movement.units).filter(([, count]) => count > 0);
            if (units.length > 0) {
                details.push(units.map(([id, count]) => `${count} ${unitConfig[id].name}`).join(', '));
            }
        }
        if (movement.resources) {
            const resources = Object.entries(movement.resources).filter(([, amount]) => amount > 0);
             if (resources.length > 0) {
                details.push(resources.map(([id, amount]) => `${amount} ${id}`).join(', '));
            }
        }
        return details.join(' & ');
    };
    
    // Determine the "from" and "to" cities based on movement status (moving or returning)
    const fromCity = movement.status === 'returning' ? targetCity : originCity;
    const toCity = movement.status === 'returning' ? originCity : targetCity;
    // Determine the action text (e.g., "Attack", "Reinforce", "Returning")
    const actionText = movement.status === 'returning' ? 'Returning' : movement.type;

    return (
        <div className={`bg-gray-700 p-4 rounded-lg border-l-4 ${isOutgoing ? 'border-red-500' : 'border-green-500'}`}>
            <div className="flex justify-between items-center">
                <div>
                    <p className="font-bold text-lg text-white capitalize">{actionText}</p>
                    <p className="text-sm text-gray-400">
                        From: {fromCity?.cityName || fromCity?.name || 'Unknown'} To: {toCity?.cityName || toCity?.name || 'Unknown'}
                    </p>
                </div>
                <div className="text-right">
                    {/* Display countdown to arrival time */}
                    <p className="text-white font-bold"><Countdown arrivalTime={movement.arrivalTime} /></p>
                    <p className="text-xs text-gray-400">Arrival</p>
                </div>
            </div>
            <p className="text-sm text-gray-300 mt-2">{renderDetails()}</p>
            {/* Admin "Rush" button, visible only to admins */}
            {isAdmin && (
                <button onClick={() => onRush(movement.id)} className="btn btn-primary text-xs px-2 py-1 mt-2">Rush</button>
            )}
        </div>
    );
};

export default MovementItem;
</file>

<file path="src/components/map/MovementModal.js">
// src/components/map/MovementModal.js
import React, { useState, useMemo, useEffect } from 'react';
import { calculateTravelTime, formatTravelTime } from '../../utils/travel';
import unitConfig from '../../gameData/units.json';
import { useGame } from '../../contexts/GameContext';

// Import new panels
import TradePanel from './TradePanel';
import ScoutPanel from './ScoutPanel';

// Dynamically import all images from the images folder (this is for unit images)
const images = {};
const imageContexts = [
    require.context('../../images', false, /\.(png|jpe?g|svg)$/),
    require.context('../../images/resources', false, /\.(png|jpe?g|svg)$/),
];

imageContexts.forEach(context => {
    context.keys().forEach((item) => {
        const key = item.replace('./', '');
        images[key] = context(item);
    });
});

// MovementModal component allows players to send units or resources for various actions.
const MovementModal = ({ mode, targetCity, playerCity, playerUnits: initialPlayerUnits, playerResources: initialPlayerResources, travelTimeInfo, onSend, onClose, setMessage }) => {
    const { gameState } = useGame();

    const currentUnits = initialPlayerUnits || gameState?.units || {};
    const currentResources = initialPlayerResources || gameState?.resources || {};

    const [selectedUnits, setSelectedUnits] = useState({});
    const [selectedResources, setSelectedResources] = useState({ wood: 0, stone: 0, silver: 0 });
    const [attackLayers, setAttackLayers] = useState({
        front: '',
        mid: '',
        back: ''
    });

    const transportCapacity = useMemo(() => {
        let capacity = 0;
        for (const unitId in selectedUnits) {
            if (unitConfig[unitId]?.type === 'naval' && unitConfig[unitId]?.capacity) {
                capacity += selectedUnits[unitId] * unitConfig[unitId].capacity;
            }
        }
        return capacity;
    }, [selectedUnits]);

    const currentUnitsLoad = useMemo(() => {
        let load = 0;
        for (const unitId in selectedUnits) {
            if (unitConfig[unitId]?.type === 'land' && unitConfig[unitId]?.cost?.population) {
                load += selectedUnits[unitId] * unitConfig[unitId].cost.population;
            }
        }
        return load;
    }, [selectedUnits]);

    useEffect(() => {
        const newAttackLayers = { ...attackLayers };
        let needsReset = false;
        for (const layer in newAttackLayers) {
            const unitId = newAttackLayers[layer];
            if (unitId && (!selectedUnits[unitId] || selectedUnits[unitId] === 0)) {
                newAttackLayers[layer] = '';
                needsReset = true;
            }
        }
        if (needsReset) {
            setAttackLayers(newAttackLayers);
        }
    }, [selectedUnits, attackLayers]);

    const handleUnitChange = (unitId, value) => {
        const amount = Math.max(0, Math.min(currentUnits[unitId] || 0, parseInt(value, 10) || 0));
        setSelectedUnits(prev => ({ ...prev, [unitId]: amount }));
    };

    const handleResourceChange = (resource, value) => {
        const parsedAmount = parseInt(value, 10) || 0;
        let amount = parsedAmount;

        if (mode === 'scout' && resource === 'silver') {
            const availableCaveSilver = gameState.cave?.silver || 0;
            amount = Math.max(0, Math.min(availableCaveSilver, parsedAmount));
        } else {
            amount = Math.max(0, Math.min(currentResources[resource] || 0, parsedAmount));
        }
        setSelectedResources(prev => ({ ...prev, [resource]: amount }));
    };

    const handleLayerChange = (layerName, unitId) => {
        setAttackLayers(prev => {
            const newLayers = { ...prev, [layerName]: unitId };
            return newLayers;
        });
    };

    const slowestSpeed = useMemo(() => {
        if (mode === 'trade' || mode === 'scout') return 10;
        const speeds = Object.entries(selectedUnits)
            .filter(([, count]) => count > 0)
            .map(([unitId]) => unitConfig[unitId].speed);
        return speeds.length > 0 ? Math.min(...speeds) : null;
    }, [selectedUnits, mode]);

    const finalTravelTime = useMemo(() => {
        if (!travelTimeInfo?.distance || !slowestSpeed) return 'N/A';
        const timeInSeconds = calculateTravelTime(travelTimeInfo.distance, slowestSpeed);
        return formatTravelTime(timeInSeconds);
    }, [slowestSpeed, travelTimeInfo?.distance]);

    const handleSend = () => {
        let totalUnitsSelected = Object.values(selectedUnits).reduce((sum, count) => sum + count, 0);
        let totalResourcesSelected = Object.values(selectedResources).reduce((sum, amount) => sum + amount, 0);

        if ((mode === 'attack' || mode === 'reinforce') && totalUnitsSelected === 0) {
            setMessage("Please select at least one unit to send for attack or reinforcement.");
            return;
        }
        if (mode === 'scout') {
            const silverForScout = selectedResources.silver || 0;
            if (silverForScout <= 0) {
                setMessage("Please enter an amount of silver for scouting.");
                return;
            }
            if (silverForScout > (gameState.cave?.silver || 0)) {
                setMessage("Not enough silver in the cave for scouting.");
                return;
            }
        }
        if (mode === 'trade' && totalResourcesSelected === 0) {
            setMessage("Please select at least one resource to trade.");
            return;
        }

        const hasLandUnitsSelected = Object.keys(selectedUnits).some(unitId => unitConfig[unitId]?.type === 'land' && selectedUnits[unitId] > 0);
        const hasNavalUnitsSelected = Object.keys(selectedUnits).some(unitId => unitConfig[unitId]?.type === 'naval' && selectedUnits[unitId] > 0);

        if (hasLandUnitsSelected && hasNavalUnitsSelected && currentUnitsLoad > transportCapacity) {
            setMessage(`Not enough transport ship capacity. You need ${currentUnitsLoad - transportCapacity} more capacity.`);
            return;
        }

        if (mode === 'attack') {
            const selectedLayerUnits = Object.values(attackLayers).filter(unitId => unitId !== '');
            const uniqueLayerUnits = new Set(selectedLayerUnits);

            if (selectedLayerUnits.length !== uniqueLayerUnits.size) {
                setMessage("Each attack formation layer must have a unique unit selected.");
                return;
            }

            for (const layerName in attackLayers) {
                const unitId = attackLayers[layerName];
                if (unitId !== '' && (selectedUnits[unitId] || 0) === 0) {
                    setMessage(`Your selected ${layerName} unit (${unitConfig[unitId].name}) has 0 troops in the current selection. Please adjust unit counts or selection.`);
                    return;
                }
                if (unitId !== '' && unitConfig[unitId]?.type !== 'land') {
                    setMessage(`The unit selected for ${layerName} (${unitConfig[unitId].name}) must be a land unit.`);
                    return;
                }
            }
        }

        const resourcesToSend = {};
        if (mode === 'scout') {
            resourcesToSend.silver = selectedResources.silver;
        } else if (mode === 'trade') {
            Object.assign(resourcesToSend, selectedResources);
        }

        onSend({
            mode,
            targetCity,
            units: mode === 'scout' || mode === 'trade' ? {} : selectedUnits,
            resources: resourcesToSend,
            travelTime: finalTravelTime,
            attackFormation: mode === 'attack' ? attackLayers : {}
        });
        onClose();
    };
    
    const renderContent = () => {
        const landUnitsList = Object.keys(unitConfig)
            .filter(unitId => unitConfig[unitId].type === 'land')
            .map(unitId => ({
                id: unitId,
                ...unitConfig[unitId],
                currentCount: currentUnits[unitId] || 0
            }));

        const navalUnitsList = Object.keys(unitConfig)
            .filter(unitId => unitConfig[unitId].type === 'naval')
            .map(unitId => ({
                id: unitId,
                ...unitConfig[unitId],
                currentCount: currentUnits[unitId] || 0
            }));

        const selectedLandUnitsForFormation = Object.keys(selectedUnits).filter(unitId => 
            selectedUnits[unitId] > 0 && unitConfig[unitId]?.type === 'land'
        );

        const attackLayerOptions = [
            { name: 'front', label: 'Front Line' },
            { name: 'mid', label: 'Mid Line' },
            { name: 'back', 'label': 'Back Line' }
        ];

        const capacityProgress = transportCapacity > 0 ? (currentUnitsLoad / transportCapacity) * 100 : 0;
        const progressBarColor = capacityProgress > 100 ? 'bg-red-500' : 'bg-green-500';

        if (mode === 'attack' || mode === 'reinforce') {
            return (
                <div className="space-y-4">
                    {/* Land Units Section */}
                    {landUnitsList.length > 0 && (
                        <div className="bg-gray-700 p-3 rounded-lg ">
                            <h4 className="font-bold text-lg text-yellow-300">Land Units</h4>
                            <div className="grid grid-cols-3 sm:grid-cols-6 gap-0 ">
                                {landUnitsList.map(unit => (
                                    <div key={unit.id} className="flex flex-col items-center p-1 rounded-lg w-12">
                                        <div className="relative w-11 h-12 mb-1">
                                            <img src={images[unit.image]} alt="" className="w-full h-full object-cover rounded-md " />
                                             <span className="absolute bottom-0 right-0 bg-gray-900 text-white text-xs px-1 rounded-tl-md font-bold">
                                                {unit.currentCount}
                                            </span>
                                        </div>
                                        <input
                                            type="number"
                                            value={selectedUnits[unit.id] || 0}
                                            onChange={(e) => handleUnitChange(unit.id, e.target.value)}
                                            className="w-12 bg-gray-900 text-white text-center rounded p-0.5 text-sm hide-number-spinners"
                                            min="0"
                                            max={unit.currentCount}
                                        />
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}

                    {/* Naval Units Section */}
                    {navalUnitsList.length > 0 && (
                        <div className="bg-gray-700 p-3 rounded-lg">
                            <h4 className="font-bold text-lg text-yellow-300">Naval Units</h4>
                            <div className="grid grid-cols-3 sm:grid-cols-6 gap-1">
                                {navalUnitsList.map(unit => (
                                    <div key={unit.id} className="flex flex-col items-center p-1">
                                        <div className="relative w-12 h-12">
                                            <img src={images[unit.image]} alt={unit.name} className="w-full h-full object-cover rounded-md" />
                                            <span className="absolute bottom-0 right-0 bg-gray-900 text-white text-xs px-1 rounded-tl-md font-bold">
                                                {unit.currentCount}
                                            </span>
                                        </div>
                                        <input
                                            type="number"
                                            value={selectedUnits[unit.id] || 0}
                                            onChange={(e) => handleUnitChange(unit.id, e.target.value)}
                                            className="w-12 bg-gray-900 text-white text-center rounded p-0.5 text-sm"
                                            min="0"
                                            max={unit.currentCount}
                                        />
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}

                    {/* Transport Capacity Bar */}
                    {transportCapacity > 0 && (
                        <div className="mt-4 pt-4 border-t border-gray-700">
                            <h4 className="text-lg text-white font-bold">Transport Capacity</h4>
                            <div className="w-full bg-gray-700 rounded-full h-6 relative">
                                <div 
                                    className={`h-full rounded-full ${progressBarColor}`} 
                                    style={{ width: `${Math.min(100, capacityProgress)}%` }}
                                ></div>
                                <div className="absolute inset-0 flex items-center justify-center text-white text-sm font-bold">
                                    {currentUnitsLoad} / {transportCapacity}
                                </div>
                            </div>
                            {capacityProgress > 100 && (
                                <p className="text-red-400 text-sm mt-1">Over capacity! Reduce land units or add more transport ships.</p>
                            )}
                        </div>
                    )}

                                      {mode === 'attack' && selectedLandUnitsForFormation.length > 0 && (
                        <div className="mt-4 pt-4 border-t border-gray-700">
                            <h4 className="text-lg text-white font-bold mb-2">Attack Formation</h4>
                            {/* Render dropdowns for each attack layer */}
                            {attackLayerOptions.map(layer => (
                                <div key={layer.name} className="flex flex-col space-y-2 mt-2">
                                    <label className="text-white">{layer.label}:</label>
                                    <select
                                        value={attackLayers[layer.name]}
                                        onChange={(e) => handleLayerChange(layer.name, e.target.value)}
                                        className="bg-gray-700 text-white rounded p-2"
                                    >
                                        <option value="">None</option>
                                        {/* Filter out units already selected in other layers AND units not selected for attack */}
                                        {selectedLandUnitsForFormation
                                            .filter(unitId => !Object.entries(attackLayers).some(([key, selectedUnit]) => selectedUnit === unitId && key !== layer.name))
                                            .map(unitId => (
                                                <option key={unitId} value={unitId}>{unitConfig[unitId].name}</option>
                                            ))}
                                    </select>
                                </div>
                            ))}
                        </div>
                    )}
                     {mode === 'attack' && selectedLandUnitsForFormation.length === 0 && (
                        <div className="mt-4 pt-4 border-t border-gray-700">
                            <p className="text-gray-400">Select land units to configure attack formation.</p>
                        </div>
                    )}
                </div>
            );
        }
        if (mode === 'scout') {
            return (
                <ScoutPanel
                    selectedResources={selectedResources}
                    gameState={gameState}
                    handleResourceChange={handleResourceChange}
                />
            );
        }
        if (mode === 'trade') {
            return (
                <TradePanel
                    selectedResources={selectedResources}
                    currentResources={currentResources}
                    handleResourceChange={handleResourceChange}
                />
            );
        }
        return null;
    };

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-transparent" onClick={onClose}>
            <div className="bg-gray-800 rounded-lg shadow-xl p-6 w-[400px] max-h-[90vh] border-2 border-gray-600" onClick={e => e.stopPropagation()}>
                <h3 className="font-title text-2xl text-white mb-4 capitalize">{mode} {targetCity ? targetCity.cityName || targetCity.name : ''}</h3>
                <div className="max-h-[70vh] overflow-y-auto pr-2">
                    {renderContent()}
                </div>
                <p className="text-gray-400 mt-4">Travel Time: <span className="font-bold text-yellow-300">{finalTravelTime}</span></p>
                <button onClick={handleSend} className="btn btn-primary w-full py-2 mt-6">
                    Send
                </button>
            </div>
        </div>
    );
};

export default MovementModal;
</file>

<file path="src/components/map/MovementsPanel.js">
// src/components/map/MovementsPanel.js
import React from 'react';
import MovementItem from './MovementItem'; // Import MovementItem component

// MovementsPanel component displays a list of all active troop movements.
const MovementsPanel = ({ movements, onClose, combinedSlots, villages, onRush, isAdmin }) => {
    const allLocations = { ...combinedSlots, ...villages };

    return (
        <div className="fixed inset-0 z-40 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            <div className="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-2xl border-2 border-gray-600" onClick={e => e.stopPropagation()}>
                <div className="flex justify-between items-center mb-4">
                    <h3 className="font-title text-3xl text-white">Movements</h3>
                    <button onClick={onClose} className="text-gray-400 text-3xl leading-none hover:text-white">&times;</button>
                </div>
                <div className="space-y-4 max-h-96 overflow-y-auto">
                    {movements.length > 0 ? movements.map(movement => (
                        // Render each movement using the MovementItem component
                        <MovementItem
                            key={movement.id}
                            movement={movement}
                            citySlots={allLocations}
                            onRush={onRush}
                            isAdmin={isAdmin}
                        />
                    )) : <p className="text-gray-400">No active movements.</p>}
                </div>
            </div>
        </div>
    );
};

export default MovementsPanel;
</file>

<file path="src/components/map/OtherCityModal.js">
import React from 'react';
import TroopDisplay from '../TroopDisplay';
import unitsData from '../../gameData/units.json';
import woodImage from '../../images/resources/wood.png';
import stoneImage from '../../images/resources/stone.png';
import silverImage from '../../images/resources/silver.png';

const OtherCityModal = ({ city, onClose, onGoTo, onAction, isVillageTarget }) => {
    if (!city) return null;

    const resourceImages = {
        wood: woodImage,
        stone: stoneImage,
        silver: silverImage,
    };

    const handleGoTo = () => {
        if (onGoTo) {
            onGoTo(city.x, city.y);
        }
        onClose();
    };

    const title = isVillageTarget 
        ? `Farming Village: ${city.name || 'Unnamed Village'} (Level ${city.level || '?'})` 
        : `City: ${city.cityName || 'Unnamed City'}`;
    
    const ownerText = `Owner: ${city.ownerUsername || 'Unknown'}`;

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            <div className="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-sm border-2 border-gray-600" onClick={e => e.stopPropagation()}>
                <div className="flex justify-between items-center mb-4">
                    <h3 className="font-title text-2xl text-white">{title}</h3>
                    <button onClick={onClose} className="text-gray-400 text-3xl leading-none hover:text-white">&times;</button>
                </div>
                <p className="text-gray-400 mb-2">{ownerText}</p>
                {city.ownerFaction && <p className="text-gray-400 mb-6">Faction: {city.ownerFaction}</p>}
                
                {isVillageTarget && (
                    <div className="bg-gray-700 p-3 rounded-lg mb-4">
                        <div className="flex justify-center items-center space-x-4">
                            <div className="flex flex-col items-center">
                                <span className="text-sm text-gray-400 capitalize">Demands</span>
                                <img src={resourceImages[city.demands]} alt={city.demands} className="w-10 h-10" />
                            </div>
                            <span className="text-3xl text-gray-400 font-bold">&rarr;</span>
                            <div className="flex flex-col items-center">
                                <span className="text-sm text-gray-400 capitalize">Supplies</span>
                                <img src={resourceImages[city.supplies]} alt={city.supplies} className="w-10 h-10" />
                            </div>
                        </div>
                        {city.troops && Object.keys(city.troops).length > 0 && (
                            <div className="mt-4 border-t border-gray-600 pt-2">
                                <TroopDisplay units={city.troops} unitsData={unitsData} title="Village Troops" />
                            </div>
                        )}
                    </div>
                )}

                <div className="grid grid-cols-2 gap-4">
                    {isVillageTarget ? (
                        <button 
                            onClick={() => onAction('attack', city)}
                            className="btn bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded col-span-2"
                        >
                            Attack
                        </button>
                    ) : (
                        <>
                            <button 
                                onClick={() => onAction('attack', city)}
                                className="btn bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded"
                            >
                                Attack
                            </button>
                            <button 
                                onClick={() => onAction('reinforce', city)}
                                className="btn bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded"
                            >
                                Reinforce
                            </button>
                            <button 
                                onClick={() => onAction('scout', city)}
                                className="btn bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded"
                            >
                                Scout
                            </button>
                            <button 
                                onClick={() => onAction('trade', city)}
                                className="btn bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded"
                            >
                                Trade
                            </button>
                             <button 
                                onClick={() => onAction('castSpell', city)}
                                className="btn bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded"
                            >
                                Cast Spell
                            </button>
                            <button 
                                onClick={() => onAction('message', city)}
                                className="btn bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded"
                            >
                                Message
                            </button>
                            <button 
                                onClick={handleGoTo}
                                className="btn bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded col-span-2"
                            >
                                Go To
                            </button>
                        </>
                    )}
                </div>
            </div>
        </div>
    );
};

export default OtherCityModal;
</file>

<file path="src/components/map/ScoutPanel.js">
// src/components/map/ScoutPanel.js
import React from 'react';

const ScoutPanel = ({ selectedResources, gameState, handleResourceChange }) => {
    const availableCaveSilver = gameState.cave?.silver || 0;

    return (
        <div className="space-y-2">
            <h4 className="text-lg text-white font-bold mt-4 mb-2">Silver for Espionage</h4>
            <div className="flex justify-between items-center">
                <span className="text-white capitalize">Silver in Cave ({Math.floor(availableCaveSilver)})</span>
                <input
                    type="number"
                    value={selectedResources.silver || 0}
                    onChange={(e) => handleResourceChange('silver', e.target.value)}
                    className="bg-gray-700 text-white rounded p-1 w-32"
                />
            </div>
        </div>
    );
};

export default ScoutPanel;
</file>

<file path="src/components/map/SidebarNav.js">
import React from 'react';

const SidebarNav = ({ onGoToCity, onOpenMovements, onOpenReports, onOpenAlliance, onOpenMessages, onOpenSettings, onOpenProfile, unreadReportsCount, unreadMessagesCount, isAdmin, onToggleDummyCityPlacement }) => {
    return (
        <div className="sidebar">
            <h2 className="font-title text-2xl text-gray-200 mb-6 text-center">Menu</h2>
            <button onClick={onGoToCity} className="sidebar-button">City View</button>
            <button onClick={onOpenMovements} className="sidebar-button">Movements</button>
            <button 
                onClick={onOpenReports} 
                className={`sidebar-button relative ${unreadReportsCount > 0 ? 'glowing-border' : ''}`}
            >
                Reports
                {unreadReportsCount > 0 && (
                    <span className="absolute top-1 right-1 bg-red-600 text-white text-xs rounded-full h-5 w-5 flex items-center justify-center">
                        {unreadReportsCount}
                    </span>
                )}
            </button>
            <button onClick={onOpenAlliance} className="sidebar-button">Alliance</button>
            <button 
                onClick={onOpenMessages} 
                className={`sidebar-button relative ${unreadMessagesCount > 0 ? 'glowing-border' : ''}`}
            >
                Messages
                {unreadMessagesCount > 0 && (
                    <span className="absolute top-1 right-1 bg-red-600 text-white text-xs rounded-full h-5 w-5 flex items-center justify-center">
                        {unreadMessagesCount}
                    </span>
                )}
            </button>
            <button className="sidebar-button">Leaderboard</button>
            <button onClick={onOpenProfile} className="sidebar-button">Profile</button>
            <button onClick={onOpenSettings} className="sidebar-button">Settings</button>
            {isAdmin && (
                <button onClick={onToggleDummyCityPlacement} className="sidebar-button bg-yellow-700 hover:bg-yellow-600">
                    Admin: Place Dummy City
                </button>
            )}
        </div>
    );
};

export default SidebarNav;
</file>

<file path="src/components/map/Tiles.js">
// src/components/map/Tiles.js
import React from 'react';
import { useAuth } from '../../contexts/AuthContext';

const defaultSettings = { showVisuals: true, showGrid: true };

export const WaterTile = React.memo(({ gameSettings = defaultSettings }) => {
    const bgClass = gameSettings.showVisuals ? 'bg-blue-800' : 'bg-gray-900';
    const borderClass = gameSettings.showGrid 
        ? `border-r border-b ${gameSettings.showVisuals ? 'border-blue-900' : 'border-gray-800'}` 
        : 'border-r border-b border-transparent';
    return <div className={`w-full h-full ${bgClass} ${borderClass}`} />;
});

export const LandTile = React.memo(({ gameSettings = defaultSettings }) => {
    const bgClass = gameSettings.showVisuals ? 'bg-green-600' : 'bg-gray-800';
    const borderClass = gameSettings.showGrid 
        ? `border-r border-b ${gameSettings.showVisuals ? 'border-green-700' : 'border-gray-700'}`
        : 'border-r border-b border-transparent';
    return <div className={`w-full h-full ${bgClass} ${borderClass}`} />;
});

export const CitySlotTile = React.memo(({ slotData, onClick, isPlacingDummyCity, playerAlliance, gameSettings = defaultSettings }) => {
    const { currentUser } = useAuth();
    let slotClass = 'empty-slot';
    let tooltipText = `Empty Plot (${slotData.x}, ${slotData.y})`;

    if (slotData.ownerId) {
        const ownerName = slotData.ownerUsername || 'Unknown';
        if (slotData.ownerId === currentUser.uid) {
            slotClass = 'my-city';
            tooltipText = `Your City: ${slotData.cityName}`;
        } else if (playerAlliance && slotData.alliance === playerAlliance.tag) {
            slotClass = 'alliance-city';
            tooltipText = `Ally: ${slotData.cityName}<br>Owner: ${ownerName}<br>Alliance: ${slotData.allianceName || 'Unknown'}`;
        } else if (slotData.ownerId.startsWith('dummy_')) {
            slotClass = 'dummy-city-plot';
            tooltipText = `Dummy City: ${slotData.cityName}<br>Owner: ${ownerName}`;
        } else {
            slotClass = 'other-city';
            tooltipText = `City: ${slotData.cityName}<br>Owner: ${ownerName}<br>Faction: ${slotData.ownerFaction || 'Unknown'}`;
        }
    } else if (isPlacingDummyCity) {
        slotClass = 'dummy-placement-plot';
        tooltipText = 'Click to place dummy city';
    }

    const backgroundClass = gameSettings.showVisuals ? 'bg-green-400' : 'bg-gray-800';
    const borderClass = gameSettings.showGrid 
        ? `border-r border-b ${gameSettings.showVisuals ? 'border-green-700' : 'border-gray-700'}`
        : 'border-r border-b border-transparent';

    return (
        <div className={`w-full h-full ${backgroundClass} ${borderClass} flex justify-center items-center`}>
            <div onClick={(e) => onClick(e, slotData)} className={`city-slot ${slotClass}`}>
                <span className="map-object-tooltip" dangerouslySetInnerHTML={{ __html: tooltipText }}></span>
            </div>
        </div>
    );
});

export const FarmingVillageTile = React.memo(({ villageData, onClick, conqueredVillages, gameSettings = defaultSettings }) => {
    let villageClass = 'neutral-village';
    let tooltipText = `Village: ${villageData.name}<br>Level: ${villageData.level}`;

    const isConqueredByPlayer = conqueredVillages && conqueredVillages[villageData.id];

    if (isConqueredByPlayer) {
        villageClass = 'my-village';
        tooltipText = `Your Village: ${villageData.name}`;
    }
    
    const backgroundClass = gameSettings.showVisuals ? 'bg-green-500' : 'bg-gray-800';
    const borderClass = gameSettings.showGrid 
        ? `border-r border-b ${gameSettings.showVisuals ? 'border-green-700' : 'border-gray-700'}`
        : 'border-r border-b border-transparent';

    return (
        <div className={`w-full h-full ${backgroundClass} ${borderClass} flex justify-center items-center`}>
            <div onClick={(e) => onClick(e, villageData)} className={`village-slot ${villageClass}`}>
                <span className="map-object-tooltip" dangerouslySetInnerHTML={{ __html: tooltipText }}></span>
            </div>
        </div>
    );
});
</file>

<file path="src/components/map/TopBar.js">
import React from 'react';
import woodImage from '../../images/resources/wood.png';
import stoneImage from '../../images/resources/stone.png';
import silverImage from '../../images/resources/silver.png';
import populationImage from '../../images/resources/population.png';

// TopBar component displays current city resources and name.
const TopBar = ({ gameState, availablePopulation, maxPopulation }) => {
    if (!gameState) return null; // Don't render if gameState is not available
    const { resources, cityName } = gameState; // Destructure resources and cityName from gameState

    return (
        <div className="absolute top-0 left-0 right-0 z-20 p-2 flex justify-between items-center bg-gray-900 bg-opacity-70">
            <h2 className="font-title text-xl text-white">{cityName}</h2>
            <div className="flex items-center space-x-4">
                {/* Display wood resource with icon and amount */}
                <div className="flex items-center">
                    <img src={woodImage} alt="Wood" className="w-6 h-6 mr-2 text-yellow-700"/> 
                    <span className="text-yellow-300 font-bold">{Math.floor(resources.wood)}</span>
                </div>
                {/* Display stone resource with icon and amount */}
                <div className="flex items-center">
                    <img src={stoneImage} alt="Stone" className="w-6 h-6 mr-2 text-gray-500"/> 
                    <span className="text-gray-300 font-bold">{Math.floor(resources.stone)}</span>
                </div>
                {/* Display silver resource with icon and amount */}
                <div className="flex items-center">
                    <img src= {silverImage} alt="Silver" className="w-6 h-6 mr-2 text-gray-300"/> 
                    <span className="text-blue-300 font-bold">{Math.floor(resources.silver)}</span>
                </div>
                {/* Display Population */}
                <div className="flex items-center">
                    <img src={populationImage} alt="Population" className="w-6 h-6 mr-2"/>
                    <span className="font-bold text-red-400">{Math.floor(availablePopulation)}</span>
                </div>
            </div>
        </div>
    );
};

export default TopBar;
</file>

<file path="src/components/map/TradePanel.js">
// src/components/map/TradePanel.js
import React from 'react';
import woodImage from '../../images/resources/wood.png';
import stoneImage from '../../images/resources/stone.png';
import silverImage from '../../images/resources/silver.png';

const TradePanel = ({ selectedResources, currentResources, handleResourceChange }) => {
    const resourceImages = {
        wood: woodImage,
        stone: stoneImage,
        silver: silverImage,
    };


    return (
        <div className="space-y-2">
            <h4 className="text-lg text-white font-bold mb-2">Select Resources</h4>
            <div className="flex justify-around items-end w-full">
                {Object.keys(selectedResources).map(resource =>
                    <div key={resource} className="flex flex-col items-center">
                        <img
                            src={resourceImages[resource]}
                            alt={resource}
                            className="w-12 h-12 mb-1 bg-gray-700 rounded"
                        />
                        <input
                            type="number"
                            value={selectedResources[resource] || 0}
                            onChange={(e) => handleResourceChange(resource, e.target.value)}
                            className="bg-gray-700 text-white text-center rounded p-1 w-14 hide-number-spinners"
                            min="0"
                            max={currentResources[resource]}
                        />
                    </div>
                )}
            </div>
        </div>
    );
};

export default TradePanel;
</file>

<file path="src/components/messaging/MessagesView.css">
/* src/components/messaging/MessagesView.css */

.papyrus-bg {
    /* Add a background image with a color overlay for readability */
    background-image: linear-gradient(rgba(245, 222, 179, 0.9), rgba(245, 222, 179, 0.9)), url('https://www.transparenttextures.com/patterns/cracks.png');
    background-color: #F5DEB3; /* wheat */
    border: 4px double #8B4513; /* saddlebrown */
    box-shadow: 0 0 15px rgba(0,0,0,0.5);
}

.papyrus-text {
    color: #4a2c2a; /* A dark, ink-like brown */
    font-family: 'Kalam', cursive;
}

.papyrus-header {
    font-family: 'IM Fell English SC', serif;
    font-size: 1.5rem; /* 24px */
    color: #5D4037; /* A darker, more official-looking brown */
}

.papyrus-input {
    background-color: transparent;
    border-bottom: 2px solid #8B4513; /* saddlebrown */
    color: #4a2c2a;
}

.papyrus-input:focus {
    outline: none;
    border-color: #5D4037;
}

.papyrus-input::placeholder {
    color: #856a69;
}

.papyrus-btn {
    background-color: #8B4513; /* saddlebrown */
    color: #F5DEB3; /* wheat */
    font-weight: bold;
    border-radius: 2px;
    padding: 0.5rem 1rem;
    transition: all 0.2s;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

.papyrus-btn:hover {
    background-color: #A0522D; /* sienna */
}

.papyrus-list-item {
    padding: 0.75rem;
    cursor: pointer;
    border-bottom: 1px solid #D2B48C; /* tan */
}

.papyrus-list-item:hover {
    background-color: #E6CBA8; /* A lighter tan */
}

.papyrus-list-item.selected {
    background-color: #D2B48C; /* tan */
}

.papyrus-message-sent {
    background-color: #d3b890;
    border-radius: 0.5rem;
    padding: 0.75rem;
    max-width: 20rem; /* 320px */
    box-shadow: 0 1px 2px rgba(0,0,0,0.1);
}

.papyrus-message-received {
    background-color: #e6cba8;
    border-radius: 0.5rem;
    padding: 0.75rem;
    max-width: 20rem; /* 320px */
    box-shadow: 0 1px 2px rgba(0,0,0,0.1);
}
</file>

<file path="src/components/messaging/MessagesView.js">
import React, { useState, useEffect, useRef } from 'react';
import { db } from '../../firebase/config';
import { collection, query, where, onSnapshot, addDoc, serverTimestamp, orderBy, doc, getDoc, setDoc, getDocs } from 'firebase/firestore';
import { useAuth } from '../../contexts/AuthContext';
import { useGame } from '../../contexts/GameContext';
import './MessagesView.css'; // Import the new CSS file

const MessagesView = ({ onClose, initialRecipientId = null, initialRecipientUsername = null }) => {
    const { currentUser, userProfile } = useAuth();
    const { worldId } = useGame();
    const [conversations, setConversations] = useState([]);
    const [selectedConversation, setSelectedConversation] = useState(null);
    const [messages, setMessages] = useState([]);
    const [newMessage, setNewMessage] = useState('');
    const [newRecipient, setNewRecipient] = useState('');
    const [isComposing, setIsComposing] = useState(false);
    const messagesEndRef = useRef(null);

    useEffect(() => {
        if (!currentUser) return;

        const conversationsQuery = query(
            collection(db, 'worlds', worldId, 'conversations'),
            where('participants', 'array-contains', currentUser.uid)
        );

        const unsubscribe = onSnapshot(conversationsQuery, (snapshot) => {
            const convos = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            setConversations(convos);
        });

        return () => unsubscribe();
    }, [currentUser, worldId]);

    useEffect(() => {
        if (initialRecipientId && initialRecipientUsername) {
            handleCompose(initialRecipientId, initialRecipientUsername);
        }
    }, [initialRecipientId, initialRecipientUsername]);

    useEffect(() => {
        if (selectedConversation) {
            const messagesQuery = query(
                collection(db, 'worlds', worldId, 'conversations', selectedConversation.id, 'messages'),
                orderBy('timestamp', 'asc')
            );

            const unsubscribe = onSnapshot(messagesQuery, (snapshot) => {
                const msgs = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                setMessages(msgs);
            });

            return () => unsubscribe();
        }
    }, [selectedConversation, worldId]);

    useEffect(() => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    }, [messages]);

    const handleSelectConversation = async (convo) => {
        setSelectedConversation(convo);
        setIsComposing(false);
    };

    const handleSendMessage = async () => {
        if (newMessage.trim() === '' || (!selectedConversation && !newRecipient)) return;

        let conversationId = selectedConversation?.id;
        // Removed: let participants = selectedConversation?.participants;

        if (isComposing) {
            const recipientQuery = query(collection(db, 'users'), where('username', '==', newRecipient));
            const recipientSnapshot = await getDocs(recipientQuery);
            if (recipientSnapshot.empty) {
                alert('Recipient not found.');
                return;
            }
            const recipientData = recipientSnapshot.docs[0].data();
            const recipientId = recipientSnapshot.docs[0].id;

            const convoQuery = query(
                collection(db, 'worlds', worldId, 'conversations'),
                where('participants', '==', [currentUser.uid, recipientId].sort())
            );
            const convoSnapshot = await getDocs(convoQuery);

            if (convoSnapshot.empty) {
                const newConvoRef = doc(collection(db, 'worlds', worldId, 'conversations'));
                await setDoc(newConvoRef, {
                    participants: [currentUser.uid, recipientId].sort(),
                    participantUsernames: {
                        [currentUser.uid]: userProfile.username,
                        [recipientId]: recipientData.username,
                    },
                    lastMessage: {
                        text: newMessage,
                        senderId: currentUser.uid,
                        timestamp: serverTimestamp(),
                    },
                    readBy: [currentUser.uid],
                });
                conversationId = newConvoRef.id;
            } else {
                conversationId = convoSnapshot.docs[0].id;
            }
            // Removed: participants = [currentUser.uid, recipientId];
        }

        const convoRef = doc(db, 'worlds', worldId, 'conversations', conversationId);
        await addDoc(collection(convoRef, 'messages'), {
            text: newMessage,
            senderId: currentUser.uid,
            senderUsername: userProfile.username,
            timestamp: serverTimestamp(),
        });

        await setDoc(convoRef, {
            lastMessage: {
                text: newMessage,
                senderId: currentUser.uid,
                timestamp: serverTimestamp(),
            },
            readBy: [currentUser.uid],
        }, { merge: true });

        setNewMessage('');
        if (isComposing) {
            setIsComposing(false);
            setNewRecipient('');
            const newConvo = await getDoc(convoRef);
            setSelectedConversation({ id: newConvo.id, ...newConvo.data() });
        }
    };

    const handleCompose = (recipientId = null, recipientUsername = null) => {
        setSelectedConversation(null);
        setIsComposing(true);
        if (recipientId && recipientUsername) {
            setNewRecipient(recipientUsername);
        }
    };

    const getOtherParticipant = (convo) => {
        const otherId = convo.participants.find(p => p !== currentUser.uid);
        return convo.participantUsernames[otherId] || 'Unknown';
    };

    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center">
            <div className="papyrus-bg papyrus-text w-full max-w-4xl h-3/4 flex flex-col rounded-lg">
                <div className="p-4 border-b-2 border-[#8B4513] flex justify-between items-center">
                    <h2 className="papyrus-header">Missives & Scrolls</h2>
                    <button onClick={onClose} className="papyrus-text text-3xl font-bold hover:text-red-700">&times;</button>
                </div>

                <div className="flex flex-grow overflow-hidden">
                    <div className="w-1/3 border-r-2 border-[#8B4513] flex flex-col">
                        <div className="p-2 border-b-2 border-[#8B4513]">
                            <button onClick={() => handleCompose()} className="w-full papyrus-btn">
                                New Scroll
                            </button>
                        </div>
                        <ul className="overflow-y-auto">
                            {conversations.map(convo => (
                                <li
                                    key={convo.id}
                                    className={`papyrus-list-item ${selectedConversation?.id === convo.id ? 'selected' : ''}`}
                                    onClick={() => handleSelectConversation(convo)}
                                >
                                    <p className="font-bold font-title text-lg">{getOtherParticipant(convo)}</p>
                                    <p className="text-sm truncate">{convo.lastMessage?.text}</p>
                                </li>
                            ))}
                        </ul>
                    </div>
                    
                    <div className="w-2/3 flex flex-col">
                        {selectedConversation || isComposing ? (
                            <>
                                <div className="p-4 border-b-2 border-[#8B4513]">
                                    {isComposing ? (
                                        <input
                                            type="text"
                                            value={newRecipient}
                                            onChange={(e) => setNewRecipient(e.target.value)}
                                            placeholder="Scribe the recipient's name..."
                                            className="w-full papyrus-input text-lg"
                                        />
                                    ) : (
                                        <h3 className="font-bold text-lg font-title">{getOtherParticipant(selectedConversation)}</h3>
                                    )}
                                </div>
                                <div className="flex-grow overflow-y-auto p-4 space-y-4">
                                    {messages.map(msg => (
                                        <div key={msg.id} className={`flex ${msg.senderId === currentUser.uid ? 'justify-end' : 'justify-start'}`}>
                                            <div className={`${msg.senderId === currentUser.uid ? 'papyrus-message-sent' : 'papyrus-message-received'}`}>
                                                <p className="font-bold text-sm font-title">{msg.senderUsername}</p>
                                                <p>{msg.text}</p>
                                                <p className="text-xs text-gray-700/70 mt-1 text-right">{msg.timestamp?.toDate().toLocaleTimeString()}</p>
                                            </div>
                                        </div>
                                    ))}
                                    <div ref={messagesEndRef} />
                                </div>
                                <div className="p-4 border-t-2 border-[#8B4513]">
                                    <div className="flex">
                                        <input
                                            type="text"
                                            value={newMessage}
                                            onChange={(e) => setNewMessage(e.target.value)}
                                            onKeyPress={(e) => e.key === 'Enter' && handleSendMessage()}
                                            className="flex-grow papyrus-input"
                                            placeholder="Write your message..."
                                        />
                                        <button onClick={handleSendMessage} className="papyrus-btn ml-2">Send</button>
                                    </div>
                                </div>
                            </>
                        ) : (
                            <div className="flex items-center justify-center h-full">
                                <p className="text-gray-500 italic">Select a conversation or start a new one.</p>
                            </div>
                        )}
                    </div>
                </div>
            </div>
        </div>
    );
};

export default MessagesView;
</file>

<file path="src/components/profile/ProfileView.css">
.profile-view-container {
    @apply bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-lg border-2 border-gray-600 text-white;
}

.profile-header {
    @apply flex justify-between items-center mb-4;
}

.profile-header .close-button {
    @apply text-gray-400 text-3xl leading-none hover:text-white;
}

.message {
    @apply text-center text-green-400 mb-4;
}

.profile-content {
    @apply space-y-4;
}

.profile-main-info {
    @apply flex items-center gap-4 mb-4;
}

.profile-avatar {
    @apply w-24 h-24 rounded-full border-2 border-gray-500 object-cover;
}

.profile-details {
    @apply flex-grow space-y-2;
}

.profile-field {
    @apply flex flex-col;
}

.profile-field label {
    @apply text-gray-400 mb-1 text-sm font-bold;
}

.display-field {
    @apply bg-gray-700 p-3 rounded-lg min-h-[40px];
}

.display-field span {
    @apply text-lg;
}

.description-text {
    @apply text-gray-300 text-sm whitespace-pre-wrap;
}

.edit-form {
    @apply space-y-4 bg-gray-700 p-4 rounded-lg;
}

.username-input, .description-input {
    @apply w-full bg-gray-900 border border-gray-600 rounded-lg px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-blue-500;
}

.description-input {
    @apply min-h-[80px];
}

.form-actions {
    @apply flex justify-end gap-2 mt-4;
}
</file>

<file path="src/components/profile/ProfileView.js">
import React, { useState } from 'react';
import { useAuth } from '../../contexts/AuthContext';
import { useGame } from '../../contexts/GameContext';

const ProfileView = ({ onClose }) => {
    const { userProfile, updateUserProfile } = useAuth();
    const { gameState } = useGame();
    const [newUsername, setNewUsername] = useState(userProfile?.username || '');
    const [newDescription, setNewDescription] = useState(userProfile?.description || '');
    const [newImageUrl, setNewImageUrl] = useState(userProfile?.imageUrl || '');
    const [isEditing, setIsEditing] = useState(false);
    const [message, setMessage] = useState('');

    const handleUpdateProfile = async (e) => {
        e.preventDefault();
        const profileData = {
            username: newUsername,
            description: newDescription,
            imageUrl: newImageUrl,
        };
        try {
            await updateUserProfile(profileData);
            setMessage('Profile updated successfully!');
            setIsEditing(false);
        } catch (error) {
            setMessage('Failed to update profile.');
            console.error(error);
        }
    };

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            <div className="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-lg border-2 border-gray-600 text-white" onClick={e => e.stopPropagation()}>
                <div className="flex justify-between items-center mb-4">
                    <h2 className="font-title text-3xl">Player Profile</h2>
                    <button onClick={onClose} className="text-gray-400 text-3xl leading-none hover:text-white">&times;</button>
                </div>
                {message && <p className="text-center text-green-400 mb-4">{message}</p>}
                <div className="space-y-4">
                    <div className="flex items-center gap-4 mb-4">
                        <img src={userProfile?.imageUrl || 'https://placehold.co/100x100/2d3748/a0aec0?text=Avatar'} alt="Profile" className="w-24 h-24 rounded-full border-2 border-gray-500 object-cover" />
                        <div className="flex-grow space-y-2">
                            <div className="flex flex-col">
                                <label className="text-gray-400 mb-1 text-sm font-bold">Username</label>
                                <div className="bg-gray-700 p-3 rounded-lg min-h-[40px]">
                                    <span className="text-lg">{userProfile?.username}</span>
                                </div>
                            </div>
                            <div className="flex flex-col">
                                <label className="text-gray-400 mb-1 text-sm font-bold">City</label>
                                <div className="bg-gray-700 p-3 rounded-lg min-h-[40px]">
                                    <span className="text-lg">{gameState?.cityName}</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div className="flex flex-col">
                        <label className="text-gray-400 mb-1 text-sm font-bold">Description</label>
                        <div className="bg-gray-700 p-3 rounded-lg min-h-[40px]">
                            <p className="text-gray-300 text-sm whitespace-pre-wrap">{userProfile?.description || 'No description set.'}</p>
                        </div>
                    </div>
                    
                    {isEditing ? (
                        <form onSubmit={handleUpdateProfile} className="space-y-4 bg-gray-700 p-4 rounded-lg">
                            <div className="flex flex-col">
                                <label className="text-gray-400 mb-1 text-sm font-bold">Username</label>
                                <input type="text" value={newUsername} onChange={(e) => setNewUsername(e.target.value)} className="w-full bg-gray-900 border border-gray-600 rounded-lg px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-blue-500" />
                            </div>
                            <div className="flex flex-col">
                                <label className="text-gray-400 mb-1 text-sm font-bold">Description</label>
                                <textarea value={newDescription} onChange={(e) => setNewDescription(e.target.value)} className="w-full bg-gray-900 border border-gray-600 rounded-lg px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-blue-500 min-h-[80px]" />
                            </div>
                            <div className="flex flex-col">
                                <label className="text-gray-400 mb-1 text-sm font-bold">Image URL</label>
                                <input type="text" value={newImageUrl} onChange={(e) => setNewImageUrl(e.target.value)} className="w-full bg-gray-900 border border-gray-600 rounded-lg px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-blue-500" />
                            </div>
                            <div className="flex justify-end gap-2 mt-4">
                                <button type="button" onClick={() => setIsEditing(false)} className="btn btn-secondary">Cancel</button>
                                <button type="submit" className="btn btn-confirm">Save</button>
                            </div>
                        </form>
                    ) : (
                        <button onClick={() => setIsEditing(true)} className="btn btn-primary w-full mt-4">Edit Profile</button>
                    )}
                </div>
            </div>
        </div>
    );
};

export default ProfileView;
</file>

<file path="src/components/shared/LoadingScreen.js">
import React from 'react';

/**
 * A simple loading screen component.
 * @param {object} props - The component props.
 * @param {string} [props.message='Loading...'] - The message to display below the spinner.
 * @returns {JSX.Element} The rendered loading screen.
 */
const LoadingScreen = ({ message = 'Loading...' }) => {
    return (
        <div className="w-full h-screen flex flex-col items-center justify-center bg-gray-900 text-white">
            {/* A simple CSS spinner */}
            <div className="animate-spin rounded-full h-16 w-16 border-t-2 border-b-2 border-blue-500"></div>
            <p className="mt-4 text-lg font-semibold">{message}</p>
        </div>
    );
};

export default LoadingScreen;
</file>

<file path="src/components/shared/Modal.js">
import React from 'react';

const Modal = ({ message, title, children, onClose }) => {
    // Render nothing if no message, title, or children are provided
    if (!message && !title && !children) return null;

    return (
        <div
            className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-60"
            onClick={onClose} // Close modal on backdrop click
        >
            <div
                className="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-sm text-center border border-gray-600"
                onClick={e => e.stopPropagation()} // Prevent modal from closing when clicking inside it
            >
                {title && <h2 className="text-2xl font-bold mb-4 text-center text-yellow-400">{title}</h2>}
                {message && <p className="mb-4 text-lg text-gray-300">{message}</p>}
                {children} {/* Render children passed to the modal */}
                <button
                    onClick={onClose}
                    className="btn btn-primary px-6 py-2 mt-4"
                >
                    Close
                </button>
            </div>
        </div>
    );
};

export default Modal;
</file>

<file path="src/components/shared/SettingsModal.js">
// src/components/shared/SettingsModal.js
import React from 'react';
import { useGame } from '../../contexts/GameContext';

const SettingsModal = ({ onClose }) => {
    const { gameSettings, setGameSettings } = useGame();

    const handleChange = (e) => {
        const { name, type, checked, value } = e.target;
        setGameSettings(prevSettings => ({
            ...prevSettings,
            [name]: type === 'checkbox' ? checked : value
        }));
    };

    const handleSave = () => {
        // Settings are saved on change, so this just closes the modal
        onClose();
    };

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70" onClick={onClose}>
            <div className="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md border-2 border-gray-600 text-white" onClick={e => e.stopPropagation()}>
                <div className="flex justify-between items-center mb-4">
                    <h2 className="text-2xl font-bold text-center text-yellow-400">Game Settings</h2>
                    <button onClick={onClose} className="text-gray-400 text-3xl leading-none hover:text-white">&times;</button>
                </div>
                
                <div className="space-y-4">
                    <div className="flex justify-between items-center bg-gray-700 p-3 rounded-lg">
                        <label htmlFor="showVisuals" className="text-lg font-semibold">Enable Visuals</label>
                        <input
                            type="checkbox"
                            id="showVisuals"
                            name="showVisuals"
                            checked={gameSettings.showVisuals}
                            onChange={handleChange}
                            className="w-6 h-6 rounded text-blue-600 bg-gray-600 border-gray-500 focus:ring-blue-500"
                        />
                    </div>

                    <div className="flex justify-between items-center bg-gray-700 p-3 rounded-lg">
                        <label htmlFor="showGrid" className="text-lg font-semibold">Enable Grid</label>
                        <input
                            type="checkbox"
                            id="showGrid"
                            name="showGrid"
                            checked={gameSettings.showGrid}
                            onChange={handleChange}
                            className="w-6 h-6 rounded text-blue-600 bg-gray-600 border-gray-500 focus:ring-blue-500"
                        />
                    </div>
                    
                    <div className="flex justify-between items-center bg-gray-700 p-3 rounded-lg">
                        <label htmlFor="animations" className="text-lg font-semibold">Enable Animations</label>
                        <input
                            type="checkbox"
                            id="animations"
                            name="animations"
                            checked={gameSettings.animations}
                            onChange={handleChange}
                            className="w-6 h-6 rounded text-blue-600 bg-gray-600 border-gray-500 focus:ring-blue-500"
                        />
                    </div>

                    <div className="flex justify-between items-center bg-gray-700 p-3 rounded-lg">
                        <label htmlFor="confirmActions" className="text-lg font-semibold">Confirm Destructive Actions</label>
                        <input
                            type="checkbox"
                            id="confirmActions"
                            name="confirmActions"
                            checked={gameSettings.confirmActions}
                            onChange={handleChange}
                            className="w-6 h-6 rounded text-blue-600 bg-gray-600 border-gray-500 focus:ring-blue-500"
                        />
                    </div>
                </div>

                <div className="mt-6 flex justify-center space-x-4">
                    <button
                        onClick={handleSave}
                        className="btn btn-confirm py-2 px-6"
                    >
                        Close
                    </button>
                </div>
            </div>
        </div>
    );
};

export default SettingsModal;
</file>

<file path="src/components/AuthScreen.js">
import React, { useState } from 'react';
import { signInWithEmailAndPassword, createUserWithEmailAndPassword } from "firebase/auth";
import { doc, setDoc } from "firebase/firestore";
import { auth, db } from '../firebase/config';
import Modal from './shared/Modal';
import EyeIcon from './icons/EyeIcon';
import EyeOffIcon from './icons/EyeOffIcon';

const AuthScreen = () => {
    const [isFlipped, setIsFlipped] = useState(false);
    const [showPassword, setShowPassword] = useState(false);
    const [message, setMessage] = useState('');

    // Form states
    const [loginEmail, setLoginEmail] = useState('');
    const [loginPassword, setLoginPassword] = useState('');
    const [registerUsername, setRegisterUsername] = useState('');
    const [registerEmail, setRegisterEmail] = useState('');
    const [registerPassword, setRegisterPassword] = useState('');
    const [registerConfirmPassword, setRegisterConfirmPassword] = useState('');

    const validateRegistration = () => {
        if (!registerUsername || !registerEmail || !registerPassword || !registerConfirmPassword) {
            setMessage("All fields are required.");
            return false;
        }
        if (registerPassword !== registerConfirmPassword) {
            setMessage("Passwords do not match.");
            return false;
        }
        if (registerPassword.length < 6) {
            setMessage("Password must be at least 6 characters long.");
            return false;
        }
        if (registerUsername.length < 3) {
            setMessage("Username must be at least 3 characters long.");
            return false;
        }
        return true;
    };

    const handleLogin = async (e) => {
        e.preventDefault();
        setMessage('');
        try {
            await signInWithEmailAndPassword(auth, loginEmail, loginPassword);
        } catch (error) {
            setMessage("Failed to login. Please check your email and password.");
            console.error(error);
        }
    };

    const handleRegister = async (e) => {
        e.preventDefault();
        if (!validateRegistration()) return;
        setMessage('');
        try {
            const userCredential = await createUserWithEmailAndPassword(auth, registerEmail, registerPassword);
            const user = userCredential.user;
            await setDoc(doc(db, "users", user.uid), {
                username: registerUsername,
                email: user.email,
                is_admin: false
            });
        } catch (error) {
            if (error.code === 'auth/email-already-in-use') {
                setMessage("An account with this email already exists.");
            } else {
                setMessage(error.message);
            }
            console.error(error);
        }
    };

    const togglePasswordVisibility = () => setShowPassword(!showPassword);

    return (
        <div className="w-full min-h-screen flex items-center justify-center p-4 bg-gray-900 perspective">
            <Modal message={message} onClose={() => setMessage('')} />
            <div className={`auth-card ${isFlipped ? 'flipped' : ''}`}>
                {/* Front Side: Login */}
                <div className="auth-card-face auth-card-front">
                    <div className="bg-gray-800 p-8 rounded-lg shadow-2xl w-full max-w-md">
                        <h1 className="font-title text-4xl text-center text-gray-300 mb-8">Age of Nasos</h1>
                        <h2 className="text-2xl font-bold text-center text-white mb-6">Login</h2>
                        <form onSubmit={handleLogin}>
                            <div className="mb-4">
                                <label className="block text-gray-400 mb-2">Email</label>
                                <input type="email" value={loginEmail} onChange={(e) => setLoginEmail(e.target.value)} className="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2 text-white focus:outline-none focus:ring-2 focus:ring-blue-500" required />
                            </div>
                            <div className="mb-6 relative">
                                <label className="block text-gray-400 mb-2">Password</label>
                                <input type={showPassword ? 'text' : 'password'} value={loginPassword} onChange={(e) => setLoginPassword(e.target.value)} className="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2 text-white focus:outline-none focus:ring-2 focus:ring-blue-500" required />
                                <button type="button" onClick={togglePasswordVisibility} className="absolute right-3 top-10 text-gray-400 hover:text-white">
                                    {showPassword ? <EyeOffIcon /> : <EyeIcon />}
                                </button>
                            </div>
                            <button type="submit" className="w-full btn btn-primary font-bold py-3 rounded-lg">Enter the Realm</button>
                        </form>
                        <p className="text-center text-gray-400 mt-6">
                            Don't have an account? <button onClick={() => setIsFlipped(true)} className="text-blue-400 hover:underline">Register here</button>
                        </p>
                    </div>
                </div>

                {/* Back Side: Register */}
                <div className="auth-card-face auth-card-back">
                    <div className="bg-gray-800 p-8 rounded-lg shadow-2xl w-full max-w-md">
                        <h1 className="font-title text-4xl text-center text-gray-300 mb-8">Age of Nasos</h1>
                        <h2 className="text-2xl font-bold text-center text-white mb-6">Register</h2>
                        <form onSubmit={handleRegister}>
                             <div className="mb-4">
                                <label className="block text-gray-400 mb-2">Username</label>
                                <input type="text" value={registerUsername} onChange={(e) => setRegisterUsername(e.target.value)} className="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2 text-white focus:outline-none focus:ring-2 focus:ring-blue-500" required />
                            </div>
                            <div className="mb-4">
                                <label className="block text-gray-400 mb-2">Email</label>
                                <input type="email" value={registerEmail} onChange={(e) => setRegisterEmail(e.target.value)} className="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2 text-white focus:outline-none focus:ring-2 focus:ring-blue-500" required />
                            </div>
                            <div className="mb-4 relative">
                                <label className="block text-gray-400 mb-2">Password</label>
                                <input type={showPassword ? 'text' : 'password'} value={registerPassword} onChange={(e) => setRegisterPassword(e.target.value)} className="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2 text-white focus:outline-none focus:ring-2 focus:ring-blue-500" required />
                                 <button type="button" onClick={togglePasswordVisibility} className="absolute right-3 top-10 text-gray-400 hover:text-white">
                                    {showPassword ? <EyeOffIcon /> : <EyeIcon />}
                                </button>
                            </div>
                             <div className="mb-6">
                                <label className="block text-gray-400 mb-2">Confirm Password</label>
                                <input type={showPassword ? 'text' : 'password'} value={registerConfirmPassword} onChange={(e) => setRegisterConfirmPassword(e.target.value)} className="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2 text-white focus:outline-none focus:ring-2 focus:ring-blue-500" required />
                            </div>
                            <button type="submit" className="w-full btn btn-primary font-bold py-3 rounded-lg">Forge Your Empire</button>
                        </form>
                        <p className="text-center text-gray-400 mt-6">
                            Already have an account? <button onClick={() => setIsFlipped(false)} className="text-blue-400 hover:underline">Login here</button>
                        </p>
                    </div>
                </div>
            </div>
        </div>
    );
};

export default AuthScreen;
</file>

<file path="src/components/CityFounding.js">
import React, { useState, useEffect, useCallback } from 'react';
import { doc, getDoc, writeBatch, collection, query, where, limit, getDocs } from 'firebase/firestore';
import { db } from '../firebase/config';
import { useAuth } from '../contexts/AuthContext';
import { useGame } from '../contexts/GameContext';
import buildingConfig from '../gameData/buildings.json';

const CityFounding = ({ onCityFounded }) => {
    const { currentUser, userProfile } = useAuth();
    const { worldId, worldState, setGameState, setPlayerCity } = useGame();
    const [selectedSlot, setSelectedSlot] = useState(null);
    const [cityName, setCityName] = useState('');
    const [message, setMessage] = useState('');
    const [isLoading, setIsLoading] = useState(false);

    useEffect(() => {
        if (userProfile?.username) {
            setCityName(`${userProfile.username}'s Capital`);
        }
    }, [userProfile]);

    const findEmptySlot = useCallback(async () => {
        if (!worldState?.islands || !worldId) return null;

        const citySlotsRef = collection(db, 'worlds', worldId, 'citySlots');
        const q = query(citySlotsRef, where('ownerId', '==', null), limit(10));

        try {
            const querySnapshot = await getDocs(q);
            if (!querySnapshot.empty) {
                const randomDoc = querySnapshot.docs[Math.floor(Math.random() * querySnapshot.docs.length)];
                return { id: randomDoc.id, ...randomDoc.data() };
            }
        } catch (error) {
            console.error("Error finding an empty slot:", error);
        }
        return null;
    }, [worldId, worldState]);

    const handleSelectSlot = useCallback(async () => {
        setIsLoading(true);
        setMessage('Finding a suitable location...');
        const slot = await findEmptySlot();
        if (slot) {
            setSelectedSlot(slot);
            setMessage(`Location found at (${slot.x}, ${slot.y}). Give your new city a name.`);
        } else {
            setMessage('Could not find an available city slot. This world might be full.');
        }
        setIsLoading(false);
    }, [findEmptySlot]);

    useEffect(() => {
        handleSelectSlot();
    }, [handleSelectSlot]);

    const handleFoundCity = async (e) => {
        e.preventDefault();
        if (!cityName.trim() || !selectedSlot) return;
        setIsLoading(true);
        setMessage('Founding your city...');

        const citySlotRef = doc(db, 'worlds', worldId, 'citySlots', selectedSlot.id);
        const gameDocRef = doc(db, `users/${currentUser.uid}/games`, worldId);

        try {
            const slotSnap = await getDoc(citySlotRef);
            if (!slotSnap.exists() || slotSnap.data().ownerId !== null) {
                throw new Error("This location was taken while you were deciding. Please try again.");
            }

            const batch = writeBatch(db);

            batch.update(citySlotRef, {
                ownerId: currentUser.uid,
                ownerUsername: userProfile.username,
                cityName: cityName.trim()
            });

            const initialBuildings = {};
            // Initialize all buildings to level 0
            for (const buildingId in buildingConfig) {
                initialBuildings[buildingId] = { level: 0 };
            }
            // Set specific initial buildings to level 1
            initialBuildings.senate = { level: 1 };
            initialBuildings.farm = { level: 1 };
            initialBuildings.warehouse = { level: 1 };
            initialBuildings.timber_camp = { level: 1 };
            initialBuildings.quarry = { level: 1 };
            initialBuildings.silver_mine = { level: 1 };
            initialBuildings.cave = { level: 1 }; // Ensure Cave is initialized at Level 1

            const newGameState = {
                id: selectedSlot.id,
                x: selectedSlot.x,
                y: selectedSlot.y,
                islandId: selectedSlot.islandId,
                cityName: cityName.trim(),
                playerInfo: { religion: userProfile.religion, nation: userProfile.nation },
                resources: { wood: 1000, stone: 1000, silver: 500, population: 100 },
                storage: buildingConfig.warehouse.storage[1], // Assuming storage is based on warehouse level 1
                buildings: initialBuildings,
                units: {},
                research: {},
                lastUpdated: Date.now(),
            };
            batch.set(gameDocRef, newGameState);

            await batch.commit();

            setMessage('Transaction successful: City placed!');
            setPlayerCity(newGameState);
            setGameState(newGameState);
            onCityFounded();

        } catch (error) {
            console.error("Error founding city: ", error);
            setMessage(`Failed to found city: ${error.message}`);
            setSelectedSlot(null);
            handleSelectSlot();
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <div className="w-full h-screen flex items-center justify-center bg-gray-900 text-white">
            <div className="w-full max-w-md text-center p-8 bg-gray-800 rounded-lg shadow-2xl">
                <h2 className="font-title text-4xl mb-4">Found Your First City</h2>
                <p className="text-gray-400 mb-6">{message}</p>
                {selectedSlot && (
                    <form onSubmit={handleFoundCity} className="flex flex-col gap-4">
                        <input
                            type="text"
                            value={cityName}
                            onChange={(e) => setCityName(e.target.value)}
                            className="bg-gray-700 border border-gray-600 rounded-lg px-4 py-3 text-white focus:outline-none focus:ring-2 focus:ring-blue-500 w-full text-center text-lg"
                            required
                        />
                        <button type="submit" disabled={isLoading} className="btn btn-confirm px-8 py-3 text-lg">
                            {isLoading ? 'Claiming Land...' : 'Found City'}
                        </button>
                    </form>
                )}
            </div>
        </div>
    );
};

export default CityFounding;
</file>

<file path="src/components/CityView.js">
// src/components/CityView.js
import React, { useState } from 'react';
import { useAuth } from '../contexts/AuthContext';
import Modal from './shared/Modal';
import CityHeader from './city/CityHeader';
import ResourceBar from './city/ResourceBar';
import CityModals from './city/CityModals';
import CityViewContent from './city/CityViewContent';
import DivinePowers from './city/DivinePowers'; // Import DivinePowers
import { useCityState } from '../hooks/useCityState';
import researchConfig from '../gameData/research.json';
import unitConfig from '../gameData/units.json';
import { useGame } from '../contexts/GameContext';

const CityView = ({ showMap, worldId }) => {
    const { currentUser, userProfile } = useAuth();
    const { gameSettings } = useGame();
    const [isInstantBuild, setIsInstantBuild] = useState(false);
    const [isInstantResearch, setIsInstantResearch] = useState(false);
    const [isInstantUnits, setIsInstantUnits] = useState(false);

    const {
        cityGameState,
        setCityGameState,
        getUpgradeCost,
        getFarmCapacity,
        calculateUsedPopulation,
        getProductionRates,
        getWarehouseCapacity,
        getHospitalCapacity,
        saveGameState,
        getResearchCost
    } = useCityState(worldId, isInstantBuild, isInstantResearch, isInstantUnits);

    const [message, setMessage] = useState('');

    const [modalState, setModalState] = useState({
        selectedBuildingId: null,
        isSenateViewOpen: false,
        isBarracksMenuOpen: false,
        isShipyardMenuOpen: false,
        isTempleMenuOpen: false,
        isCaveMenuOpen: false,
        isAcademyMenuOpen: false,
        isHospitalMenuOpen: false,
        isCheatMenuOpen: false,
        isDivinePowersOpen: false,
    });

    const openModal = (modalKey) => setModalState(prev => ({ ...prev, [modalKey]: true }));
    const closeModal = (modalKey) => setModalState(prev => ({ ...prev, [modalKey]: false, selectedBuildingId: null }));

    const handleUpgrade = async (buildingId) => {
        const currentState = cityGameState;
        if (!currentState || !worldId) return;

        const currentQueue = currentState.buildQueue || [];

        if (currentQueue.length >= 5) {
            setMessage("Build queue is full (max 5).");
            return;
        }

        const building = currentState.buildings[buildingId] || { level: 0 };

        let effectiveCurrentLevel = building.level;
        currentQueue.forEach(task => {
            if (task.buildingId === buildingId && task.level > effectiveCurrentLevel) {
                effectiveCurrentLevel = task.level;
            }
        });
        const nextLevelToQueue = effectiveCurrentLevel + 1;

        const cost = getUpgradeCost(buildingId, nextLevelToQueue);
        const currentUsedPopulation = calculateUsedPopulation(currentState.buildings, currentState.units);
        const maxPopulation = getFarmCapacity(currentState.buildings.farm.level);
        const newTotalPopulation = currentUsedPopulation + cost.population;

        if (
            currentState.resources.wood >= cost.wood &&
            currentState.resources.stone >= cost.stone &&
            currentState.resources.silver >= cost.silver &&
            newTotalPopulation <= maxPopulation
        ) {
            const newGameState = JSON.parse(JSON.stringify(currentState));

            newGameState.resources.wood -= cost.wood;
            newGameState.resources.stone -= cost.stone;
            newGameState.resources.silver -= cost.silver;

            let lastEndTime = Date.now();
            if (currentQueue.length > 0) {
                const lastQueueItem = currentQueue[currentQueue.length - 1];
                if (lastQueueItem.endTime) {
                    lastEndTime = lastQueueItem.endTime.toDate
                        ? lastQueueItem.endTime.toDate().getTime()
                        : new Date(lastQueueItem.endTime).getTime();
                }
            }

            const endTime = new Date(lastEndTime + cost.time * 1000);

            const newQueueItem = {
                buildingId,
                level: nextLevelToQueue,
                endTime: endTime,
            };

            newGameState.buildQueue = [...currentQueue, newQueueItem];

            try {
                await saveGameState(newGameState);
                setCityGameState(newGameState);
            }
            catch (error) {
                console.error("Error adding to build queue:", error);
                setMessage("Could not start upgrade. Please try again.");
            }
        }
        else {
            setMessage(newTotalPopulation > maxPopulation ? 'Not enough population capacity!' : 'Not enough resources to upgrade!');
        }
    };

    const handleCancelBuild = async (itemIndex) => {
        const currentState = cityGameState;
        if (!currentState || !currentState.buildQueue || itemIndex < 0 || itemIndex >= currentState.buildQueue.length) {
            return;
        }

        const newQueue = [...currentState.buildQueue];
        const canceledTask = newQueue.splice(itemIndex, 1)[0];

        const cost = getUpgradeCost(canceledTask.buildingId, canceledTask.level);
        const newResources = {
            ...currentState.resources,
            wood: currentState.resources.wood + cost.wood,
            stone: currentState.resources.stone + cost.stone,
            silver: currentState.resources.silver + cost.silver,
        };

        for (let i = itemIndex; i < newQueue.length; i++) {
            const previousTaskEndTime = (i === 0)
                ? Date.now()
                : (newQueue[i - 1].endTime.toDate ? newQueue[i - 1].endTime.toDate().getTime() : new Date(newQueue[i - 1].endTime).getTime());

            const taskToUpdate = newQueue[i];
            const taskCost = getUpgradeCost(taskToUpdate.buildingId, taskToUpdate.level);
            const newEndTime = new Date(previousTaskEndTime + taskCost.time * 1000);
            newQueue[i] = { ...taskToUpdate, endTime: newEndTime };
        }

        const newGameState = { ...currentState, resources: newResources, buildQueue: newQueue };
        await saveGameState(newGameState);
        setCityGameState(newGameState);
    };

    const handleStartResearch = async (researchId) => {
        const currentState = cityGameState;
        if (!currentState || !researchConfig[researchId]) return;

        const currentQueue = currentState.researchQueue || [];

        if (currentQueue.length >= 5) {
            setMessage("Research queue is full (max 5).");
            return;
        }

        const researchData = researchConfig[researchId];
        const { cost, requirements } = researchData;

        if (currentState.research[researchId]) {
            setMessage("Research already completed.");
            return;
        }

        if (currentQueue.some(item => item.researchId === researchId)) {
            setMessage("Research is already in the queue.");
            return;
        }

        if (requirements.academy && currentState.buildings.academy.level < requirements.academy) {
            setMessage(`Requires Academy Level ${requirements.academy}.`);
            return;
        }
        if (requirements.research && !currentState.research[requirements.research]) {
            setMessage(`Requires "${researchConfig[requirements.research].name}" research first.`);
            return;
        }

        if (
            currentState.resources.wood < cost.wood ||
            currentState.resources.stone < cost.stone ||
            currentState.resources.silver < cost.silver
        ) {
            setMessage("Not enough resources to start research.");
            return;
        }

        const newGameState = JSON.parse(JSON.stringify(currentState));
        newGameState.resources.wood -= cost.wood;
        newGameState.resources.stone -= cost.stone;
        newGameState.resources.silver -= cost.silver;

        let lastEndTime = Date.now();
        if (currentQueue.length > 0) {
            const lastQueueItem = currentQueue[currentQueue.length - 1];
            if (lastQueueItem.endTime) {
                lastEndTime = lastQueueItem.endTime.toDate
                    ? lastQueueItem.endTime.toDate().getTime()
                    : new Date(lastQueueItem.endTime).getTime();
            }
        }
        const researchTime = getResearchCost(researchId).time;
        const endTime = new Date(lastEndTime + researchTime * 1000);

        const newQueueItem = {
            researchId,
            endTime: endTime,
        };

        newGameState.researchQueue = [...currentQueue, newQueueItem];

        try {
            await saveGameState(newGameState);
            setCityGameState(newGameState);
            setMessage(`Research for "${researchData.name}" started.`);
        }
        catch (error) {
            console.error("Error starting research:", error);
            setMessage("Could not start research. Please try again.");
        }
    };

    const handleCancelResearch = async (itemIndex) => {
        const currentState = cityGameState;
        if (!currentState || !currentState.researchQueue || itemIndex < 0 || itemIndex >= currentState.researchQueue.length) {
            return;
        }

        const newQueue = [...currentState.researchQueue];
        const canceledTask = newQueue.splice(itemIndex, 1)[0];
        const researchData = researchConfig[canceledTask.researchId];

        const newResources = {
            ...currentState.resources,
            wood: currentState.resources.wood + researchData.cost.wood,
            stone: currentState.resources.stone + researchData.cost.stone,
            silver: currentState.resources.silver + researchData.cost.silver,
        };

        for (let i = itemIndex; i < newQueue.length; i++) {
            const previousTaskEndTime = (i === 0)
                ? Date.now()
                : (newQueue[i - 1].endTime.toDate ? newQueue[i - 1].endTime.toDate().getTime() : new Date(newQueue[i - 1].endTime).getTime());

            const taskToUpdate = newQueue[i];
            const taskResearchTime = getResearchCost(taskToUpdate.researchId).time;
            const newEndTime = new Date(previousTaskEndTime + taskResearchTime * 1000);
            newQueue[i] = { ...taskToUpdate, endTime: newEndTime };
        }

        const newGameState = { ...currentState, resources: newResources, researchQueue: newQueue };
        await saveGameState(newGameState);
        setCityGameState(newGameState);
        setMessage(`Research for "${researchData.name}" canceled and resources refunded.`);
    };

    const handleCancelTrain = async (itemIndex) => {
        const currentState = cityGameState;
        if (!currentState || !currentState.unitQueue || itemIndex < 0 || itemIndex >= currentState.unitQueue.length) {
            return;
        }

        const newQueue = [...currentState.unitQueue];
        const canceledTask = newQueue.splice(itemIndex, 1)[0];
        const unit = unitConfig[canceledTask.unitId];

        const newResources = {
            ...currentState.resources,
            wood: currentState.resources.wood + (unit.cost.wood * canceledTask.amount),
            stone: currentState.resources.stone + (unit.cost.stone * canceledTask.amount),
            silver: currentState.resources.silver + (unit.cost.silver * canceledTask.amount),
        };

        for (let i = itemIndex; i < newQueue.length; i++) {
            const previousTaskEndTime = (i === 0)
                ? Date.now()
                : (newQueue[i - 1].endTime.toDate ? newQueue[i - 1].endTime.toDate().getTime() : new Date(newQueue[i - 1].endTime).getTime());

            const taskToUpdate = newQueue[i];
            const taskUnit = unitConfig[taskToUpdate.unitId];
            const newEndTime = new Date(previousTaskEndTime + (isInstantUnits ? 1 : taskUnit.cost.time * taskToUpdate.amount) * 1000);
            newQueue[i] = { ...taskToUpdate, endTime: newEndTime };
        }

        const newGameState = { ...currentState, resources: newResources, unitQueue: newQueue };
        await saveGameState(newGameState);
        setCityGameState(newGameState);
        setMessage(`Training for ${canceledTask.amount} ${unit.name}s canceled and resources refunded.`);
    };

    const handleTrainTroops = async (unitId, amount) => {
        const currentState = cityGameState;
        if (!currentState || !worldId || amount <= 0) return;

        const currentQueue = currentState.unitQueue || [];

        if (currentQueue.length >= 5) {
            setMessage("Unit training queue is full (max 5).");
            return;
        }

        const unit = unitConfig[unitId];

        const totalCost = {
            wood: unit.cost.wood * amount,
            stone: unit.cost.stone * amount,
            silver: unit.cost.silver * amount,
            population: unit.cost.population * amount,
        };

        let effectiveUsedPopulation = calculateUsedPopulation(currentState.buildings, currentState.units);
        currentQueue.forEach(task => {
            effectiveUsedPopulation += (unitConfig[task.unitId]?.cost.population || 0) * task.amount;
        });

        const maxPopulation = getFarmCapacity(currentState.buildings.farm.level);
        const availablePopulation = maxPopulation - effectiveUsedPopulation;

        if (unit.type === 'naval' && (!currentState.buildings.shipyard || currentState.buildings.shipyard.level === 0)) {
            setMessage("Naval units can only be built in the Shipyard.");
            return;
        }
        if (unit.type === 'land' && (!currentState.buildings.barracks || currentState.buildings.barracks.level === 0)) {
            setMessage("Land units can only be trained in the Barracks.");
            return;
        }

        if (
            currentState.resources.wood >= totalCost.wood &&
            currentState.resources.stone >= totalCost.stone &&
            currentState.resources.silver >= totalCost.silver &&
            availablePopulation >= totalCost.population
        ) {
            const newGameState = JSON.parse(JSON.stringify(currentState));

            newGameState.resources.wood -= totalCost.wood;
            newGameState.resources.stone -= totalCost.stone;
            newGameState.resources.silver -= totalCost.silver;

            let lastEndTime = Date.now();
            if (currentQueue.length > 0) {
                const lastQueueItem = currentQueue[currentQueue.length - 1];
                if (lastQueueItem.endTime) {
                    lastEndTime = lastQueueItem.endTime.toDate
                        ? lastQueueItem.endTime.toDate().getTime()
                        : new Date(lastQueueItem.endTime).getTime();
                }
            }

            const trainingTime = unit.cost.time * amount;
            const endTime = new Date(lastEndTime + (isInstantUnits ? 1 : trainingTime) * 1000);

            const newQueueItem = {
                unitId,
                amount,
                endTime: endTime,
            };

            newGameState.unitQueue = [...currentQueue, newQueueItem];

            try {
                await saveGameState(newGameState);
                setCityGameState(newGameState);
                setMessage(`Training ${amount} ${unit.name}s.`);
            }
            catch (error) {
                console.error("Error adding to unit queue:", error);
                setMessage("Could not start training. Please try again.");
            }
        } else {
            setMessage(availablePopulation < totalCost.population ? 'Not enough available population!' : 'Not enough resources to train troops!');
        }
    };

    const handleHealTroops = async (unitsToHeal) => {
        const currentState = cityGameState;
        if (!currentState || !worldId || Object.keys(unitsToHeal).length === 0) return;

        const currentQueue = currentState.healQueue || [];
        if (currentQueue.length >= 5) {
            setMessage("Healing queue is full (max 5).");
            return;
        }

        const totalCost = { wood: 0, stone: 0, silver: 0 };
        let totalTime = 0;

        for (const unitId in unitsToHeal) {
            const amount = unitsToHeal[unitId];
            const unit = unitConfig[unitId];
            totalCost.wood += (unit.heal_cost.wood || 0) * amount;
            totalCost.stone += (unit.heal_cost.stone || 0) * amount;
            totalCost.silver += (unit.heal_cost.silver || 0) * amount;
            totalTime += (unit.heal_time || 0) * amount;
        }
        
        if (
            currentState.resources.wood >= totalCost.wood &&
            currentState.resources.stone >= totalCost.stone &&
            currentState.resources.silver >= totalCost.silver
        ) {
            const newGameState = JSON.parse(JSON.stringify(currentState));
            newGameState.resources.wood -= totalCost.wood;
            newGameState.resources.stone -= totalCost.stone;
            newGameState.resources.silver -= totalCost.silver;

            const newWounded = { ...newGameState.wounded };
            for (const unitId in unitsToHeal) {
                newWounded[unitId] -= unitsToHeal[unitId];
                if (newWounded[unitId] <= 0) {
                    delete newWounded[unitId];
                }
            }
            newGameState.wounded = newWounded;

            let lastEndTime = Date.now();
            if (currentQueue.length > 0) {
                const lastQueueItem = currentQueue[currentQueue.length - 1];
                lastEndTime = lastQueueItem.endTime.toDate ? lastQueueItem.endTime.toDate().getTime() : new Date(lastQueueItem.endTime).getTime();
            }

            const endTime = new Date(lastEndTime + totalTime * 1000);

            for (const unitId in unitsToHeal) {
                const newQueueItem = {
                    unitId,
                    amount: unitsToHeal[unitId],
                    endTime,
                };
                 newGameState.healQueue = [...newGameState.healQueue, newQueueItem];
            }

            try {
                await saveGameState(newGameState);
                setCityGameState(newGameState);
                setMessage(`Healing started.`);
            } catch (error) {
                console.error("Error starting healing:", error);
                setMessage("Could not start healing. Please try again.");
            }

        } else {
            setMessage("Not enough resources to heal troops!");
        }
    };

    const handleWorshipGod = async (godName) => {
        if (!cityGameState || !worldId || !godName) return;
        const newWorshipData = { ...(cityGameState.worship || {}) };
        if (newWorshipData[godName] === undefined) {
            newWorshipData[godName] = 0;
        }
        newWorshipData.lastFavorUpdate = Date.now();

        const newGameState = { ...cityGameState, god: godName, worship: newWorshipData };
        await saveGameState(newGameState);
        setCityGameState(newGameState);
        closeModal('isTempleMenuOpen');
    };

    const handleCheat = async (amounts, troop, warehouseLevels, instantBuild, unresearchId, instantResearch, instantUnits, favorAmount) => {
        if (!cityGameState || !userProfile?.is_admin) return;
        setIsInstantBuild(instantBuild);
        setIsInstantResearch(instantResearch);
        setIsInstantUnits(instantUnits);

        const newGameState = { ...cityGameState };
        newGameState.resources.wood += amounts.wood;
        newGameState.resources.stone += amounts.stone;
        newGameState.resources.silver += amounts.silver;
        if (amounts.population > 0) {
            const farmLevel = newGameState.buildings.farm.level;
            newGameState.buildings.farm.level = farmLevel + amounts.population;
        }
        if (troop.amount > 0) {
            newGameState.units[troop.unit] = (newGameState.units[troop.unit] || 0) + troop.amount;
        }
        if (warehouseLevels > 0) {
            newGameState.buildings.warehouse.level += warehouseLevels;
        }
        if (unresearchId && newGameState.research[unresearchId]) {
            delete newGameState.research[unresearchId];
            setMessage(`Research "${researchConfig[unresearchId]?.name}" unreasearched!`);
        } else if (unresearchId) {
            setMessage(`Research "${researchConfig[unresearchId]?.name}" is not researched.`);
        }
        if (favorAmount > 0 && newGameState.god) {
            const currentFavor = newGameState.worship[newGameState.god] || 0;
            const templeLevel = newGameState.buildings.temple?.level || 0;
            const maxFavor = templeLevel > 0 ? 100 + (templeLevel * 20) : 0;
            newGameState.worship[newGameState.god] = Math.min(maxFavor, currentFavor + favorAmount);
            setMessage(`Added ${favorAmount} favor to ${newGameState.god}!`);
        } else if (favorAmount > 0 && !newGameState.god) {
            setMessage("No god is currently worshipped to add favor.");
        }


        await saveGameState(newGameState);
        setMessage("Admin cheat applied!");
    };

    const handlePlotClick = (buildingId) => {
        const buildingData = cityGameState.buildings[buildingId];
        if (!buildingData || buildingData.level === 0) {
            openModal('isSenateViewOpen');
            return;
        }
        switch (buildingId) {
            case 'senate': openModal('isSenateViewOpen'); break;
            case 'barracks': openModal('isBarracksMenuOpen'); break;
            case 'shipyard': openModal('isShipyardMenuOpen'); break;
            case 'temple': openModal('isTempleMenuOpen'); break;
            case 'cave': openModal('isCaveMenuOpen'); break;
            case 'academy': openModal('isAcademyMenuOpen'); break;
            case 'hospital': openModal('isHospitalMenuOpen'); break;
            default: setModalState(prev => ({ ...prev, selectedBuildingId: buildingId })); break;
        }
    };

    const handleCastSpell = async (power) => {
        const currentState = cityGameState;
        if (!currentState || !currentState.god || (currentState.worship[currentState.god] || 0) < power.favorCost) {
            setMessage("Not enough favor to cast this spell.");
            return;
        }

        const newGameState = JSON.parse(JSON.stringify(currentState));
        newGameState.worship[currentState.god] -= power.favorCost;

        switch (power.effect.type) {
            case 'add_resources':
                newGameState.resources[power.effect.resource] = (newGameState.resources[power.effect.resource] || 0) + power.effect.amount;
                break;
            case 'add_multiple_resources':
                for (const resource in power.effect.resources) {
                    newGameState.resources[resource] = (newGameState.resources[resource] || 0) + power.effect.resources[resource];
                }
                break;
            // Add more spell effects here in the future
            default:
                setMessage("This spell's effect is not yet implemented.");
                return;
        }

        try {
            await saveGameState(newGameState);
            setCityGameState(newGameState);
            setMessage(`${power.name} has been cast!`);
            closeModal('isDivinePowersOpen');
        } catch (error) {
            console.error("Error casting spell:", error);
            setMessage("Failed to cast the spell. Please try again.");
        }
    };

    if (!cityGameState) {
        return <div className="text-white text-center p-10">Loading City...</div>;
    }

    const productionRates = getProductionRates(cityGameState.buildings);
    const maxPopulation = getFarmCapacity(cityGameState.buildings?.farm?.level);
    const usedPopulation = calculateUsedPopulation(cityGameState.buildings, cityGameState.units);
    const availablePopulation = maxPopulation - usedPopulation;

    return (
        <div className="w-full h-screen flex flex-col bg-gray-900">
            <Modal message={message} onClose={() => setMessage('')} />

            <CityHeader
                cityGameState={cityGameState}
                worldId={worldId}
                showMap={showMap}
                onCityNameChange={(newName) => setCityGameState(prev => ({ ...prev, cityName: newName }))}
                setMessage={setMessage}
                onOpenCheats={() => openModal('isCheatMenuOpen')}
            />

            <ResourceBar
                resources={cityGameState.resources}
                productionRates={productionRates}
                availablePopulation={availablePopulation}
            />

            <CityViewContent
                cityGameState={cityGameState}
                handlePlotClick={handlePlotClick}
                onOpenPowers={() => openModal('isDivinePowersOpen')}
                gameSettings={gameSettings}
            />

            <CityModals
                cityGameState={cityGameState}
                worldId={worldId}
                currentUser={currentUser}
                userProfile={userProfile}
                isInstantBuild={isInstantBuild}
                getUpgradeCost={getUpgradeCost}
                getFarmCapacity={getFarmCapacity}
                getWarehouseCapacity={getWarehouseCapacity}
                getHospitalCapacity={getHospitalCapacity}
                getProductionRates={getProductionRates}
                calculateUsedPopulation={calculateUsedPopulation}
                saveGameState={saveGameState}
                handleUpgrade={handleUpgrade}
                handleCancelBuild={handleCancelBuild}
                handleTrainTroops={handleTrainTroops}
                handleCancelTrain={handleCancelTrain}
                handleStartResearch={handleStartResearch}
                handleCancelResearch={handleCancelResearch}
                handleWorshipGod={handleWorshipGod}
                handleCheat={handleCheat}
                handleHealTroops={handleHealTroops}
                modalState={modalState}
                openModal={openModal}
                closeModal={closeModal}
                setMessage={setMessage}
            />
            {modalState.isDivinePowersOpen && (
                <DivinePowers
                    godName={cityGameState.god}
                    playerReligion={cityGameState.playerInfo.religion}
                    favor={cityGameState.worship[cityGameState.god] || 0}
                    onCastSpell={handleCastSpell}
                    onClose={() => closeModal('isDivinePowersOpen')}
                />
            )}
        </div>
    );
};

export default CityView;
</file>

<file path="src/components/Game.js">
import React, { useState, useEffect, useCallback } from 'react';
import { useGame } from '../contexts/GameContext';
import CityView from './CityView';
import MapView from './MapView';
import { db } from '../firebase/config';
import { collection, query, where, getDocs, writeBatch, doc, getDoc, serverTimestamp } from 'firebase/firestore';
import { resolveCombat, resolveScouting, getVillageTroops } from '../utils/combat';
import LoadingScreen from './shared/LoadingScreen';
import Chat from './chat/Chat';
import { useCityState } from '../hooks/useCityState';

const Game = ({ onBackToWorlds }) => {
    const { worldId, gameState } = useGame();
    const { getHospitalCapacity } = useCityState(worldId);
    const [view, setView] = useState('city'); // 'city' or 'map'
    const [isChatOpen, setIsChatOpen] = useState(false);

    const processMovement = useCallback(async (movementDoc) => {
        console.log(`Processing movement ID: ${movementDoc.id}`);
        const movement = { id: movementDoc.id, ...movementDoc.data() };
        const batch = writeBatch(db);

        const originOwnerRef = doc(db, `users/${movement.originOwnerId}/games`, worldId);
        
        let targetOwnerRef;
        if (movement.targetOwnerId) {
            targetOwnerRef = doc(db, `users/${movement.targetOwnerId}/games`, worldId);
        }

        const [originOwnerSnap, targetOwnerSnap] = await Promise.all([
            getDoc(originOwnerRef),
            targetOwnerRef ? getDoc(targetOwnerRef) : Promise.resolve(null)
        ]);
        
        if (!originOwnerSnap.exists()) {
            console.log(`Origin owner ${movement.originOwnerId} not found. Deleting movement.`);
            batch.delete(movementDoc.ref);
            await batch.commit();
            return;
        }
        
        const originGameState = originOwnerSnap.data();

        if (movement.status === 'returning') {
            console.log(`Movement ${movement.id} is returning.`);
            const newGameState = { ...originGameState };

            const newUnits = { ...newGameState.units };
            for (const unitId in movement.units) {
                newUnits[unitId] = (newUnits[unitId] || 0) + movement.units[unitId];
            }
            
            const newResources = { ...newGameState.resources };
            if (movement.resources) {
                for (const resourceId in movement.resources) {
                    newResources[resourceId] = (newResources[resourceId] || 0) + movement.resources[resourceId];
                }
            }

            // Handle wounded troops
            const newWounded = { ...newGameState.wounded };
            let totalWoundedInHospital = Object.values(newWounded).reduce((sum, count) => sum + count, 0);
            const hospitalCapacity = getHospitalCapacity(newGameState.buildings.hospital?.level || 0);
            
            if (movement.wounded) {
                for (const unitId in movement.wounded) {
                    const woundedCount = movement.wounded[unitId];
                    if (totalWoundedInHospital + woundedCount <= hospitalCapacity) {
                        newWounded[unitId] = (newWounded[unitId] || 0) + woundedCount;
                        totalWoundedInHospital += woundedCount;
                    } else {
                        const canFit = hospitalCapacity - totalWoundedInHospital;
                        if (canFit > 0) {
                            newWounded[unitId] = (newWounded[unitId] || 0) + canFit;
                        }
                        // The rest die
                    }
                }
            }

             const returnReport = {
                type: 'return',
                title: `Troops returned to ${originGameState.cityName}`,
                timestamp: serverTimestamp(),
                units: movement.units,
                resources: movement.resources || {},
                wounded: movement.wounded || {},
                read: false,
            };
            batch.set(doc(collection(db, `users/${movement.originOwnerId}/reports`)), returnReport);

            batch.update(originOwnerRef, { units: newUnits, resources: newResources, wounded: newWounded });
            batch.delete(movementDoc.ref);
            console.log(`Movement ${movement.id} processed and deleted.`);
        
        } else if (movement.status === 'moving') {
            console.log(`Movement ${movement.id} is moving with type: ${movement.type}`);
            const targetGameState = targetOwnerSnap?.exists() ? targetOwnerSnap.data() : null;

            switch (movement.type) {
                case 'attack_village': {
                    console.log(`Processing village attack: ${movement.id}`);
                    const villageRef = doc(db, 'worlds', worldId, 'villages', movement.targetVillageId);
                    const villageSnap = await getDoc(villageRef);

                    if (!villageSnap.exists()) {
                        console.log(`Village ${movement.targetVillageId} not found.`);
                        batch.delete(movementDoc.ref);
                        const report = {
                            type: 'attack_village',
                            title: `Attack on missing village`,
                            timestamp: serverTimestamp(),
                            outcome: { message: 'The village was no longer there.' },
                            read: false,
                        };
                        batch.set(doc(collection(db, `users/${movement.originOwnerId}/reports`)), report);
                        break;
                    }

                    const villageData = villageSnap.data();
                    const villageTroops = getVillageTroops(villageData);
                    const result = resolveCombat(movement.units, villageTroops, villageData.resources, false);
                    console.log('Village combat resolved:', result);
                    
                    if (result.attackerWon) {
                        console.log('Attacker won. Conquering/farming village.');
                        const playerVillageRef = doc(db, `users/${movement.originOwnerId}/games/${worldId}/conqueredVillages`, movement.targetVillageId);
                        
                        batch.set(playerVillageRef, { 
                            level: villageData.level,
                            lastCollected: serverTimestamp() 
                        }, { merge: true });
                    }

                    const attackerReport = {
                        type: 'attack_village',
                        title: `Attack on ${villageData.name}`,
                        timestamp: serverTimestamp(),
                        outcome: result,
                        attacker: { cityName: originGameState.cityName, units: movement.units, losses: result.attackerLosses },
                        defender: { villageName: villageData.name, troops: villageTroops, losses: result.defenderLosses },
                        read: false,
                    };
                    batch.set(doc(collection(db, `users/${movement.originOwnerId}/reports`)), attackerReport);

                    const survivingAttackers = {};
                    let anySurvivors = false;
                    for (const unitId in movement.units) {
                        const survivors = movement.units[unitId] - (result.attackerLosses[unitId] || 0) - (result.wounded[unitId] || 0);
                        if (survivors > 0) {
                            survivingAttackers[unitId] = survivors;
                            anySurvivors = true;
                        }
                    }

                    if (anySurvivors || Object.keys(result.wounded).length > 0) {
                        console.log('Survivors/wounded are returning.');
                        const travelDuration = movement.arrivalTime.toMillis() - movement.departureTime.toMillis();
                        const returnArrivalTime = new Date(movement.arrivalTime.toDate().getTime() + travelDuration);
                        batch.update(movementDoc.ref, {
                            status: 'returning',
                            units: survivingAttackers,
                            resources: result.plunder,
                            wounded: result.wounded,
                            arrivalTime: returnArrivalTime,
                        });
                    } else {
                        console.log('No survivors. Deleting movement.');
                        batch.delete(movementDoc.ref);
                    }
                    break;
                }
                case 'attack': {
                    if (!targetGameState) {
                        console.log(`Target game state not found for movement ${movement.id}. Deleting.`);
                        batch.delete(movementDoc.ref);
                        break;
                    }
                    const result = resolveCombat(
                        movement.units, 
                        targetGameState.units, 
                        targetGameState.resources, 
                        !!movement.isCrossIsland,
                        movement.attackFormation?.front,
                        movement.attackFormation?.mid
                    );

                    const newDefenderUnits = { ...targetGameState.units };
                    for (const unitId in result.defenderLosses) {
                        newDefenderUnits[unitId] = Math.max(0, (newDefenderUnits[unitId] || 0) - result.defenderLosses[unitId]);
                    }

                    const newDefenderResources = { ...targetGameState.resources };
                    if (result.attackerWon) {
                        newDefenderResources.wood = Math.max(0, newDefenderResources.wood - result.plunder.wood);
                        newDefenderResources.stone = Math.max(0, newDefenderResources.stone - result.plunder.stone);
                        newDefenderResources.silver = Math.max(0, newDefenderResources.silver - result.plunder.silver);
                    }

                    batch.update(targetOwnerRef, { units: newDefenderUnits, resources: newDefenderResources });

                    const attackerReport = {
                        type: 'attack',
                        title: `Attack on ${targetGameState.cityName}`,
                        timestamp: serverTimestamp(),
                        outcome: result,
                        attacker: { cityName: originGameState.cityName, units: movement.units, losses: result.attackerLosses },
                        defender: { cityName: targetGameState.cityName, units: targetGameState.units, losses: result.defenderLosses },
                        read: false,
                    };
                    const defenderReport = { 
                        ...attackerReport, 
                        title: `Defense against ${originGameState.cityName}`, 
                        read: false,
                        outcome: { ...result, attackerWon: !result.attackerWon } 
                    };

                    batch.set(doc(collection(db, `users/${movement.originOwnerId}/reports`)), attackerReport);
                    batch.set(doc(collection(db, `users/${movement.targetOwnerId}/reports`)), defenderReport);

                    const survivingAttackers = {};
                    let anySurvivors = false;
                    for (const unitId in movement.units) {
                        const survivors = movement.units[unitId] - (result.attackerLosses[unitId] || 0) - (result.wounded[unitId] || 0);
                        if (survivors > 0) {
                            survivingAttackers[unitId] = survivors;
                            anySurvivors = true;
                        }
                    }

                    if (anySurvivors || Object.keys(result.wounded).length > 0) {
                        const travelDuration = movement.arrivalTime.toMillis() - movement.departureTime.toMillis();
                        const returnArrivalTime = new Date(movement.arrivalTime.toDate().getTime() + travelDuration);
                        batch.update(movementDoc.ref, {
                            status: 'returning',
                            units: survivingAttackers,
                            resources: result.plunder,
                            wounded: result.wounded,
                            arrivalTime: returnArrivalTime,
                        });
                    } else {
                        batch.delete(movementDoc.ref);
                    }
                    break;
                }
                case 'scout': {
                    if (!targetGameState) {
                        console.log(`Target game state not found for movement ${movement.id}. Deleting.`);
                        batch.delete(movementDoc.ref);
                        break;
                    }
                    const attackingSilver = movement.resources?.silver || 0;
                    const result = resolveScouting(targetGameState, attackingSilver);

                     if (result.success) {
                        const scoutReport = {
                            type: 'scout',
                            title: `Scout report of ${targetGameState.cityName}`,
                            timestamp: serverTimestamp(),
                            scoutSucceeded: true, 
                            ...result,
                            targetOwnerUsername: movement.ownerUsername,
                            read: false, 
                        };
                        batch.set(doc(collection(db, `users/${movement.originOwnerId}/reports`)), scoutReport);
                    } else {
                        const failedScoutAttackerReport = {
                            type: 'scout',
                            title: `Scouting ${targetGameState.cityName} failed`,
                            timestamp: serverTimestamp(),
                            scoutSucceeded: false, 
                            message: result.message,
                            read: false,
                        };
                        batch.set(doc(collection(db, `users/${movement.originOwnerId}/reports`)), failedScoutAttackerReport);

                        const newDefenderCave = { ...targetGameState.cave, silver: (targetGameState.cave?.silver || 0) + result.silverGained };
                        batch.update(targetOwnerRef, { cave: newDefenderCave });

                        const spyCaughtReport = {
                            type: 'spy_caught',
                            title: `Caught a spy from ${originGameState.cityName}!`,
                            timestamp: serverTimestamp(),
                            originCity: originGameState.cityName,
                            silverGained: result.silverGained,
                            read: false,
                        };
                        batch.set(doc(collection(db, `users/${movement.targetOwnerId}/reports`)), spyCaughtReport);
                    }
                    batch.delete(movementDoc.ref);
                    break;
                }
                case 'reinforce': {
                    if (!targetGameState) {
                        console.log(`Target game state not found for movement ${movement.id}. Deleting.`);
                        batch.delete(movementDoc.ref);
                        break;
                    }
                    const newTargetUnits = { ...targetGameState.units };
                    for (const unitId in movement.units) {
                        newTargetUnits[unitId] = (newTargetUnits[unitId] || 0) + movement.units[unitId];
                    }
                    batch.update(targetOwnerRef, { units: newTargetUnits });

                    const reinforceReport = { type: 'reinforce', title: `Reinforcement to ${targetGameState.cityName}`, timestamp: serverTimestamp(), units: movement.units, read: false };
                    batch.set(doc(collection(db, `users/${movement.originOwnerId}/reports`)), reinforceReport);

                    const arrivalReport = { type: 'reinforce', title: `Reinforcements from ${originGameState.cityName}`, timestamp: serverTimestamp(), units: movement.units, read: false };
                    batch.set(doc(collection(db, `users/${movement.targetOwnerId}/reports`)), arrivalReport);

                    batch.delete(movementDoc.ref);
                    break;
                }
                case 'trade': {
                    if (!targetGameState) {
                        console.log(`Target game state not found for movement ${movement.id}. Deleting.`);
                        batch.delete(movementDoc.ref);
                        break;
                    }
                    const newTargetResources = { ...targetGameState.resources };
                    for (const resource in movement.resources) {
                        newTargetResources[resource] = (newTargetResources[resource] || 0) + movement.resources[resource];
                    }
                    batch.update(targetOwnerRef, { resources: newTargetResources });

                    const tradeReport = { type: 'trade', title: `Trade to ${targetGameState.cityName}`, timestamp: serverTimestamp(), resources: movement.resources, read: false };
                    batch.set(doc(collection(db, `users/${movement.originOwnerId}/reports`)), tradeReport);

                    const arrivalReport = { type: 'trade', title: `Trade from ${originGameState.cityName}`, timestamp: serverTimestamp(), resources: movement.resources, read: false };
                    batch.set(doc(collection(db, `users/${movement.targetOwnerId}/reports`)), arrivalReport);

                    batch.delete(movementDoc.ref);
                    break;
                }
                default:
                    console.log(`Unknown movement type: ${movement.type}. Deleting movement ${movement.id}`);
                    batch.delete(movementDoc.ref);
                    break;
            }
        }
        await batch.commit();
        console.log(`Batch commit successful for movement ${movement.id}`);
    }, [worldId, getHospitalCapacity]);

    useEffect(() => {
        const processMovements = async () => {
            if (!worldId) return;

            const movementsRef = collection(db, 'worlds', worldId, 'movements');
            const q = query(movementsRef, where('arrivalTime', '<=', new Date()));

            const arrivedMovementsSnapshot = await getDocs(q);
            if (arrivedMovementsSnapshot.empty) return;

            console.log(`Found ${arrivedMovementsSnapshot.docs.length} arrived movements to process.`);
            for (const movementDoc of arrivedMovementsSnapshot.docs) {
                try {
                    await processMovement(movementDoc);
                } catch (error) {
                    console.error("Error processing movement:", movementDoc.id, error);
                }
            }
        };

        const interval = setInterval(processMovements, 5000); // Check every 5 seconds
        return () => clearInterval(interval);
    }, [worldId, processMovement]);


    if (!gameState) {
        return <LoadingScreen message="Loading Game..." />;
    }

    const showMap = () => setView('map');
    const showCity = () => setView('city');

    return (
        <div className="w-full h-screen bg-gray-900 text-white">
            {view === 'city' && <CityView showMap={showMap} worldId={worldId} />}
            {view === 'map' && <MapView showCity={showCity} onBackToWorlds={onBackToWorlds} />}
            
            <div className="chat-container">
                <button onClick={() => setIsChatOpen(prev => !prev)} className="chat-toggle-button">
                    💬
                </button>
                <Chat 
                    worldId={worldId} 
                    isVisible={isChatOpen} 
                    onClose={() => setIsChatOpen(false)} 
                />
            </div>
        </div>
    );
};

export default Game;
</file>

<file path="src/components/MapView.js">
// src/components/MapView.js

import React, { useState, useRef, useCallback, useEffect, useMemo } from 'react';
import { useAuth } from '../contexts/AuthContext';
import { useGame } from '../contexts/GameContext';
import { signOut } from "firebase/auth";
import { auth, db } from '../firebase/config';
import { doc, updateDoc, collection, onSnapshot, query, where, writeBatch, serverTimestamp, getDoc } from 'firebase/firestore';


// UI Components
import Modal from './shared/Modal';
import SidebarNav from './map/SidebarNav';
import TopBar from './map/TopBar';
import MapGrid from './map/MapGrid';
import MapModals from './map/MapModals';
import SideInfoPanel from './SideInfoPanel';
import AllianceModal from './map/AllianceModal';
import SettingsModal from './shared/SettingsModal';
import DivinePowers from './city/DivinePowers';
import ProfileView from './profile/ProfileView';
import AllianceCreation from './alliance/AllianceCreation'; // Import AllianceCreation

// Custom Hooks
import { useMapInteraction } from '../hooks/useMapInteraction';
import { useMapData } from '../hooks/usemapdatapls';
import { useModalState } from '../hooks/useModalState';
import { useMapActions } from '../hooks/useMapActions';
import { useCityState } from '../hooks/useCityState';

// Utilities
import { calculateDistance } from '../utils/travel';
import { getVillageTroops } from '../utils/combat';
import buildingConfig from '../gameData/buildings.json';


const MapView = ({ showCity, onBackToWorlds }) => {
    const { currentUser, userProfile } = useAuth();
    const { worldState, gameState, setGameState, worldId, playerCity, playerAlliance, conqueredVillages, gameSettings } = useGame();

    const [isPlacingDummyCity, setIsPlacingDummyCity] = useState(false);
    const [unreadReportsCount, setUnreadReportsCount] = useState(0);
    const [unreadMessagesCount, setUnreadMessagesCount] = useState(0);
    const [isSettingsModalOpen, setIsSettingsModalOpen] = useState(false);

    const viewportRef = useRef(null);
    const mapContainerRef = useRef(null);

    const {
        modalState,
        openModal,
        closeModal,
    } = useModalState();

    const {
        pan,
        zoom,
        viewportSize,
        borderOpacity,
        isPanning,
        handleMouseDown,
        goToCoordinates,
        centerOnCity
    } = useMapInteraction(viewportRef, mapContainerRef, worldState, playerCity);

    const {
        movements,
        visibleSlots,
        villages,
        invalidateChunkCache
    } = useMapData(currentUser, worldId, worldState, pan, zoom, viewportSize);

    const {
        message,
        setMessage,
        travelTimeInfo,
        setTravelTimeInfo,
        handleActionClick,
        handleSendMovement,
        handleCreateDummyCity
    } = useMapActions(openModal, closeModal, showCity, invalidateChunkCache);
    
    const { getFarmCapacity, calculateUsedPopulation } = useCityState(worldId);

    const maxPopulation = useMemo(() => {
        return gameState?.buildings ? getFarmCapacity(gameState.buildings.farm?.level) : 0;
    }, [gameState?.buildings, getFarmCapacity]);

    const usedPopulation = useMemo(() => {
        return gameState?.buildings && gameState?.units ? calculateUsedPopulation(gameState.buildings, gameState.units) : 0;
    }, [gameState?.buildings, gameState?.units, calculateUsedPopulation]);

    const availablePopulation = useMemo(() => {
        return maxPopulation - usedPopulation;
    }, [maxPopulation, usedPopulation]);

    const handleOpenAlliance = () => {
        if (playerAlliance) {
            openModal('alliance');
        } else {
            openModal('allianceCreation');
        }
    };

    useEffect(() => {
        if (!currentUser) return;
        const reportsQuery = query(collection(db, 'users', currentUser.uid, 'reports'), where('read', '==', false));
        const unsubscribeReports = onSnapshot(reportsQuery, (snapshot) => {
            setUnreadReportsCount(snapshot.size);
        });

        const conversationsQuery = query(
            collection(db, 'worlds', worldId, 'conversations'),
            where('participants', 'array-contains', currentUser.uid)
        );
        const unsubscribeMessages = onSnapshot(conversationsQuery, (snapshot) => {
            let unreadCount = 0;
            snapshot.forEach(doc => {
                const convo = doc.data();
                if (convo.lastMessage && convo.lastMessage.senderId !== currentUser.uid && !convo.readBy.includes(currentUser.uid)) {
                    unreadCount++;
                }
            });
            setUnreadMessagesCount(unreadCount);
        });

        return () => {
            unsubscribeReports();
            unsubscribeMessages();
        };
    }, [currentUser, worldId]);

    useEffect(() => {
        const handleKeyDown = (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                centerOnCity();
            }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
    }, [centerOnCity]);

    const combinedSlots = useMemo(() => {
        const slots = { ...visibleSlots };
        if (playerCity) {
            slots[playerCity.id] = playerCity;
        }
        return slots;
    }, [visibleSlots, playerCity]);
    
    const onCitySlotClick = (e, slotData) => {
        closeModal('village');
        if (isPlacingDummyCity && !slotData.ownerId) {
            handleCreateDummyCity(slotData.id, slotData).then(() => {
                setIsPlacingDummyCity(false);
            });
            return;
        }

        if (slotData.ownerId === currentUser.uid) {
            showCity();
        } else if (slotData.ownerId) {
            if (playerCity) {
                const distance = calculateDistance(playerCity, slotData);
                setTravelTimeInfo({ distance });
            }
            const cityDataWithAlliance = { ...slotData, playerAlliance };
            openModal('city', cityDataWithAlliance);
        } else {
            setMessage('This plot is empty. Future updates will allow colonization!');
        }
    };
    
    const onVillageClick = (e, villageData) => {
        closeModal('city');
        if (playerCity.islandId !== villageData.islandId) {
            setMessage("You can only interact with villages on islands where you have a city.");
            return;
        }

        const isConqueredByPlayer = conqueredVillages && conqueredVillages[villageData.id];

        if (isConqueredByPlayer) {
            openModal('village', { ...villageData, ...conqueredVillages[villageData.id] });
        } else {
            const distance = playerCity ? calculateDistance(playerCity, villageData) : Infinity;
            setTravelTimeInfo({ distance });
            const targetData = {
                id: villageData.id,
                name: villageData.name,
                cityName: villageData.name,
                ownerId: null,
                ownerUsername: 'Neutral',
                x: villageData.x,
                y: villageData.y,
                islandId: villageData.islandId,
                isVillageTarget: true,
                troops: getVillageTroops(villageData),
                level: villageData.level || 1,
                demands: villageData.demands,
                supplies: villageData.supplies,
                tradeRatio: villageData.tradeRatio
            };
            openModal('city', targetData);
        }
    };

    const handleRushMovement = useCallback(async (movementId) => {
        if (!userProfile?.is_admin) return;
        const movementRef = doc(db, 'worlds', worldId, 'movements', movementId);
        await updateDoc(movementRef, { arrivalTime: new Date() });
    }, [userProfile, worldId]);

    const handleToggleDummyCityPlacement = () => {
        setIsPlacingDummyCity(prevMode => !prevMode);
        setMessage(isPlacingDummyCity ? 'Dummy city placement OFF.' : 'Dummy city placement ON. Click an empty slot.');
    };

    const handleCastSpell = async (power, targetCity) => {
        const currentState = gameState;
        if (!currentState || !currentState.god || (currentState.worship[currentState.god] || 0) < power.favorCost) {
            setMessage("Not enough favor to cast this spell.");
            return;
        }
    
        const batch = writeBatch(db);
    
        // 1. Deduct favor from the caster
        const casterGameDocRef = doc(db, `users/${currentUser.uid}/games`, worldId);
        const newWorship = { ...currentState.worship };
        newWorship[currentState.god] -= power.favorCost;
        batch.update(casterGameDocRef, { worship: newWorship });
    
        // 2. Determine target
        const isSelfCast = !targetCity;
        const targetOwnerId = isSelfCast ? currentUser.uid : targetCity.ownerId;
        const targetGameDocRef = doc(db, `users/${targetOwnerId}/games`, worldId);
        const targetGameSnap = await getDoc(targetGameDocRef);
    
        if (!targetGameSnap.exists()) {
            setMessage("Target city's game data not found.");
            await batch.commit(); // Still commit the favor cost deduction
            setGameState({ ...gameState, worship: newWorship });
            return;
        }
    
        const targetGameState = targetGameSnap.data();
        let spellEffectMessage = '';
        let casterMessage = '';
    
        // 3. Apply spell effect
        switch (power.effect.type) {
            case 'add_resources':
            case 'add_multiple_resources': {
                const resourcesToAdd = power.effect.type === 'add_resources'
                    ? { [power.effect.resource]: power.effect.amount }
                    : power.effect.resources;
                
                const newResources = { ...targetGameState.resources };
                let resourcesReceivedMessage = [];
                for (const resource in resourcesToAdd) {
                    newResources[resource] = (newResources[resource] || 0) + resourcesToAdd[resource];
                    resourcesReceivedMessage.push(`${resourcesToAdd[resource]} ${resource}`);
                }
                batch.update(targetGameDocRef, { resources: newResources });
    
                if (isSelfCast) {
                    casterMessage = `You have blessed yourself with ${resourcesReceivedMessage.join(' and ')}!`;
                } else {
                    spellEffectMessage = `Your city ${targetGameState.cityName} has been blessed with ${resourcesReceivedMessage.join(' and ')} by ${userProfile.username}!`;
                    casterMessage = `You have blessed ${targetGameState.cityName} with ${resourcesReceivedMessage.join(' and ')}.`;
                }
                break;
            }
            case 'damage_building': {
                if (isSelfCast) break; // This spell should not be self-cast
                const buildings = { ...targetGameState.buildings };
                const buildingKeys = Object.keys(buildings).filter(b => buildings[b].level > 0);
                if (buildingKeys.length > 0) {
                    const randomBuildingKey = buildingKeys[Math.floor(Math.random() * buildingKeys.length)];
                    buildings[randomBuildingKey].level = Math.max(0, buildings[randomBuildingKey].level - power.effect.amount);
                    spellEffectMessage = `Your ${buildingConfig[randomBuildingKey]?.name || 'building'} in ${targetGameState.cityName} was damaged by a divine power from ${userProfile.username}!`;
                    casterMessage = `You damaged a building in ${targetGameState.cityName}.`;
                    batch.update(targetGameDocRef, { buildings });
                } else {
                    casterMessage = `You attempted to damage a building in ${targetGameState.cityName}, but there were none.`;
                }
                break;
            }
            default:
                setMessage("This spell's effect is not yet implemented for instant casting.");
                return; // Don't commit batch if not implemented
        }
    
        // 4. Create reports
        const casterReport = {
            type: 'spell_cast',
            title: `Spell cast: ${power.name}`,
            timestamp: serverTimestamp(),
            outcome: { message: casterMessage },
            read: false,
        };
        batch.set(doc(collection(db, `users/${currentUser.uid}/reports`)), casterReport);
    
        if (!isSelfCast) {
            const targetReport = {
                type: 'spell_received',
                title: `Divine Intervention!`,
                timestamp: serverTimestamp(),
                outcome: { message: spellEffectMessage, from: playerCity.cityName },
                read: false,
            };
            batch.set(doc(collection(db, `users/${targetOwnerId}/reports`)), targetReport);
        }
    
        // 5. Commit batch and update local state
        try {
            await batch.commit();
            setMessage(`${power.name} has been cast!`);
            closeModal('divinePowers');
            
            // Optimistically update local state for caster
            if (isSelfCast) {
                const updatedSelfSnap = await getDoc(casterGameDocRef);
                if (updatedSelfSnap.exists()) {
                    setGameState(updatedSelfSnap.data());
                }
            } else {
                setGameState({ ...gameState, worship: newWorship });
            }
        } catch (error) {
            console.error("Error casting spell:", error);
            setMessage("Failed to cast the spell. Please try again.");
        }
    };
    
    const mapGrid = useMemo(() => {
        if (!worldState?.islands) return null;
        const grid = Array(worldState.height).fill(null).map(() => Array(worldState.width).fill({ type: 'water' }));

        worldState.islands.forEach(island => {
            const centerX = Math.round(island.x);
            const centerY = Math.round(island.y);
            for (let i = -Math.floor(island.radius); i <= Math.ceil(island.radius); i++) {
                for (let j = -Math.floor(island.radius); j <= Math.ceil(island.radius); j++) {
                    if (i * i + j * j <= island.radius * island.radius) {
                        const x = centerX + j;
                        const y = centerY + i;
                        if (y >= 0 && y < worldState.height && x >= 0 && x < worldState.width) {
                            grid[y][x] = { type: 'land' };
                        }
                    }
                }
            }
        });

        Object.values(combinedSlots).forEach(slot => {
            if (slot.x !== undefined && slot.y !== undefined) {
                const x = Math.round(slot.x);
                const y = Math.round(slot.y);
                if (grid[y]?.[x]) {
                    grid[y][x] = { type: 'city_slot', data: slot };
                }
            }
        });

        Object.values(villages).forEach(village => {
            const x = Math.round(village.x);
            const y = Math.round(village.y);
            if (grid[y]?.[x]?.type === 'land') {
                grid[y][x] = { type: 'village', data: village };
            }
        });

        return grid;
    }, [worldState, combinedSlots, villages]);

    return (
        <div className="w-full h-screen flex flex-col bg-gray-900">
            <Modal message={message} onClose={() => setMessage('')} />
            <header className="flex-shrink-0 flex justify-between items-center p-2 bg-gray-800 shadow-lg border-b border-gray-700 z-30">
                <h1 className="font-title text-2xl text-gray-300">World Map</h1>
                <div className="flex items-center space-x-4">
                    <p className="text-xs text-gray-400">Player: <span className="font-mono">{userProfile?.username || currentUser?.email}</span></p>
                    <button onClick={onBackToWorlds} className="text-xs text-blue-400 hover:text-blue-300">Back to Worlds</button>
                    <button onClick={() => signOut(auth)} className="text-xs text-red-400 hover:text-red-300">Logout</button>
                </div>
            </header>

            <div className="flex-grow flex flex-row p-4 gap-4 overflow-hidden">
                <SidebarNav
                    onGoToCity={showCity}
                    onOpenMovements={() => openModal('movements')}
                    onOpenReports={() => openModal('reports')}
                    onOpenAlliance={handleOpenAlliance}
                    onOpenMessages={() => openModal('messages')}
                    onOpenSettings={() => setIsSettingsModalOpen(true)}
                    onOpenProfile={() => openModal('profile')}
                    unreadReportsCount={unreadReportsCount}
                    unreadMessagesCount={unreadMessagesCount}
                    isAdmin={userProfile?.is_admin}
                    onToggleDummyCityPlacement={handleToggleDummyCityPlacement}
                />
                <div className="main-content flex-grow relative">
                    <div
                        className="map-viewport"
                        ref={viewportRef}
                        onMouseDown={handleMouseDown}
                        style={{ cursor: isPanning ? 'grabbing' : (isPlacingDummyCity ? 'crosshair' : 'grab') }}
                    >
                        <TopBar 
                            gameState={gameState} 
                            availablePopulation={availablePopulation} 
                            maxPopulation={maxPopulation} 
                        />
                        <SideInfoPanel 
                            gameState={gameState} 
                            className="absolute top-16 right-4 z-20 flex flex-col gap-4"
                            onOpenPowers={() => openModal('divinePowers')}
                        />
                        <div className="map-border top" style={{ opacity: borderOpacity.top }}></div>
                        <div className="map-border bottom" style={{ opacity: borderOpacity.bottom }}></div>
                        <div className="map-border left" style={{ opacity: borderOpacity.left }}></div>
                        <div className="map-border right" style={{ opacity: borderOpacity.right }}></div>

                        <div
                            ref={mapContainerRef}
                            style={{
                                width: worldState?.islands ? worldState.width * 32 : 0,
                                height: worldState?.islands ? worldState.height * 32 : 0,
                                transformOrigin: '0 0',
                            }}
                        >
                            <MapGrid
                                mapGrid={mapGrid}
                                worldState={worldState}
                                pan={pan}
                                zoom={zoom}
                                viewportSize={viewportSize}
                                onCitySlotClick={onCitySlotClick}
                                onVillageClick={onVillageClick}
                                isPlacingDummyCity={isPlacingDummyCity}
                                movements={movements}
                                combinedSlots={combinedSlots}
                                villages={villages}
                                playerAlliance={playerAlliance}
                                conqueredVillages={conqueredVillages}
                                gameSettings={gameSettings}
                            />
                        </div>
                    </div>
                </div>
            </div>
            
            <MapModals
                modalState={modalState}
                closeModal={closeModal}
                gameState={gameState}
                playerCity={playerCity}
                travelTimeInfo={travelTimeInfo}
                handleSendMovement={handleSendMovement}
                setMessage={setMessage}
                goToCoordinates={goToCoordinates}
                handleActionClick={handleActionClick}
                worldId={worldId}
                movements={movements}
                combinedSlots={combinedSlots}
                villages={villages}
                handleRushMovement={handleRushMovement}
                userProfile={userProfile}
            />
            
            {modalState.isAllianceModalOpen && (
                <AllianceModal onClose={() => closeModal('alliance')} />
            )}

            {modalState.isAllianceCreationOpen && (
                <AllianceCreation onClose={() => closeModal('allianceCreation')} />
            )}

            {isSettingsModalOpen && (
                <SettingsModal
                    onClose={() => setIsSettingsModalOpen(false)}
                />
            )}

            {modalState.isDivinePowersOpen && (
                <DivinePowers
                    godName={gameState.god}
                    playerReligion={gameState.playerInfo.religion}
                    favor={gameState.worship[gameState.god] || 0}
                    onCastSpell={(power) => handleCastSpell(power, modalState.divinePowersTarget)}
                    onClose={() => closeModal('divinePowers')}
                    targetType={modalState.divinePowersTarget ? 'other' : 'self'}
                />
            )}
            
            {modalState.isProfileModalOpen && (
                <ProfileView onClose={() => closeModal('profile')} />
            )}
        </div>
    );
};

export default MapView;
</file>

<file path="src/components/ReportsView.js">
import React, { useState, useEffect } from 'react';
import { collection, onSnapshot, doc, updateDoc, deleteDoc, query, orderBy } from 'firebase/firestore';
import { db } from '../firebase/config';
import { useAuth } from '../contexts/AuthContext';
import unitConfig from '../gameData/units.json';
import buildingConfig from '../gameData/buildings.json';
import godsConfig from '../gameData/gods.json'; // Import gods config

// Dynamically import all images from the images and its subfolders
const images = {};

// Context for images directly in src/images (e.g., units)
const mainImageContext = require.context('../images', false, /\.(png|jpe?g|svg)$/);
mainImageContext.keys().forEach((item) => {
    const key = item.replace('./', ''); // e.g., 'swordman.png'
    images[key] = mainImageContext(item);
});

// Context for images in src/images/resources
const resourceImageContext = require.context('../images/resources', false, /\.(png|jpe?g|svg)$/);
resourceImageContext.keys().forEach((item) => {
    const key = `resources/${item.replace('./', '')}`; // e.g., 'resources/wood.png'
    images[key] = resourceImageContext(item);
});

// Context for images in src/images/buildings
const buildingImageContext = require.context('../images/buildings', false, /\.(png|jpe?g|svg)$/);
buildingImageContext.keys().forEach((item) => {
    const key = `buildings/${item.replace('./', '')}`; // e.g., 'buildings/senate.png'
    images[key] = buildingImageContext(item);
});

// Context for images in src/images/gods
const godsImageContext = require.context('../images/gods', false, /\.(png|jpe?g|svg)$/);
godsImageContext.keys().forEach((item) => {
    const key = `gods/${item.replace('./', '')}`; // e.g., 'gods/zeus.png'
    images[key] = godsImageContext(item);
});


const ReportsView = ({ onClose }) => {
    const { currentUser } = useAuth();
    const [reports, setReports] = useState([]);
    const [selectedReport, setSelectedReport] = useState(null);
    const [activeTab, setActiveTab] = useState('Combat');

    const tabs = {
        'Combat': ['attack', 'attack_village'],
        'Reinforce': ['reinforce'],
        'Trade': ['trade'],
        'Scout': ['scout', 'spy_caught'],
        'Misc': ['return', 'spell_cast', 'spell_received', 'spell_fail'],
    };

    useEffect(() => {
        if (!currentUser) return;
        const reportsQuery = query(collection(db, 'users', currentUser.uid, 'reports'), orderBy('timestamp', 'desc'));
        const unsubscribe = onSnapshot(reportsQuery, (snapshot) => {
            const reportsData = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            setReports(reportsData);
        });
        return () => unsubscribe();
    }, [currentUser]);

    useEffect(() => {
        if (!currentUser || reports.length === 0) return;
    
        const unreadReports = reports.filter(report => !report.read);
    
        if (unreadReports.length > 0) {
            unreadReports.forEach(async (report) => {
                if (report.id) {
                    try {
                        const reportRef = doc(db, 'users', currentUser.uid, 'reports', report.id);
                        await updateDoc(reportRef, { read: true });
                    } catch (error) {
                        console.error(`Failed to mark report ${report.id} as read:`, error);
                    }
                }
            });
        }
    }, [reports, currentUser]);

    const handleSelectReport = async (report) => {
        setSelectedReport(report);
        if (!report.read) {
            const reportRef = doc(db, 'users', currentUser.uid, 'reports', report.id);
            await updateDoc(reportRef, { read: true });
        }
    };

    const handleDeleteReport = async (reportId) => {
        const reportRef = doc(db, 'users', currentUser.uid, 'reports', reportId);
        await deleteDoc(reportRef);
        if (selectedReport && selectedReport.id === reportId) {
            setSelectedReport(null);
        }
    };

    const handleTabClick = (tabName) => {
        setActiveTab(tabName);
        setSelectedReport(null);
    };
    
    const getReportTitleColor = (report) => {
        switch (report.type) {
            case 'attack':
            case 'attack_village':
                return report.outcome?.attackerWon ? 'text-green-400' : 'text-red-400';
            case 'scout':
                return report.scoutSucceeded ? 'text-green-400' : 'text-red-400';
            case 'spy_caught':
                return 'text-red-400';
            case 'spell_cast':
            case 'spell_received':
                return 'text-purple-400';
            case 'spell_fail':
                return 'text-red-400';
            case 'return':
            case 'reinforce':
                return 'text-blue-400';
            case 'trade':
                return 'text-yellow-400';
            default:
                return 'text-gray-300';
        }
    };

    const getReportTitle = (report) => {
        let title = report.title || 'Untitled Report';
        if (report.type === 'attack' || report.type === 'attack_village') {
            title += report.outcome?.attackerWon ? ' (Victory)' : ' (Defeat)';
        }
        return title;
    };

    const renderUnitList = (units) => {
        if (!units || Object.keys(units).length === 0) return 'None';
        return Object.entries(units)
            .map(([id, count]) => `${count} ${unitConfig[id]?.name || id}`)
            .join(', ');
    };
    
    const getImageUrl = (imageName) => {
        if (!imageName) return '';
        if (images[imageName]) {
            return images[imageName];
        }
        if (imageName.startsWith('resources/')) {
            if (images[imageName]) {
                return images[imageName];
            }
        }
        if (imageName.startsWith('buildings/')) {
             if (images[imageName]) {
                return images[imageName];
            }
        }
        if (imageName.startsWith('gods/')) {
             if (images[imageName]) {
                return images[imageName];
            }
        }
        
        console.warn(`Image not found: ${imageName}`);
        return '';
    };

    const renderTroopDisplay = (units) => {
        if (!units || Object.keys(units).length === 0) return null;
        
        return (
            <div className="flex flex-wrap items-center justify-center gap-2">
                {Object.entries(units).map(([unitId, count]) => {
                    if (count > 0) {
                        const unit = unitConfig[unitId];
                        const imageSrc = getImageUrl(unit?.image || '');
                        return (
                            <div key={unitId} className="flex flex-col items-center">
                                {imageSrc && <img src={imageSrc} alt={unit?.name || unitId} className="w-8 h-8"/>}
                                <span className="text-sm">{count}</span>
                            </div>
                        );
                    }
                    return null;
                })}
            </div>
        );
    };

    const renderResourceIcons = (resources) => {
        return Object.entries(resources || {}).map(([res, amount]) => {
            const imagePath = `resources/${res}.png`;
            const imageSrc = getImageUrl(imagePath);
            return (
                <div key={res} className="flex flex-col items-center mx-2">
                    {imageSrc && <img src={imageSrc} alt={res} className="w-8 h-8"/>}
                    <span className="text-sm">{Math.floor(amount)}</span>
                </div>
            );
        });
    };

    const renderBuildingDisplay = (buildings) => {
        if (!buildings || Object.keys(buildings).length === 0) return null;

        return (
            <div className="flex flex-wrap items-center justify-center gap-2">
                {Object.entries(buildings).map(([buildingId, data]) => {
                    if (data.level > 0) {
                        const building = buildingConfig[buildingId];
                        const imageSrc = getImageUrl(`buildings/${building?.image}` || '');
                        return (
                            <div key={buildingId} className="flex flex-col items-center">
                                {imageSrc && <img src={imageSrc} alt={building?.name || buildingId} className="w-8 h-8"/>}
                                <span className="text-sm">{building?.name || buildingId} (Lvl {data.level})</span>
                            </div>
                        );
                    }
                    return null;
                })}
            </div>
        );
    };

    const renderReportOutcome = (report) => {
        const outcome = report.outcome || {};
        const attacker = report.attacker || {};
        const defender = report.defender || {};

        switch (report.type) {
            case 'attack':
                return (
                    <div className="flex flex-col items-center">
                        <p className={`font-bold text-2xl mb-4 ${outcome.attackerWon ? 'text-green-400' : 'text-red-400'}`}>
                            {outcome.attackerWon ? 'Victory!' : 'Defeat!'}
                        </p>
                        <div className="flex items-center justify-between w-full mb-4">
                            <div className="flex flex-col items-center w-1/3">
                                <p className="font-bold text-lg">{attacker.cityName || 'Unknown City'}</p>
                                <p className="text-sm text-gray-400">{report.originOwnerUsername || 'You'}</p>
                            </div>
                            <div className="w-1/3 text-center">
                                <img src={getImageUrl('swordman.png')} alt="Attack Icon" className="mx-auto h-12 w-auto"/>
                            </div>
                            <div className="flex flex-col items-center w-1/3">
                                <p className="font-bold text-lg">{defender.cityName || 'Unknown City'}</p>
                                <p className="text-sm text-gray-400">{report.ownerUsername || 'Opponent'}</p>
                            </div>
                        </div>

                        <div className="w-full grid grid-cols-2 gap-4 text-sm mt-4">
                            <div className="p-3 bg-gray-700/50 rounded flex flex-col items-center">
                                <h4 className="font-semibold text-lg text-yellow-300 mb-2">Attacker Units</h4>
                                {renderTroopDisplay(attacker.units)}
                                <p className="mt-2"><strong>Losses:</strong> {renderUnitList(outcome.attackerLosses)}</p>
                            </div>
                            <div className="p-3 bg-gray-700/50 rounded flex flex-col items-center">
                                <h4 className="font-semibold text-lg text-yellow-300 mb-2">Defender Units</h4>
                                {renderTroopDisplay(defender.units)}
                                <p className="mt-2"><strong>Losses:</strong> {renderUnitList(outcome.defenderLosses)}</p>
                            </div>
                        </div>

                        {outcome.attackerWon && outcome.plunder && (
                            <div className="w-full p-3 bg-green-800/30 rounded mt-4 text-center">
                                <h4 className="font-semibold text-lg text-green-300 mb-2">Plundered Resources</h4>
                                <div className="flex justify-center">
                                    {renderResourceIcons(outcome.plunder)}
                                </div>
                            </div>
                        )}
                        <p className="text-gray-400 mt-4">No battle points received.</p>
                    </div>
                );

            case 'attack_village':
                return (
                    <div className="flex flex-col items-center">
                        <p className={`font-bold text-2xl mb-4 ${outcome.attackerWon ? 'text-green-400' : 'text-red-400'}`}>
                            {outcome.attackerWon ? 'Victory!' : 'Defeat!'}
                        </p>
                        <div className="flex items-center justify-between w-full mb-4">
                            <div className="flex flex-col items-center w-1/3">
                                <p className="font-bold text-lg">{attacker.cityName || 'Unknown City'}</p>
                                <p className="text-sm text-gray-400">{report.originOwnerUsername || 'You'}</p>
                            </div>
                            <div className="w-1/3 text-center">
                                <img src={getImageUrl('swordman.png')} alt="Attack Icon" className="mx-auto h-12 w-auto"/>
                            </div>
                            <div className="flex flex-col items-center w-1/3">
                                <p className="font-bold text-lg">{defender.villageName || 'Unknown Village'}</p>
                                <p className="text-sm text-gray-400">Neutral</p>
                            </div>
                        </div>

                        <div className="w-full grid grid-cols-2 gap-4 text-sm mt-4">
                            <div className="p-3 bg-gray-700/50 rounded flex flex-col items-center">
                                <h4 className="font-semibold text-lg text-yellow-300 mb-2">Attacker Units</h4>
                                {renderTroopDisplay(attacker.units)}
                                <p className="mt-2"><strong>Losses:</strong> {renderUnitList(outcome.attackerLosses)}</p>
                            </div>
                            <div className="p-3 bg-gray-700/50 rounded flex flex-col items-center">
                                <h4 className="font-semibold text-lg text-yellow-300 mb-2">Village Troops</h4>
                                {renderTroopDisplay(defender.troops)}
                                <p className="mt-2"><strong>Losses:</strong> {renderUnitList(outcome.defenderLosses)}</p>
                            </div>
                        </div>

                        {outcome.attackerWon && (
                            <p className="text-green-400 font-bold mt-4">You have conquered the village!</p>
                        )}
                        <p className="text-gray-400 mt-4">No battle points received.</p>
                    </div>
                );

            case 'scout':
                const scoutedGod = (report.god && report.playerReligion) ? godsConfig[report.playerReligion.toLowerCase()]?.[report.god] : null;
                return (
                    <div className="space-y-3">
                        {report.scoutSucceeded ? (
                            <>
                                <p className="font-bold text-green-400 text-lg">Scout Successful!</p>
                                <p><strong>Target City:</strong> {report.targetCityName}</p>
                                <p><strong>Owner:</strong> {report.targetOwnerUsername || 'Unknown'}</p>
                                {scoutedGod && (
                                    <div className="flex items-center gap-2 mt-2">
                                        <p><strong>Worshipped God:</strong> {scoutedGod.name}</p>
                                        <img src={getImageUrl(`gods/${scoutedGod.image}`)} alt={scoutedGod.name} className="w-8 h-8"/>
                                    </div>
                                )}
                                <div className="mt-4">
                                    <h5 className="font-semibold text-yellow-300">Resources:</h5>
                                    <div className="flex flex-wrap gap-2">{renderResourceIcons(report.resources)}</div>
                                </div>
                                <div className="mt-4">
                                    <h5 className="font-semibold text-yellow-300">Units:</h5>
                                    {renderTroopDisplay(report.units)}
                                </div>
                                <div className="mt-4">
                                    <h5 className="font-semibold text-yellow-300">Buildings:</h5>
                                    {renderBuildingDisplay(report.buildings)}
                                </div>
                            </>
                        ) : (
                            <p className="font-bold text-red-400">{report.message || 'Scout Failed!'}</p>
                        )}
                    </div>
                );
            case 'spell_cast':
            case 'spell_received':
            case 'spell_fail':
                return (
                    <div className="space-y-2 text-center">
                        <p className="font-bold text-lg">{report.title}</p>
                        <p>{outcome.message}</p>
                        {outcome.from && <p className="text-sm text-gray-400">From: {outcome.from}</p>}
                    </div>
                );
            
            case 'return':
                return (
                    <div className="space-y-1">
                        <p className="font-bold text-blue-400">Troops Returned</p>
                        <p><strong>Surviving Units:</strong></p>
                        {renderTroopDisplay(report.units)}
                        <div className="flex flex-wrap gap-2 mt-2">
                            <strong>Loot:</strong> {renderResourceIcons(report.resources)}
                        </div>
                    </div>
                );

            case 'spy_caught':
                return (
                    <div className="space-y-1">
                        <p className="font-bold text-red-400">Spy Detected!</p>
                        <p>A spy from {report.originCityName || 'an unknown city'} was detected.</p>
                        {report.silverGained > 0 && (
                            <div className="flex items-center gap-2">
                                <p>You gained:</p> {renderResourceIcons({ silver: report.silverGained })}
                            </div>
                        )}
                    </div>
                );
            
            case 'reinforce':
                return (
                    <div className="space-y-1">
                        <p className="font-bold text-blue-400">Reinforcement Arrived</p>
                        <p><strong>From:</strong> {report.originCityName}</p>
                        <p><strong>To:</strong> {report.targetCityName}</p>
                        <p><strong>Units:</strong></p>
                        {renderTroopDisplay(report.units)}
                    </div>
                );

            case 'trade':
                return (
                    <div className="space-y-1">
                        <p className="font-bold text-yellow-400">Trade Complete</p>
                        <p><strong>From:</strong> {report.originCityName}</p>
                        <p><strong>To:</strong> {report.targetCityName}</p>
                        <div className="flex flex-wrap gap-2 mt-2">
                            <strong>Resources:</strong> {renderResourceIcons(report.resources)}
                        </div>
                    </div>
                );

            default:
                return <p>Report type not recognized.</p>;
        }
    };

    const filteredReports = reports.filter(report => tabs[activeTab]?.includes(report.type));

    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center">
            <div className="bg-gray-800 border-2 border-gray-600 rounded-lg text-white w-full max-w-4xl h-3/4 flex flex-col">
                <div className="p-4 border-b border-gray-600 flex justify-between items-center">
                    <h2 className="text-xl font-bold">Reports</h2>
                    <button onClick={onClose} className="text-white text-2xl">&times;</button>
                </div>

                <div className="flex flex-grow overflow-hidden">
                    <div className="w-1/3 border-r border-gray-600 flex flex-col">
                        <div className="flex border-b border-gray-600">
                            {Object.keys(tabs).map(tabName => (
                                <button
                                    key={tabName}
                                    onClick={() => handleTabClick(tabName)}
                                    className={`flex-1 p-2 text-sm font-bold transition-colors ${
                                        activeTab === tabName
                                            ? 'bg-gray-700 text-white'
                                            : 'bg-gray-800 text-gray-400 hover:bg-gray-700'
                                    }`}
                                >
                                    {tabName}
                                </button>
                            ))}
                        </div>
                        
                        <ul className="overflow-y-auto">
                            {filteredReports.length > 0 ? (
                                filteredReports.map(report => (
                                    <li
                                        key={report.id}
                                        className={`p-3 cursor-pointer border-l-4 ${selectedReport && selectedReport.id === report.id ? 'bg-gray-700 border-yellow-400' : 'border-transparent'} ${!report.read ? 'font-bold' : ''} hover:bg-gray-700`}
                                        onClick={() => handleSelectReport(report)}
                                    >
                                        <div className="flex justify-between items-center">
                                            <span className={`truncate pr-2 ${getReportTitleColor(report)}`}>
                                                {getReportTitle(report)}
                                            </span>
                                            <button onClick={(e) => { e.stopPropagation(); handleDeleteReport(report.id); }} className="text-red-500 hover:text-red-400 text-xs flex-shrink-0">Delete</button>
                                        </div>
                                        <p className="text-xs text-gray-400">{report.timestamp?.toDate().toLocaleString()}</p>
                                    </li>
                                ))
                            ) : (
                                <p className="p-4 text-center text-gray-500">No reports in this category.</p>
                            )}
                        </ul>
                    </div>
                    
                    <div className="w-2/3 p-4 overflow-y-auto">
                        {selectedReport ? (
                            <div>
                                <h3 className="text-lg font-bold mb-2">{selectedReport.title || 'Report Details'}</h3>
                                <div className="space-y-2">
                                    {renderReportOutcome(selectedReport)}
                                </div>
                            </div>
                        ) : (
                            <div className="flex items-center justify-center h-full">
                                <p className="text-gray-400">Select a report to view its details.</p>
                            </div>
                        )}
                    </div>
                </div>
            </div>
        </div>
    );
};

export default ReportsView;
</file>

<file path="src/components/SelectionScreen.js">
// src/components/SelectionScreen.js
import React, { useState } from 'react';
import { useAuth } from '../contexts/AuthContext';
import { useGame } from '../contexts/GameContext';
import { doc, runTransaction, collection, query, where, limit, getDocs } from "firebase/firestore";
import { db } from '../firebase/config';
import Modal from './shared/Modal';
import buildingConfig from '../gameData/buildings.json';

const nationsByReligion = {
    'Greek': ['Athenian', 'Spartan', 'Corinthian'],
    'Roman': ['Julian', 'Cornelian', 'Fabian'],
    'Egyptian': ['Ptolemaic', 'Nubian', 'Bedouin']
};

const SelectionScreen = () => {
    const { currentUser, userProfile, loading: authLoading } = useAuth();
    const { worldState } = useGame();
    const [selectedReligion, setSelectedReligion] = useState(null);
    const [selectedNation, setSelectedNation] = useState(null);
    const [message, setMessage] = useState('');
    const [isSubmitting, setIsSubmitting] = useState(false);

    const placeNewCity = async (userId, userEmail, username, religion, nation) => {
        if (!worldState || !worldState.id) {
            setMessage("World data is not loaded correctly.");
            return;
        }

        const worldId = worldState.id;
        const citySlotsCollectionRef = collection(db, 'worlds', worldId, 'citySlots');
        
        let claimed = false;
        let attempts = 0;
        const maxAttempts = 5;
        const fetchLimit = 10; // Fetch more empty slots at once

        while (!claimed && attempts < maxAttempts) {
            attempts++;
            // Capture the current value of 'attempts' for this iteration
            const currentAttempt = attempts; 

            let availableSlots = [];
            try {
                // Fetch a batch of available slots
                const q = query(citySlotsCollectionRef, where("ownerId", "==", null), limit(fetchLimit));
                const querySnapshot = await getDocs(q);
                
                if (querySnapshot.empty) {
                    setMessage("This world is full! No empty city slots are available.");
                    return; // No slots found, exit
                }
                availableSlots = querySnapshot.docs;
            } catch (error) {
                console.error(`Error fetching empty slots (attempt ${currentAttempt}):`, error);
                setMessage(`Failed to find a location due to a technical issue. Retrying... (${currentAttempt}/${maxAttempts})`);
                await new Promise(resolve => setTimeout(resolve, 1000 * currentAttempt)); // Use currentAttempt here
                continue; // Try fetching again
            }

            // Try to claim one of the fetched slots
            for (const emptySlotDoc of availableSlots) {
                const emptySlotRef = emptySlotDoc.ref;
                try {
                    await runTransaction(db, async (transaction) => {
                        const slotSnap = await transaction.get(emptySlotRef);
                        if (!slotSnap.exists() || slotSnap.data().ownerId !== null) {
                            // This slot was taken, throw to try the next one in the list
                            throw new Error("Slot was already taken. Trying another...");
                        }

                        const newCityName = `${username}'s Landing`;
                        const faction = `${nation} (${religion})`;
                        transaction.update(emptySlotRef, {
                            ownerId: userId,
                            ownerEmail: userEmail,
                            ownerUsername: username,
                            cityName: newCityName,
                            ownerFaction: faction
                        });

                        const gameDocRef = doc(db, `users/${userId}/games`, worldId);
                        
                        const initialBuildings = {};
                        // All buildings from config start at level 0
                        for (const buildingId in buildingConfig) {
                            initialBuildings[buildingId] = { level: 0 };
                        }
                        // Set specific buildings to level 1
                        initialBuildings.senate = { level: 1 };
                        initialBuildings.farm = { level: 1 };
                        initialBuildings.warehouse = { level: 1 };
                        initialBuildings.timber_camp = { level: 1 };
                        initialBuildings.quarry = { level: 1 };
                        initialBuildings.silver_mine = { level: 1 };

                        const newGameState = {
                            cityName: newCityName,
                            playerInfo: { religion, nation },
                            resources: { wood: 500, stone: 500, silver: 100 },
                            buildings: initialBuildings,
                            units: {},
                            cave: { silver: 0 },
                            lastUpdated: Date.now(), 
                            cityLocation: {
                                mapId: worldId,
                                slotId: emptySlotDoc.id,
                                islandId: slotSnap.data().islandId
                            }
                        };
                        transaction.set(gameDocRef, newGameState);
                    });
                    claimed = true; // Successfully claimed a slot, exit outer loop
                    console.log("Transaction successful: City placed!");
                    return; // Exit the function after successful claim
                } catch (e) {
                    console.warn(`Failed to claim slot ${emptySlotDoc.id}: ${e.message}`);
                    // Continue to next slot in availableSlots array
                }
            }
            if (!claimed && currentAttempt < maxAttempts) { // Use currentAttempt here
                setMessage(`Failed to claim any of the found slots. Retrying to find new ones... (${currentAttempt}/${maxAttempts})`); // Use currentAttempt here
                await new Promise(resolve => setTimeout(resolve, 1000 * currentAttempt)); // Use currentAttempt here
            }
        }

        if (!claimed) {
            setMessage(`Could not place your city after ${maxAttempts} attempts. The world might be full or under heavy load. Please try again later.`);
        }
    };

    const handleConfirm = async () => {
        if (!selectedReligion || !selectedNation) {
            setMessage("Please select both a religion and a nation.");
            return;
        }
        if (authLoading || !userProfile || !userProfile.username) {
            setMessage("User profile is not loaded yet. Please wait a moment and try again.");
            return;
        }
        setIsSubmitting(true);
        setMessage("Founding your first city...");
        await placeNewCity(currentUser.uid, currentUser.email, userProfile.username, selectedReligion, selectedNation);
        setIsSubmitting(false);
    };

    const isButtonDisabled = !selectedReligion || !selectedNation || isSubmitting || authLoading;

    return (
        <div className="w-full min-h-screen flex items-center justify-center p-4">
             <Modal message={message} onClose={() => setMessage('')} />
            <div className="w-full max-w-2xl">
                <div className="bg-gray-800 p-8 rounded-lg shadow-2xl">
                    <h1 className="font-title text-4xl text-center text-gray-300 mb-6">Choose Your Path</h1>
                    <p className="text-center text-gray-400 mb-8">Your choice of Religion and Nation will define your journey in this world.</p>
                    <div className="mb-8">
                        <h2 className="font-title text-2xl text-gray-300 mb-4">Select Religion</h2>
                        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                            {Object.keys(nationsByReligion).map(religion => (
                                <div key={religion} onClick={() => { setSelectedReligion(religion); setSelectedNation(null); }} className={`selection-card p-4 rounded-lg text-center ${selectedReligion === religion ? 'selected' : ''}`}>
                                    <h3 className="text-xl font-bold">{religion}</h3>
                                </div>
                            ))}
                        </div>
                    </div>
                    {selectedReligion && (
                        <div className="mb-8">
                            <h2 className="font-title text-2xl text-gray-300 mb-4">Select Nation</h2>
                            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                                {nationsByReligion[selectedReligion].map(nation => (
                                    <div key={nation} onClick={() => setSelectedNation(nation)} className={`selection-card p-4 rounded-lg text-center ${selectedNation === nation ? 'selected' : ''}`}>
                                        <h3 className="text-xl font-bold">{nation}</h3>
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}
                    <button onClick={handleConfirm} disabled={isButtonDisabled} className="w-full btn btn-confirm font-bold py-3 rounded-lg disabled:btn-disabled">
                         {isSubmitting ? 'Founding City...' : (authLoading ? 'Loading Profile...' : 'Found My Empire')}
                    </button>
                </div>
            </div>
        </div>
    );
};

export default SelectionScreen;
</file>

<file path="src/components/SideInfoPanel.js">
// src/components/SideInfoPanel.js

import React from 'react';
import WorshipDisplay from './city/WorshipDisplay';
import TroopDisplay from './TroopDisplay';

const SideInfoPanel = ({ gameState, className, onOpenPowers }) => {
    if (!gameState) {
        return null;
    }

    return (
        <div className={className}>
            <WorshipDisplay
                godName={gameState.god}
                playerReligion={gameState.playerInfo.religion}
                worship={gameState.worship}
                buildings={gameState.buildings}
                onOpenPowers={onOpenPowers}
            />
            <TroopDisplay units={gameState.units || {}} />
        </div>
    );
};

export default SideInfoPanel;
</file>

<file path="src/components/Temple.js">
import React, { useState } from 'react';
import { useGame } from '../contexts/GameContext';
import godsConfig from '../gameData/gods.json';
import Modal from './shared/Modal';

const Temple = ({ onClose }) => {
    const { gameState, setGameState, playerNationality } = useGame();
    const [selectedGod, setSelectedGod] = useState(gameState.god || null);
    const [message, setMessage] = useState('');

    const handleSelectGod = (god) => {
        setSelectedGod(god);
    };

    const handleWorship = () => {
        if (!selectedGod) {
            setMessage("You must select a god to worship.");
            return;
        }
        const newGameState = { ...gameState, god: selectedGod };
        setGameState(newGameState);
        setMessage(`You are now worshipping ${selectedGod}.`);
        onClose();
    };

    const availableGods = godsConfig[playerNationality.toLowerCase()] || {};

    return (
        <Modal onClose={onClose} title="Temple">
            <div className="p-4 bg-gray-800 text-white rounded-lg max-w-2xl w-full">
                <h2 className="text-2xl font-bold text-yellow-400 mb-4 text-center">Choose a Deity to Worship</h2>
                {message && <p className="text-center text-green-400 mb-4">{message}</p>}
                
                <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                    {Object.keys(availableGods).map(godId => {
                        const god = availableGods[godId];
                        const isSelected = selectedGod === god.name;
                        return (
                            <div 
                                key={god.name}
                                className={`p-4 rounded-lg cursor-pointer transition-all border-2 ${isSelected ? 'border-yellow-400 bg-gray-700' : 'border-gray-600 bg-gray-900 hover:bg-gray-700'}`}
                                onClick={() => handleSelectGod(god.name)}
                            >
                                <h3 className="text-xl font-bold text-center text-yellow-500">{god.name}</h3>
                                <p className="text-sm text-gray-400 mt-2 text-center">{god.description}</p>
                                {/* Future additions for powers and units can go here */}
                            </div>
                        );
                    })}
                </div>

                <div className="mt-6 flex justify-center">
                    <button 
                        onClick={handleWorship}
                        className="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-6 rounded-lg transition-colors"
                    >
                        Worship {selectedGod || '...'}
                    </button>
                </div>
            </div>
        </Modal>
    );
};

export default Temple;
</file>

<file path="src/components/TroopDisplay.js">
// src/components/TroopDisplay.js
import React from 'react';
import unitConfig from '../gameData/units.json';

// Dynamically import all images from the images and images/buildings folder
const images = {};
const imageContexts = [
    require.context('../images', false, /\.(png|jpe?g|svg)$/),
    require.context('../images/buildings', false, /\.(png|jpe?g|svg)$/),
    require.context('../images/gods', false, /\.(png|jpe?g|svg)$/),
];

imageContexts.forEach(context => {
    context.keys().forEach((item) => {
        const key = item.replace('./', '');
        images[key] = context(item);
    });
});

const TroopDisplay = ({ units, title }) => {
    const landUnits = Object.entries(units || {}).filter(([id, count]) => count > 0 && unitConfig[id]?.type === 'land');
    const navalUnits = Object.entries(units || {}).filter(([id, count]) => count > 0 && unitConfig[id]?.type === 'naval');

    const renderUnit = ([unitId, count]) => {
        const unit = unitConfig[unitId];
        if (!unit || !unit.image) return null;

        const imageUrl = images[unit.image];
        if (!imageUrl) return null;

        return (
            <div key={unitId} className="troop-item" title={unit.name}>
                <img src={imageUrl} alt={unit.name} className="troop-image" />
                <span className="troop-count">{count}</span>
            </div>
        );
    };

    return (
        <div className="w-48 bg-gray-800 p-2 flex flex-col gap-2 border-2 border-gray-600 rounded-lg shadow-lg">
            {landUnits.length > 0 && (
                <div className="troop-section">
                    <h4 className="troop-section-header">{title || 'Barracks'}</h4>
                    <div className="troop-grid">
                        {landUnits.map(renderUnit)}
                    </div>
                </div>
            )}
            {navalUnits.length > 0 && (
                 <div className="troop-section">
                    <h4 className="troop-section-header">Harbor</h4>
                    <div className="troop-grid">
                        {navalUnits.map(renderUnit)}
                    </div>
                </div>
            )}
            {(landUnits.length === 0 && navalUnits.length === 0) && (
                 <p className="text-gray-400 text-xs text-center p-4">No troops in this city.</p>
            )}
        </div>
    );
};

export default TroopDisplay;
</file>

<file path="src/components/WorldSelectionScreen.js">
import React, { useState, useEffect, useCallback } from 'react';
import { collection, getDocs, doc, writeBatch, serverTimestamp, getDoc, deleteDoc, query, limit } from 'firebase/firestore';
import { signOut } from "firebase/auth";
import { db, auth } from '../firebase/config';
import { useAuth } from '../contexts/AuthContext';
import Modal from './shared/Modal';
import { generateIslands, generateCitySlots, generateFarmingVillages } from '../utils/worldGeneration';

const ConfirmationModal = ({ message, onConfirm, onCancel, confirmText = 'Confirm', cancelText = 'Cancel' }) => {
    if (!message) return null;

    return (
        <div
            className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-60"
            onClick={onCancel}
        >
            <div
                className="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-sm text-center border border-gray-600"
                onClick={e => e.stopPropagation()}
            >
                <p className="mb-6 text-lg text-gray-300">{message}</p>
                <div className="flex justify-center space-x-4">
                    <button
                        onClick={onCancel}
                        className="btn btn-primary px-6 py-2"
                    >
                        {cancelText}
                    </button>
                    <button
                        onClick={onConfirm}
                        className="btn btn-danger px-6 py-2"
                    >
                        {confirmText}
                    </button>
                </div>
            </div>
        </div>
    );
};

const WorldSelectionScreen = ({ onWorldSelected }) => {
    const { currentUser, userProfile } = useAuth();
    const [worlds, setWorlds] = useState([]);
    const [userGames, setUserGames] = useState([]);
    const [loading, setLoading] = useState(true);
    const [message, setMessage] = useState('');
    const [newWorldName, setNewWorldName] = useState('');
    const [isCreating, setIsCreating] = useState(false);
    const [worldToDelete, setWorldToDelete] = useState(null);

    const fetchWorldsAndGames = useCallback(async () => {
        setLoading(true);
        try {
            const worldsCollectionRef = collection(db, 'worlds');
            const worldsSnapshot = await getDocs(worldsCollectionRef);
            const worldsList = worldsSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            setWorlds(worldsList);

            if (currentUser) {
                const gamesCollectionRef = collection(db, `users/${currentUser.uid}/games`);
                const gamesSnapshot = await getDocs(gamesCollectionRef);
                const gamesList = gamesSnapshot.docs.map(doc => doc.id);
                setUserGames(gamesList);
            }
        } catch (error) {
            console.error("Error fetching worlds:", error);
            setMessage('Could not load world list.');
        }
        setLoading(false);
    }, [currentUser]);

    useEffect(() => {
        fetchWorldsAndGames();
    }, [fetchWorldsAndGames]);

    const handleCreateWorld = async (e) => {
        e.preventDefault();
        if (!newWorldName.trim()) {
            setMessage('Please enter a world name.');
            return;
        }

        setIsCreating(true);
        setMessage('Creating a new world, this may take a moment...');

        try {
            const worldId = newWorldName.trim().toLowerCase().replace(/\s+/g, '-');
            const worldDocRef = doc(db, 'worlds', worldId);

            const existingWorld = await getDoc(worldDocRef);
            if (existingWorld.exists()) {
                setMessage(`A world with the ID '${worldId}' already exists. Please choose a different name.`);
                setIsCreating(false);
                return;
            }

            const worldWidth = 50;
            const worldHeight = 50;
            const islandCount = Math.floor((worldWidth * worldHeight) / 250);

            // Generate all world data
            const islands = generateIslands(worldWidth, worldHeight, islandCount);
            const citySlots = generateCitySlots(islands, worldWidth, worldHeight);
            const villages = generateFarmingVillages(islands, citySlots, worldWidth, worldHeight);

            const worldData = {
                name: newWorldName.trim(),
                islands,
                width: worldWidth,
                height: worldHeight,
                createdAt: serverTimestamp()
            };

            await writeBatch(db).set(worldDocRef, worldData).commit();

            const batchSize = 400;

            // Batch write city slots
            const citySlotsCollectionRef = collection(db, 'worlds', worldId, 'citySlots');
            const slotEntries = Object.entries(citySlots);
            for (let i = 0; i < slotEntries.length; i += batchSize) {
                const batch = writeBatch(db);
                const chunk = slotEntries.slice(i, i + batchSize);
                setMessage(`Creating world... writing city data ${i + chunk.length}/${slotEntries.length}`);
                for (const [slotId, slotData] of chunk) {
                    const slotDocRef = doc(citySlotsCollectionRef, slotId);
                    batch.set(slotDocRef, slotData);
                }
                await batch.commit();
            }

            // Batch write villages
            const villagesCollectionRef = collection(db, 'worlds', worldId, 'villages');
            const villageEntries = Object.entries(villages);
            for (let i = 0; i < villageEntries.length; i += batchSize) {
                const batch = writeBatch(db);
                const chunk = villageEntries.slice(i, i + batchSize);
                setMessage(`Creating world... writing village data ${i + chunk.length}/${villageEntries.length}`);
                for (const [villageId, villageData] of chunk) {
                    const villageDocRef = doc(villagesCollectionRef, villageId);
                    batch.set(villageDocRef, { ...villageData, lastCollected: serverTimestamp() });
                }
                await batch.commit();
            }

            setMessage('World created successfully!');
            onWorldSelected(worldId);

        } catch (error) {
            console.error("Error creating world:", error);
            setMessage(`Failed to create world: ${error.message}`);
        }
        setIsCreating(false);
        setNewWorldName('');
    };

    const handleDeleteWorld = async (worldId, worldName) => {
        setMessage(`Deleting world "${worldName}"... This may take a moment.`);
        try {
            const worldDocRef = doc(db, 'worlds', worldId);
            
            const deleteCollectionBatch = async (collectionRef) => {
                const q = query(collectionRef, limit(500));
                const snapshot = await getDocs(q);
                if (snapshot.size === 0) {
                    return 0;
                }
                const batch = writeBatch(db);
                snapshot.docs.forEach(doc => batch.delete(doc.ref));
                await batch.commit();
                return snapshot.size;
            };

            // Delete subcollections
            let deletedCount;
            const citySlotsRef = collection(db, 'worlds', worldId, 'citySlots');
            while ((deletedCount = await deleteCollectionBatch(citySlotsRef)) > 0) {
                console.log(`Deleted ${deletedCount} city slots...`);
            }
            
            const villagesRef = collection(db, 'worlds', worldId, 'villages');
            while ((deletedCount = await deleteCollectionBatch(villagesRef)) > 0) {
                console.log(`Deleted ${deletedCount} villages...`);
            }
            
            // Delete the main world doc
            await deleteDoc(worldDocRef);

            setMessage(`World "${worldName}" has been deleted successfully.`);
            fetchWorldsAndGames();
        } catch (error) {
            console.error("Error deleting world:", error);
            setMessage(`Failed to delete world: ${error.message}`);
        } finally {
            setWorldToDelete(null);
        }
    };

    if (loading) {
        return <div className="text-white text-center p-10">Loading Worlds...</div>;
    }

    const availableWorlds = worlds.filter(world => !userGames.includes(world.id));
    const joinedWorlds = worlds.filter(world => userGames.includes(world.id));

    return (
        <div className="w-full min-h-screen flex items-center justify-center p-4">
            <Modal message={message} onClose={() => setMessage('')} />
            {worldToDelete && (
                <ConfirmationModal
                    message={`Are you sure you want to permanently delete the world "${worldToDelete.name}"? This will delete all cities and progress within it.`}
                    onConfirm={() => handleDeleteWorld(worldToDelete.id, worldToDelete.name)}
                    onCancel={() => setWorldToDelete(null)}
                    confirmText="Delete World"
                />
            )}
            <div className="w-full max-w-4xl">
                <div className="bg-gray-800 p-8 rounded-lg shadow-2xl relative">
                    <button
                        onClick={() => signOut(auth)}
                        className="absolute top-4 right-4 text-sm text-red-400 hover:text-red-300 px-3 py-1 rounded"
                    >
                        Logout
                    </button>
                    <h1 className="font-title text-4xl text-center text-gray-300 mb-8">Select a World</h1>

                    <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
                        <div>
                            <h2 className="font-title text-2xl text-gray-300 mb-4">Your Worlds</h2>
                            {joinedWorlds.length > 0 ? (
                                joinedWorlds.map(world => (
                                    <div key={world.id} className="selection-card p-4 rounded-lg text-center mb-2 flex justify-between items-center">
                                        <h3 className="text-xl font-bold flex-grow text-left cursor-pointer" onClick={() => onWorldSelected(world.id)}>{world.name}</h3>
                                        {userProfile?.is_admin && (
                                            <button
                                                onClick={() => setWorldToDelete(world)}
                                                className="btn btn-danger px-3 py-1 text-xs rounded"
                                            >
                                                Delete
                                            </button>
                                        )}
                                    </div>
                                ))
                            ) : (
                                <p className="text-gray-400">You have not joined any worlds yet.</p>
                            )}
                        </div>

                        <div>
                            <h2 className="font-title text-2xl text-gray-300 mb-4">Join a New World</h2>
                            {availableWorlds.length > 0 ? (
                                availableWorlds.map(world => (
                                    <div key={world.id} className="selection-card p-4 rounded-lg text-center mb-2 flex justify-between items-center">
                                        <h3 className="text-xl font-bold flex-grow text-left cursor-pointer" onClick={() => onWorldSelected(world.id)}>{world.name}</h3>
                                        {userProfile?.is_admin && (
                                            <button
                                                onClick={() => setWorldToDelete(world)}
                                                className="btn btn-danger px-3 py-1 text-xs rounded"
                                            >
                                                Delete
                                            </button>
                                        )}
                                    </div>
                                ))
                            ) : (
                                <p className="text-gray-400">No new worlds are available to join.</p>
                            )}
                        </div>
                    </div>

                    {userProfile?.is_admin && (
                        <div className="mt-12 border-t border-gray-700 pt-8">
                            <h2 className="font-title text-2xl text-gray-300 mb-4">Admin Panel</h2>
                            <form onSubmit={handleCreateWorld} className="flex flex-col sm:flex-row gap-4 mb-4">
                                <input
                                    type="text"
                                    value={newWorldName}
                                    onChange={(e) => setNewWorldName(e.target.value)}
                                    placeholder="Enter new world name"
                                    className="flex-grow bg-gray-700 border border-gray-600 rounded-lg px-4 py-2 text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                                    disabled={isCreating}
                                />
                                <button type="submit" className="btn btn-confirm px-6 py-2" disabled={isCreating}>
                                    {isCreating ? 'Creating...' : 'Create New World'}
                                </button>
                            </form>
                        </div>
                    )}
                </div>
            </div>
        </div>
    );
};

export default WorldSelectionScreen;
</file>

<file path="src/contexts/AuthContext.js">
import React, { useState, useEffect, createContext, useContext } from 'react';
import { onAuthStateChanged } from "firebase/auth";
import { doc, onSnapshot, updateDoc } from "firebase/firestore";
import { auth, db } from '../firebase/config';

const AuthContext = createContext();

export const useAuth = () => useContext(AuthContext);

export const AuthProvider = ({ children }) => {
    const [currentUser, setCurrentUser] = useState(null);
    const [userProfile, setUserProfile] = useState(null);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        let unsubscribeProfile = () => {};

        const unsubscribeAuth = onAuthStateChanged(auth, user => {
            setCurrentUser(user);
            unsubscribeProfile(); 

            if (user) {
                setLoading(true);
                const userDocRef = doc(db, "users", user.uid);
                unsubscribeProfile = onSnapshot(userDocRef, (docSnap) => {
                    if (docSnap.exists()) {
                        setUserProfile(docSnap.data());
                    } else {
                        setUserProfile(null);
                    }
                    setLoading(false);
                }, (error) => {
                    console.error("Error fetching user profile:", error);
                    setUserProfile(null);
                    setLoading(false);
                });
            } else {
                setUserProfile(null);
                setLoading(false);
            }
        });

        return () => {
            unsubscribeAuth();
            unsubscribeProfile();
        };
    }, []);

    const updateUserProfile = async (profileData) => {
        if (currentUser) {
            const userDocRef = doc(db, "users", currentUser.uid);
            await updateDoc(userDocRef, profileData);
        }
    };

    const value = { currentUser, userProfile, loading, updateUserProfile };

    return <AuthContext.Provider value={value}>{!loading && children}</AuthContext.Provider>;
};
</file>

<file path="src/contexts/GameContext.js">
// src/contexts/GameContext.js

import React, { useState, useEffect, createContext, useContext } from 'react';
import { doc, onSnapshot,deleteDoc, collection, runTransaction } from "firebase/firestore";
import { db } from '../firebase/config';
import { useAuth } from './AuthContext';

const GameContext = createContext();

export const useGame = () => useContext(GameContext);

export const GameProvider = ({ children, worldId }) => {
    const { currentUser, userProfile } = useAuth();
    const [gameState, setGameState] = useState(null);
    const [worldState, setWorldState] = useState(null);
    const [playerCity, setPlayerCity] = useState(null);
    const [playerHasChosenFaction, setPlayerHasChosenFaction] = useState(false);
    const [loading, setLoading] = useState(true);
    const [playerGod, setPlayerGod] = useState(null);
    const [playerAlliance, setPlayerAlliance] = useState(null);
    const [conqueredVillages, setConqueredVillages] = useState({});
    const [gameSettings, setGameSettings] = useState({
        animations: true,
        confirmActions: true,
        showGrid: true,
        showVisuals: true,
    });

    const createAlliance = async (name, tag) => {
        if (!currentUser || !worldId || !userProfile) return;

        const allianceId = tag.toUpperCase();
        const allianceDocRef = doc(db, 'worlds', worldId, 'alliances', allianceId);
        const gameDocRef = doc(db, `users/${currentUser.uid}/games`, worldId);

        try {
            await runTransaction(db, async (transaction) => {
                const allianceDoc = await transaction.get(allianceDocRef);
                if (allianceDoc.exists()) {
                    throw new Error("An alliance with this tag already exists.");
                }

                const gameDoc = await transaction.get(gameDocRef);
                if (!gameDoc.exists()) {
                    throw new Error("Player game data not found.");
                }

                const playerData = gameDoc.data();
                if (playerData.alliance) {
                    throw new Error("You are already in an alliance.");
                }

                const newAlliance = {
                    name,
                    tag: allianceId,
                    leader: { uid: currentUser.uid, username: userProfile.username },
                    members: [{ uid: currentUser.uid, username: userProfile.username, rank: 'leader' }],
                    research: {},
                    diplomacy: { allies: [], enemies: [] }
                };

                transaction.set(allianceDocRef, newAlliance);
                transaction.update(gameDocRef, { alliance: allianceId });
            });

            console.log("Alliance created successfully");
        } catch (error) {
            console.error("Error creating alliance: ", error);
            alert("Failed to create alliance: " + error.message);
        }
    };
    
    const donateToAllianceResearch = async (researchId, donation) => {
        if (!playerAlliance) {
            alert("You are not in an alliance.");
            return;
        }

        const gameDocRef = doc(db, `users/${currentUser.uid}/games`, worldId);
        const allianceDocRef = doc(db, 'worlds', worldId, 'alliances', playerAlliance.id);

        try {
            await runTransaction(db, async (transaction) => {
                const gameDoc = await transaction.get(gameDocRef);
                const allianceDoc = await transaction.get(allianceDocRef);

                if (!gameDoc.exists() || !allianceDoc.exists()) {
                    throw new Error("Game or Alliance data not found.");
                }

                const playerData = gameDoc.data();
                const allianceData = allianceDoc.data();

                // Check if player has enough resources
                for (const resource in donation) {
                    if ((playerData.resources[resource] || 0) < donation[resource]) {
                        throw new Error(`Not enough ${resource}.`);
                    }
                }
                
                const research = allianceData.research[researchId] || { level: 0, progress: { wood: 0, stone: 0, silver: 0 }};

                const newPlayerResources = { ...playerData.resources };
                const newResearchProgress = { ...research.progress };

                for (const resource in donation) {
                    newPlayerResources[resource] -= donation[resource];
                    newResearchProgress[resource] = (newResearchProgress[resource] || 0) + donation[resource];
                }

                transaction.update(gameDocRef, { resources: newPlayerResources });
                transaction.update(allianceDocRef, { [`research.${researchId}.progress`]: newResearchProgress });
            });
            alert("Donation successful!");
        } catch (error) {
            alert(`Donation failed: ${error.message}`);
            console.error("Donation error:", error);
        }
    };


    useEffect(() => {
        if (!currentUser || !worldId) {
            setLoading(false);
            return;
        }

        setLoading(true);
        let playerStateLoaded = false;
        let worldMetaLoaded = false;
        let playerCityLoaded = false;
        let cityListenerUnsubscribe = () => {};
        let conqueredVillagesUnsubscribe = () => {};
        let allianceListenerUnsubscribe = () => {};


        const checkAllLoaded = () => {
            if (playerStateLoaded && worldMetaLoaded && playerCityLoaded) {
                setLoading(false);
            }
        };

        const worldDocRef = doc(db, 'worlds', worldId);
        const unsubscribeWorldMeta = onSnapshot(worldDocRef, (docSnap) => {
            if (docSnap.exists()) {
                setWorldState({ id: docSnap.id, ...docSnap.data() });
            } else {
                setWorldState(null);
            }
            worldMetaLoaded = true;
            checkAllLoaded();
        }, (error) => {
            console.error("Error fetching world metadata:", error);
            worldMetaLoaded = true;
            checkAllLoaded();
        });
        
        const gameDocRef = doc(db, `users/${currentUser.uid}/games`, worldId);
        const unsubscribePlayer = onSnapshot(gameDocRef, async (docSnap) => {
            cityListenerUnsubscribe();
            conqueredVillagesUnsubscribe();
            allianceListenerUnsubscribe();

            if (docSnap.exists() && docSnap.data().playerInfo) {
                const gameData = docSnap.data();
                setGameState(gameData);
                setPlayerHasChosenFaction(true);
                setPlayerGod(gameData.god || null);

                if (gameData.alliance) {
                    const allianceDocRef = doc(db, 'worlds', worldId, 'alliances', gameData.alliance);
                    allianceListenerUnsubscribe = onSnapshot(allianceDocRef, (allianceSnap) => {
                        if(allianceSnap.exists()) {
                            setPlayerAlliance({id: allianceSnap.id, ...allianceSnap.data()});
                        } else {
                            setPlayerAlliance(null);
                        }
                    });
                } else {
                    setPlayerAlliance(null);
                }

                const citySlotId = gameData.cityLocation?.slotId;

                const conqueredVillagesRef = collection(db, `users/${currentUser.uid}/games`, worldId, 'conqueredVillages');
                conqueredVillagesUnsubscribe = onSnapshot(conqueredVillagesRef, (snapshot) => {
                    const villagesData = {};
                    snapshot.docs.forEach(doc => {
                        villagesData[doc.id] = { id: doc.id, ...doc.data() };
                    });
                    setConqueredVillages(villagesData);
                });

                if (citySlotId) {
                    const cityDocRef = doc(db, 'worlds', worldId, 'citySlots', citySlotId);
                    cityListenerUnsubscribe = onSnapshot(cityDocRef, (cityDataSnap) => {
                        if (cityDataSnap.exists()) {
                            setPlayerCity({ id: cityDataSnap.id, ...cityDataSnap.data() });
                        }
                        playerCityLoaded = true;
                        checkAllLoaded();
                    });
                } else {
                     console.warn("Malformed game data detected. Deleting and forcing re-selection.");
                     await deleteDoc(gameDocRef);
                }
            } else {
                setGameState(null);
                setPlayerCity(null);
                setPlayerHasChosenFaction(false);
                setPlayerGod(null);
                setPlayerAlliance(null);
                setConqueredVillages({});
                playerCityLoaded = true; 
            }
            playerStateLoaded = true;
            checkAllLoaded();
        }, (error) => {
            console.error("Error fetching player game state:", error);
            playerStateLoaded = true;
            playerCityLoaded = true;
            checkAllLoaded();
        });

        return () => {
            unsubscribePlayer();
            unsubscribeWorldMeta();
            cityListenerUnsubscribe();
            conqueredVillagesUnsubscribe();
            allianceListenerUnsubscribe();
        };
    }, [currentUser, worldId]);

    const value = { 
        gameState, setGameState, 
        worldState, 
        playerCity, 
        playerHasChosenFaction, 
        loading, 
        worldId, 
        playerGod, setPlayerGod, 
        playerAlliance, setPlayerAlliance, 
        conqueredVillages, 
        donateToAllianceResearch, 
        createAlliance,
        gameSettings, setGameSettings 
    };
    return <GameContext.Provider value={value}>{children}</GameContext.Provider>;
};
</file>

<file path="src/firebase/config.js">
import { initializeApp } from "firebase/app";
import { getAuth } from "firebase/auth";
import { getFirestore } from "firebase/firestore";
import { getFunctions } from "firebase/functions";

// Your web app's Firebase configuration is now loaded from environment variables
const firebaseConfig = {
  apiKey: process.env.REACT_APP_FIREBASE_API_KEY,
  authDomain: process.env.REACT_APP_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.REACT_APP_FIREBASE_PROJECT_ID,
  storageBucket: process.env.REACT_APP_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.REACT_APP_FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.REACT_APP_FIREBASE_APP_ID,
  measurementId: process.env.REACT_APP_FIREBASE_MEASUREMENT_ID
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);
export const auth = getAuth(app);
export const db = getFirestore(app);
export const functions = getFunctions(app);
export const appId = 'default-grepolis-clone';
</file>

<file path="src/gameData/allianceResearch.json">
{
    "master_of_arms": {
        "name": "Master of Arms",
        "description": "Increases the attack power of all alliance members' troops.",
        "maxLevel": 10,
        "baseCost": { "wood": 100000, "stone": 100000, "silver": 50000 },
        "costMultiplier": 1.5,
        "effect": { "type": "attack_boost", "value": 0.01 }
    },
    "fortification_experts": {
        "name": "Fortification Experts",
        "description": "Increases the defensive power of all alliance members' troops.",
        "maxLevel": 10,
        "baseCost": { "wood": 100000, "stone": 150000, "silver": 25000 },
        "costMultiplier": 1.5,
        "effect": { "type": "defense_boost", "value": 0.01 }
    },
    "logistics_specialists": {
        "name": "Logistics Specialists",
        "description": "Increases the travel speed of all alliance members' troops.",
        "maxLevel": 5,
        "baseCost": { "wood": 120000, "stone": 80000, "silver": 80000 },
        "costMultiplier": 1.8,
        "effect": { "type": "speed_boost", "value": 0.02 }
    },
    "expanded_charter": {
        "name": "Expanded Charter",
        "description": "Increases the maximum number of members in the alliance.",
        "maxLevel": 5,
        "baseCost": { "wood": 250000, "stone": 250000, "silver": 100000 },
        "costMultiplier": 2,
        "effect": { "type": "max_members", "value": 5 }
    }
}
</file>

<file path="src/gameData/BuildingLayout.json">
[
  { "id": "city_wall", "name": "City Wall", "position": { "x": 10, "y": 1240 } },
  { "id": "senate", "name": "Senate", "position": { "x": 925, "y": 750 } },
  { "id": "timber_camp", "name": "Lumber Mill", "position": { "x": 700, "y": 850 } },
  { "id": "quarry", "name": "Stone Quarry", "position": { "x": 1150, "y": 850 } },
  { "id": "barracks", "name": "Barracks", "position": { "x": 500, "y": 950 } },
  { "id": "silver_mine", "name": "Silver Mine", "position": { "x": 925, "y": 950 } },
  { "id": "market", "name": "Market", "position": { "x": 1350, "y": 950 } },
  { "id": "warehouse", "name": "Warehouse", "position": { "x": 700, "y": 1050 } },
  { "id": "farm", "name": "Farm", "position": { "x": 1150, "y": 1050 } },
  { "id": "temple", "name": "Temple", "position": { "x": 925, "y": 1100 } },
  { "id": "cave", "name": "Cave", "position": { "x": 500, "y": 1100 } },
  { "id": "academy", "name": "Academy", "position": { "x": 1350, "y": 1100 } },
  { "id": "hospital", "name": "Hospital", "position": { "x": 700, "y": 1150 } },
  { "id": "shipyard", "name": "Shipyard", "position": { "x": 925, "y": 1350 } }
]
</file>

<file path="src/gameData/buildings.json">
{
  "senate": {
    "name": "Senate",
    "description": "Manage your city and view building levels.",
    "baseCost": { "wood": 200, "stone": 250, "silver": 150, "population": 10, "time": 120 },
    "image": "senate.png"
  },
  "timber_camp": {
    "name": "Timber Camp",
    "description": "Generates wood for your empire.",
    "baseCost": { "wood": 60, "stone": 80, "silver": 20, "population": 5, "time": 60 },
    "image": "lumber_mill.png"
  },
  "quarry": {
    "name": "Quarry",
    "description": "Mines stone for construction.",
    "baseCost": { "wood": 80, "stone": 60, "silver": 20, "population": 5, "time": 60 },
    "image": "stone_quarry.png"
  },
  "silver_mine": {
    "name": "Silver Mine",
    "description": "Mints silver coins.",
    "baseCost": { "wood": 100, "stone": 100, "silver": 50, "population": 8, "time": 90 },
    "image": "silver_mines.png"
  },
  "warehouse": {
    "name": "Warehouse",
    "description": "Stores your precious resources.",
    "baseCost": { "wood": 150, "stone": 200, "silver": 0, "population": 5, "time": 80 },
    "image": "warehouse.png"
  },
  "barracks": {
    "name": "Barracks",
    "description": "Train land units to attack and defend.",
    "baseCost": { "wood": 120, "stone": 100, "silver": 80, "population": 10, "time": 150 },
    "image": "barracks.png"
  },
  "shipyard": {
    "name": "Shipyard",
    "description": "Build ships for naval warfare.",
    "baseCost": { "wood": 150, "stone": 100, "silver": 100, "population": 10, "time": 180 },
    "image": "shipyard.png"
  },
  "academy": {
    "name": "Academy",
    "description": "Research new technologies and units.",
    "baseCost": { "wood": 220, "stone": 220, "silver": 180, "population": 15, "time": 240 },
    "image": "academy.png"
  },
  "city_wall": {
    "name": "City Wall",
    "description": "Increases the defense of your city.",
    "baseCost": { "wood": 50, "stone": 250, "silver": 100, "population": 5, "time": 100 },
    "image": "city_wall.png"
  },
  "cave": {
    "name": "Cave",
    "description": "Train spies and store silver safely from raids.",
    "baseCost": { "wood": 100, "stone": 100, "silver": 20, "population": 5, "time": 120 },
    "image": "cavepng.png"
  },
  "market": {
    "name": "Market",
    "description": "Trade resources with other players.",
    "baseCost": { "wood": 180, "stone": 180, "silver": 180, "population": 10, "time": 200 },
    "image": "market.png"
  },
  "temple": {
    "name": "Temple",
    "description": "Worship the gods to gain their favor.",
    "baseCost": { "wood": 250, "stone": 250, "silver": 250, "population": 10, "time": 300 },
    "image": "temple.png"
  },
  "farm": {
    "name": "Farm",
    "description": "Increases your city's population capacity.",
    "baseCost": { "wood": 100, "stone": 50, "silver": 30, "population": 0, "time": 70 },
    "image": "farm.png"
  },
  "hospital": {
    "name": "Hospital",
    "description": "Heal your wounded troops after battle.",
    "baseCost": { "wood": 200, "stone": 150, "silver": 100, "population": 8, "time": 180 },
    "image": "hospital.png"
  }
}
</file>

<file path="src/gameData/gods.json">
{
    "greek": {
        "Zeus": {
            "name": "Zeus",
            "description": "King of the Gods, master of lightning and the sky.",
            "powers": [
                {
                    "name": "Divine Sign",
                    "description": "Instantly send 250 silver to a target city.",
                    "favorCost": 50,
                    "effect": { "type": "add_resources", "resource": "silver", "amount": 250, "target": "both" }
                },
                {
                    "name": "Lightning Bolt",
                    "description": "Destroy a random enemy building level in a target city.",
                    "favorCost": 200,
                    "effect": { "type": "damage_building", "amount": 1, "target": "other" }
                }
            ],
            "mythical_units": ["Minotaur", "Manticore"],
            "image": "zeus.png"
        },
        "Hera": {
            "name": "Hera",
            "description": "Queen of the Gods, protector of marriage and family.",
            "powers": [
                {
                    "name": "Wedding",
                    "description": "Instantly send 250 wood to a target city.",
                    "favorCost": 50,
                    "effect": { "type": "add_resources", "resource": "wood", "amount": 250, "target": "both" }
                },
                {
                    "name": "Satisfaction",
                    "description": "Increase resource production by 10% for 1 hour in a target city.",
                    "favorCost": 150,
                    "effect": { "type": "resource_boost", "multiplier": 1.1, "duration": 3600, "target": "both" }
                }
            ],
            "mythical_units": ["Harpy", "Medusa"],
            "image": "hera.png"
        },
        "Athena": {
            "name": "Athena",
            "description": "Goddess of wisdom, courage, and strategic warfare.",
            "powers": [
                {
                    "name": "City Protection",
                    "description": "Your city cannot be attacked for 1 hour.",
                    "favorCost": 300,
                    "effect": { "type": "protection", "duration": 3600, "target": "self" }
                },
                {
                    "name": "Wisdom",
                    "description": "All your troops gain +10% attack for their next battle.",
                    "favorCost": 180,
                    "effect": { "type": "attack_boost", "multiplier": 1.1, "target": "self" }
                }
            ],
            "mythical_units": ["Centaur", "Pegasus"],
            "image": "athena.png"
        }
    },
    "roman": {
        "Jupiter": {
            "name": "Jupiter",
            "description": "The Roman equivalent of Zeus, god of the sky and thunder.",
            "powers": [
                {
                    "name": "Divine Sign",
                    "description": "Instantly send 250 silver to a target city.",
                    "favorCost": 50,
                    "effect": { "type": "add_resources", "resource": "silver", "amount": 250, "target": "both" }
                },
                {
                    "name": "Lightning Bolt",
                    "description": "Destroy a random enemy building level in a target city.",
                    "favorCost": 200,
                    "effect": { "type": "damage_building", "amount": 1, "target": "other" }
                }
            ],
            "mythical_units": ["Minotaur", "Manticore"],
            "image": "jupiter.png"
        },
        "Juno": {
            "name": "Juno",
            "description": "The Roman equivalent of Hera, protector of the Roman people.",
            "powers": [
                {
                    "name": "Wedding",
                    "description": "Instantly send 250 wood to a target city.",
                    "favorCost": 50,
                    "effect": { "type": "add_resources", "resource": "wood", "amount": 250, "target": "both" }
                },
                {
                    "name": "Satisfaction",
                    "description": "Increase resource production by 10% for 1 hour in a target city.",
                    "favorCost": 150,
                    "effect": { "type": "resource_boost", "multiplier": 1.1, "duration": 3600, "target": "both" }
                }
            ],
            "mythical_units": ["Harpy", "Medusa"],
            "image": "juno.png"
        },
        "Minerva": {
            "name": "Minerva",
            "description": "The Roman equivalent of Athena, goddess of wisdom and strategic warfare.",
            "powers": [
                {
                    "name": "City Protection",
                    "description": "Your city cannot be attacked for 1 hour.",
                    "favorCost": 300,
                    "effect": { "type": "protection", "duration": 3600, "target": "self" }
                },
                {
                    "name": "Wisdom",
                    "description": "All your troops gain +10% attack for their next battle.",
                    "favorCost": 180,
                    "effect": { "type": "attack_boost", "multiplier": 1.1, "target": "self" }
                }
            ],
            "mythical_units": ["Centaur", "Pegasus"],
            "image": "minerva.png"
        }
    },
    "egyptian": {
        "Anubis": {
            "name": "Anubis",
            "description": "God of the dead and the embalming process, protector of tombs.",
            "powers": [
                {
                    "name": "Plague of Locusts",
                    "description": "Reduce a target city's resource production by 20% for 1 hour.",
                    "favorCost": 250,
                    "effect": { "type": "production_debuff", "multiplier": 0.8, "duration": 3600, "target": "other" }
                },
                {
                    "name": "Underworld's Favor",
                    "description": "Revive 10% of your troops lost in the next battle.",
                    "favorCost": 350,
                    "effect": { "type": "revive_troops", "percentage": 0.1, "target": "self" }
                }
            ],
            "mythical_units": ["Sphinx", "Scarab"],
            "image": "anubis.png"
        },
        "Horus": {
            "name": "Horus",
            "description": "God of the sky, kingship, and order.",
            "powers": [
                {
                    "name": "Favorable Winds",
                    "description": "Your naval units travel 20% faster for 1 hour.",
                    "favorCost": 120,
                    "effect": { "type": "naval_speed_boost", "multiplier": 1.2, "duration": 3600, "target": "self" }
                },
                {
                    "name": "Vision of the Sky",
                    "description": "Reveal the number of incoming attacks on your city.",
                    "favorCost": 80,
                    "effect": { "type": "reveal_attacks", "target": "self" }
                }
            ],
            "mythical_units": ["Griffin", "Phoenix"],
            "image": "horus.png"
        },
        "Osiris": {
            "name": "Osiris",
            "description": "God of the afterlife, the underworld, and rebirth.",
            "powers": [
                {
                    "name": "Resurrection",
                    "description": "Instantly revive 5 of your most powerful deceased units.",
                    "favorCost": 400,
                    "effect": { "type": "revive_specific_troops", "amount": 5, "target": "self" }
                },
                {
                    "name": "Bountiful Harvest",
                    "description": "Instantly send 250 wood and 250 stone to a target city.",
                    "favorCost": 100,
                    "effect": { "type": "add_multiple_resources", "resources": { "wood": 250, "stone": 250 }, "target": "both" }
                }
            ],
            "mythical_units": ["Mummy", "Serpopard"],
            "image": "osiris.png"
        }
    }
}
</file>

<file path="src/gameData/research.json">
{
  "logistics": {
    "name": "Logistics",
    "description": "Increases the speed of your land units by 10%.",
    "cost": { "wood": 1000, "stone": 1200, "silver": 800, "time": 1800 },
    "requirements": { "academy": 1 },
    "effect": { "type": "unit_speed_land", "value": 1.1 }
  },
  "architecture": {
    "name": "Architecture",
    "description": "Reduces the construction time of buildings by 10%.",
    "cost": { "wood": 1500, "stone": 2000, "silver": 1000, "time": 3600 },
    "requirements": { "academy": 2 },
    "effect": { "type": "build_time", "value": 0.9 }
  },
  "ballistics": {
    "name": "Ballistics",
    "description": "Increases the attack power of archers and slingers by 10%.",
    "cost": { "wood": 2000, "stone": 1500, "silver": 2500, "time": 5400 },
    "requirements": { "academy": 3, "research": "logistics" },
    "effect": { "type": "unit_attack_ranged", "value": 1.1 }
  },
  "shipwright": {
    "name": "Shipwright",
    "description": "Increases the speed of your naval units by 10%.",
    "cost": { "wood": 2500, "stone": 1800, "silver": 2200, "time": 7200 },
    "requirements": { "academy": 4 },
    "effect": { "type": "unit_speed_naval", "value": 1.1 }
  },
  "phalanx": {
    "name": "Phalanx",
    "description": "Increases the defensive strength of hoplites by 15%.",
    "cost": { "wood": 3000, "stone": 4000, "silver": 3500, "time": 10800 },
    "requirements": { "academy": 5, "research": "architecture" },
    "effect": { "type": "unit_defense_hoplite", "value": 1.15 }
  }
}
</file>

<file path="src/gameData/units.json">
{
  "swordsman": {
    "name": "Swordsman",
    "description": "A basic melee unit, effective in close combat.",
    "cost": {
      "wood": 50,
      "stone": 30,
      "silver": 20,
      "population": 1,
      "time": 30
    },
    "attack": 10,
    "defense": 15,
    "speed": 5,
    "type": "land",
    "counters": ["archer"],
    "image": "swordman.png"
  },
  "archer": {
    "name": "Archer",
    "description": "A ranged unit that can attack from a distance.",
    "cost": {
      "wood": 30,
      "stone": 40,
      "silver": 35,
      "population": 1,
      "time": 45
    },
    "attack": 12,
    "defense": 8,
    "speed": 6,
    "type": "land",
    "counters": ["swordsman"],
    "image": "archers.png"
  },
  "slinger": {
    "name": "Slinger",
    "description": "Light ranged unit, good against unarmored foes.",
    "cost": {
      "wood": 25,
      "stone": 20,
      "silver": 15,
      "population": 1,
      "time": 25
    },
    "attack": 8,
    "defense": 10,
    "speed": 7,
    "type": "land",
    "counters": ["cavalry"],
    "image": "slinger.png"
  },
  "hoplite": {
    "name": "Hoplite",
    "description": "Heavily armored infantry, strong defensive unit.",
    "cost": {
      "wood": 70,
      "stone": 60,
      "silver": 40,
      "population": 2,
      "time": 60
    },
    "attack": 15,
    "defense": 25,
    "speed": 4,
    "type": "land",
    "counters": ["cavalry"],
    "image": "hospite.png"
  },
  "cavalry": {
    "name": "Cavalry",
    "description": "Fast and powerful mounted units, good for flanking.",
    "cost": {
      "wood": 80,
      "stone": 50,
      "silver": 70,
      "population": 3,
      "time": 90
    },
    "attack": 20,
    "defense": 18,
    "speed": 10,
    "type": "land",
    "counters": ["archer", "slinger"],
    "image": "cavalry.png"
  },
  "transport_ship": {
    "name": "Transport Ship",
    "description": "Standard transport for land units across seas. Slower but higher capacity.",
    "cost": {
      "wood": 200,
      "stone": 100,
      "silver": 150,
      "population": 5,
      "time": 180
    },
    "attack": 0,
    "defense": 20,
    "speed": 10,
    "type": "naval",
    "capacity": 16,
    "requiredBuilding": "shipyard",
    "image": "transport_ship.png"
  },
  "fast_transport_ship": {
    "name": "Fast Transport Ship",
    "description": "Faster transport for land units, but with less capacity.",
    "cost": {
      "wood": 250,
      "stone": 120,
      "silver": 180,
      "population": 6,
      "time": 240
    },
    "attack": 0,
    "defense": 15,
    "speed": 15,
    "type": "naval",
    "capacity": 10,
    "requiredBuilding": "shipyard",
    "image": "fast_transport_ship.png"
  },
  "trireme": {
    "name": "Trireme",
    "description": "A powerful naval combat vessel.",
    "cost": {
      "wood": 300,
      "stone": 150,
      "silver": 200,
      "population": 8,
      "time": 300
    },
    "attack": 25,
    "defense": 30,
    "speed": 8,
    "type": "naval",
    "counters": ["transport_ship", "fast_transport_ship"],
    "requiredBuilding": "shipyard",
    "image": "trireme.png"
  }
}
</file>

<file path="src/hooks/useCityState.js">
// src/hooks/useCityState.js

import { useState, useEffect, useCallback, useRef } from 'react';
import { useAuth } from '../contexts/AuthContext';
import { doc, onSnapshot, setDoc } from 'firebase/firestore';
import { db } from '../firebase/config';
import buildingConfig from '../gameData/buildings.json';
import unitConfig from '../gameData/units.json';
import researchConfig from '../gameData/research.json'; // Import research config

const getGameDocRef = (userId, worldId) => doc(db, `users/${userId}/games`, worldId);

export const useCityState = (worldId, isInstantBuild, isInstantResearch, isInstantUnits) => { // Added isInstantResearch, isInstantUnits
    const { currentUser } = useAuth();
    const [cityGameState, setCityGameState] = useState(null);
    const gameStateRef = useRef(cityGameState);

    useEffect(() => {
        gameStateRef.current = cityGameState;
    }, [cityGameState]);

    const getProductionRates = useCallback((buildings) => {
        if (!buildings) return { wood: 0, stone: 0, silver: 0 };
        return {
            wood: Math.floor(30 * Math.pow(1.2, (buildings.timber_camp?.level || 1) - 1)),
            stone: Math.floor(30 * Math.pow(1.2, (buildings.quarry?.level || 1) - 1)),
            silver: Math.floor(15 * Math.pow(1.15, (buildings.silver_mine?.level || 1) - 1)),
        };
    }, []);

    const getWarehouseCapacity = useCallback((level) => {
        if (!level) return 0;
        return Math.floor(1000 * Math.pow(1.5, level - 1));
    }, []);

    const getFarmCapacity = useCallback((level) => {
        if (!level) return 0;
        return Math.floor(100 * Math.pow(1.3, level - 1));
    }, []);

    const getHospitalCapacity = useCallback((level) => {
        if (!level) return 0;
        return level * 1000;
    }, []);

    const getUpgradeCost = useCallback((buildingId, level) => {
        const building = buildingConfig[buildingId];
        if (!building || level < 1) return { wood: 0, stone: 0, silver: 0, population: 0, time: 0 };
        
        const cost = building.baseCost;
        let populationCost = Math.floor(cost.population * Math.pow(1.1, level - 1));
        const initialBuildings = ['senate', 'farm', 'warehouse', 'timber_camp', 'quarry', 'silver_mine', 'cave', 'hospital'];
        if (level === 1 && initialBuildings.includes(buildingId)) {
          populationCost = 0;
        }

        const calculatedTime = Math.floor(cost.time * Math.pow(1.5, level - 1));

        return {
            wood: Math.floor(cost.wood * Math.pow(1.6, level - 1)),
            stone: Math.floor(cost.stone * Math.pow(1.6, level - 1)),
            silver: Math.floor(cost.silver * Math.pow(1.8, level - 1)),
            population: populationCost,
            time: isInstantBuild ? 1 : calculatedTime,
        };
    }, [isInstantBuild]);
    
    // New function to get research cost and time
    const getResearchCost = useCallback((researchId) => {
        const research = researchConfig[researchId];
        if (!research) return null;
        return {
            wood: research.cost.wood,
            stone: research.cost.stone,
            silver: research.cost.silver,
            time: isInstantResearch ? 1 : research.cost.time, // Apply instant research
        };
    }, [isInstantResearch]); // Dependency on the new prop

    const calculateUsedPopulation = useCallback((buildings, units) => {
        let used = 0;
        if (buildings) {
          for (const buildingId in buildings) {
            const buildingData = buildings[buildingId];
            const startLevel = ['senate', 'farm', 'warehouse', 'timber_camp', 'quarry', 'silver_mine', 'cave', 'hospital'].includes(buildingId) ? 1 : 0;
            for (let i = startLevel; i <= buildingData.level; i++) {
              if (i > 0) {
                used += getUpgradeCost(buildingId, i).population;
              }
            }
          }
        }
        if (units) {
          for (const unitId in units) {
            used += (unitConfig[unitId]?.cost.population || 0) * units[unitId];
          }
        }
        return used;
    }, [getUpgradeCost]);

    const saveGameState = useCallback(async (stateToSave) => {
        if (!currentUser || !worldId || !stateToSave) return;
        try {
            const gameDocRef = getGameDocRef(currentUser.uid, worldId);
            const dataToSave = { ...stateToSave, lastUpdated: Date.now() };
            if (dataToSave.buildQueue) {
                dataToSave.buildQueue = dataToSave.buildQueue.map(task => ({
                    ...task,
                    endTime: task.endTime.toDate ? task.endTime.toDate() : task.endTime
                }));
            }
            if (dataToSave.unitQueue) {
                dataToSave.unitQueue = dataToSave.unitQueue.map(task => ({
                    ...task,
                    endTime: task.endTime.toDate ? task.endTime.toDate() : task.endTime
                }));
            }
            if (dataToSave.researchQueue) { // Add researchQueue to save logic
                dataToSave.researchQueue = dataToSave.researchQueue.map(task => ({
                    ...task,
                    endTime: task.endTime.toDate ? task.endTime.toDate() : task.endTime
                }));
            }
            if (dataToSave.healQueue) {
                dataToSave.healQueue = dataToSave.healQueue.map(task => ({
                    ...task,
                    endTime: task.endTime.toDate ? task.endTime.toDate() : task.endTime
                }));
            }
            await setDoc(gameDocRef, dataToSave, { merge: true });
        } catch (error) {
            console.error('Failed to save game state:', error);
        }
    }, [currentUser, worldId]);

    useEffect(() => {
        if (!currentUser || !worldId) return;
        const gameDocRef = getGameDocRef(currentUser.uid, worldId);
        const unsubscribe = onSnapshot(gameDocRef, (docSnap) => {
            if (docSnap.exists()) {
                const data = docSnap.data();
                if (!data.units) data.units = {};
                if (!data.wounded) data.wounded = {};
                if (!data.worship) data.worship = {};
                if (!data.cave) data.cave = { silver: 0 }; 
                if (!data.research) data.research = {};
                if (!data.buildings.cave) data.buildings.cave = { level: 1 };
                if (!data.buildings.hospital) data.buildings.hospital = { level: 0 };
                if (!data.buildQueue) data.buildQueue = [];
                if (!data.unitQueue) data.unitQueue = [];
                if (!data.researchQueue) data.researchQueue = []; // Initialize researchQueue
                if (!data.healQueue) data.healQueue = [];

                setCityGameState(data);
            }
        });
        return () => unsubscribe();
    }, [currentUser, worldId]);

    useEffect(() => {
        const interval = setInterval(() => {
            setCityGameState(prevState => {
                if (!prevState) return null;
                const now = Date.now();
                const lastUpdate = prevState.lastUpdated || now;
                const elapsedSeconds = (now - lastUpdate) / 1000;
                
                const newState = JSON.parse(JSON.stringify(prevState));
                
                const productionRates = getProductionRates(newState.buildings);
                const capacity = getWarehouseCapacity(newState.buildings?.warehouse?.level);
                newState.resources.wood = Math.min(capacity, prevState.resources.wood + (productionRates.wood / 3600) * elapsedSeconds);
                newState.resources.stone = Math.min(capacity, prevState.resources.stone + (productionRates.stone / 3600) * elapsedSeconds);
                newState.resources.silver = Math.min(capacity, prevState.resources.silver + (productionRates.silver / 3600) * elapsedSeconds);

                const templeLevel = newState.buildings.temple?.level || 0;
                if (newState.god && templeLevel > 0) {
                    const favorPerSecond = templeLevel / 3600;
                    const maxFavor = 100 + (templeLevel * 20);
                    newState.worship[newState.god] = Math.min(maxFavor, (prevState.worship[newState.god] || 0) + favorPerSecond * elapsedSeconds);
                }
                
                newState.lastUpdated = now;
                return newState;
            });
        }, 1000);
        return () => clearInterval(interval);
    }, [getProductionRates, getWarehouseCapacity]);

    useEffect(() => {
        const processQueue = async () => {
            const currentState = gameStateRef.current;
            if (!currentUser || !worldId || (!currentState?.buildQueue?.length && !currentState?.unitQueue?.length && !currentState?.researchQueue?.length && !currentState?.healQueue?.length)) return;

            const now = Date.now();

            // Process Build Queue
            if (currentState.buildQueue && currentState.buildQueue.length > 0) {
                const completedBuildTasks = [];
                const remainingBuildQueue = [];

                currentState.buildQueue.forEach(task => {
                    const endTime = task.endTime?.toDate ? task.endTime.toDate().getTime() : new Date(task.endTime).getTime();
                    if (endTime > 0 && now >= endTime) {
                        completedBuildTasks.push(task);
                    } else {
                        remainingBuildQueue.push(task);
                    }
                });

                if (completedBuildTasks.length > 0) {
                    const newBuildings = { ...currentState.buildings };
                    completedBuildTasks.forEach(task => {
                        newBuildings[task.buildingId].level = task.level;
                    });
                    try {
                        await setDoc(getGameDocRef(currentUser.uid, worldId), {
                            buildings: newBuildings,
                            buildQueue: remainingBuildQueue,
                            lastUpdated: now
                        }, { merge: true });
                    } catch (error) {
                        console.error("Error completing build task(s):", error);
                    }
                }
            }

            // Process Unit Queue
            if (currentState.unitQueue && currentState.unitQueue.length > 0) {
                const completedUnitTasks = [];
                const remainingUnitQueue = [];

                currentState.unitQueue.forEach(task => {
                    const endTime = task.endTime?.toDate ? task.endTime.toDate().getTime() : new Date(task.endTime).getTime();
                    if (endTime > 0 && now >= endTime) {
                        completedUnitTasks.push(task);
                    } else {
                        remainingUnitQueue.push(task);
                    }
                });

                if (completedUnitTasks.length > 0) {
                    const newUnits = { ...currentState.units };
                    completedUnitTasks.forEach(task => {
                        newUnits[task.unitId] = (newUnits[task.unitId] || 0) + task.amount;
                    });
                    try {
                        await setDoc(getGameDocRef(currentUser.uid, worldId), {
                            units: newUnits,
                            unitQueue: remainingUnitQueue,
                            lastUpdated: now
                        }, { merge: true });
                    } catch (error) {
                        console.error("Error completing unit training task(s):", error);
                    }
                }
            }

            // Process Research Queue
            if (currentState.researchQueue && currentState.researchQueue.length > 0) {
                const completedResearchTasks = [];
                const remainingResearchQueue = [];

                currentState.researchQueue.forEach(task => {
                    const endTime = task.endTime?.toDate ? task.endTime.toDate().getTime() : new Date(task.endTime).getTime();
                    if (endTime > 0 && now >= endTime) {
                        completedResearchTasks.push(task);
                    } else {
                        remainingResearchQueue.push(task);
                    }
                });

                if (completedResearchTasks.length > 0) {
                    const newResearch = { ...currentState.research };
                    completedResearchTasks.forEach(task => {
                        newResearch[task.researchId] = true;
                    });
                    try {
                        await setDoc(getGameDocRef(currentUser.uid, worldId), {
                            research: newResearch,
                            researchQueue: remainingResearchQueue,
                            lastUpdated: now
                        }, { merge: true });
                    } catch (error) {
                        console.error("Error completing research task(s):", error);
                    }
                }
            }

            // Process Heal Queue
            if (currentState.healQueue && currentState.healQueue.length > 0) {
                const completedHealTasks = [];
                const remainingHealQueue = [];

                currentState.healQueue.forEach(task => {
                    const endTime = task.endTime?.toDate ? task.endTime.toDate().getTime() : new Date(task.endTime).getTime();
                    if (endTime > 0 && now >= endTime) {
                        completedHealTasks.push(task);
                    } else {
                        remainingHealQueue.push(task);
                    }
                });

                if (completedHealTasks.length > 0) {
                    const newUnits = { ...currentState.units };
                    completedHealTasks.forEach(task => {
                        newUnits[task.unitId] = (newUnits[task.unitId] || 0) + task.amount;
                    });
                    try {
                        await setDoc(getGameDocRef(currentUser.uid, worldId), {
                            units: newUnits,
                            healQueue: remainingHealQueue,
                            lastUpdated: now
                        }, { merge: true });
                    } catch (error) {
                        console.error("Error completing healing task(s):", error);
                    }
                }
            }
        };
        const interval = setInterval(processQueue, 1000);
        return () => clearInterval(interval);
    }, [currentUser, worldId]);

    useEffect(() => {
        const saveInterval = setInterval(() => {
            if (gameStateRef.current) saveGameState(gameStateRef.current);
        }, 30000);
        return () => clearInterval(saveInterval);
    }, [saveGameState]);

    return { 
        cityGameState, 
        setCityGameState, 
        getUpgradeCost, 
        getFarmCapacity,
        getWarehouseCapacity,
        getHospitalCapacity,
        getProductionRates,
        calculateUsedPopulation,
        saveGameState,
        getResearchCost
    };
};
</file>

<file path="src/hooks/useMapActions.js">
import { useState, useCallback } from 'react';
import { useAuth } from '../contexts/AuthContext';
import { useGame } from '../contexts/GameContext';
import { db } from '../firebase/config';
import { collection, writeBatch, doc, serverTimestamp, getDoc } from 'firebase/firestore';
import { v4 as uuidv4 } from 'uuid';
import { calculateDistance, calculateTravelTime } from '../utils/travel';
import unitConfig from '../gameData/units.json';
import buildingConfig from '../gameData/buildings.json';

export const useMapActions = (openModal, closeModal, showCity, invalidateChunkCache) => {
    const { currentUser, userProfile } = useAuth();
    const { worldId, gameState, playerCity, setGameState } = useGame();
    const [message, setMessage] = useState('');
    const [travelTimeInfo, setTravelTimeInfo] = useState(null);

    const handleActionClick = useCallback((mode, targetCity) => {
        if (['attack', 'reinforce', 'scout', 'trade'].includes(mode)) {
            openModal('action', { mode, city: targetCity });
            closeModal('city');
            closeModal('village');
        } else if (mode === 'message') {
            openModal('messages', { city: targetCity });
            closeModal('city');
        } else if (mode === 'castSpell') {
            openModal('divinePowers', { targetCity });
            closeModal('city');
        } else if (['information', 'rally'].includes(mode)) {
            setMessage(`${mode.charAt(0).toUpperCase() + mode.slice(1)} is not yet implemented.`);
        }
    }, [openModal, closeModal]);

    const handleSendMovement = async (movementDetails) => {
        const { mode, targetCity, units, resources, attackFormation } = movementDetails;
        // Only restrict village interactions to same island
        if (targetCity.isVillageTarget && playerCity.islandId !== targetCity.islandId) {
            setMessage("You can only attack villages from a city on the same island.");
            return;
        }

        // Cross-island checks for land units (require transport ships)
        const isCrossIsland = playerCity.islandId !== targetCity.islandId;
        let hasLandUnits = false, hasNavalUnits = false, totalTransportCapacity = 0, totalLandUnitsToSend = 0;
        for (const unitId in units) {
            if (units[unitId] > 0) {
                const config = unitConfig[unitId];
                if (config.type === 'land') { hasLandUnits = true; totalLandUnitsToSend += units[unitId]; }
                else if (config.type === 'naval') { hasNavalUnits = true; totalTransportCapacity += (config.capacity || 0) * units[unitId]; }
            }
        }
        if (isCrossIsland && hasLandUnits && !hasNavalUnits) { setMessage("Ground troops cannot travel across the sea without transport ships."); return; }
        if (isCrossIsland && hasLandUnits && totalTransportCapacity < totalLandUnitsToSend) { setMessage(`Not enough transport ship capacity. Need ${totalLandUnitsToSend - totalTransportCapacity} more capacity.`); return; }

        const batch = writeBatch(db);
        const newMovementRef = doc(collection(db, 'worlds', worldId, 'movements'));
        const distance = calculateDistance(playerCity, targetCity);
        const unitsBeingSent = Object.entries(units || {}).filter(([, count]) => count > 0);

        if (unitsBeingSent.length === 0 && !['trade', 'scout'].includes(mode)) {
            setMessage("No units selected for movement.");
            return;
        }

        const slowestSpeed = unitsBeingSent.length > 0
            ? Math.min(...unitsBeingSent.map(([unitId]) => unitConfig[unitId].speed))
            : 10;

        const travelSeconds = calculateTravelTime(distance, slowestSpeed);
        const arrivalTime = new Date(Date.now() + travelSeconds * 1000);

        // --- Correct movement type and fields for village attacks ---
        let movementData;
        if (mode === 'attack' && targetCity.isVillageTarget) {
            movementData = {
                type: 'attack_village',
                targetVillageId: targetCity.id,
                originCityId: playerCity.id,
                originOwnerId: currentUser.uid,
                originCityName: playerCity.cityName,
                originOwnerUsername: userProfile.username,
                units,
                resources: resources || {},
                departureTime: serverTimestamp(),
                arrivalTime,
                status: 'moving',
                attackFormation: attackFormation || {},
                involvedParties: [currentUser.uid],
                isVillageTarget: true,
                isCrossIsland: false, // Village attacks are always same-island
            };
        } else {
            movementData = {
                type: mode,
                originCityId: playerCity.id,
                originOwnerId: currentUser.uid,
                originCityName: playerCity.cityName,
                targetCityId: targetCity.id,
                targetOwnerId: targetCity.ownerId,
                ownerUsername: targetCity.ownerUsername,
                targetCityName: targetCity.cityName,
                units,
                resources: resources || {},
                departureTime: serverTimestamp(),
                arrivalTime,
                status: 'moving',
                attackFormation: attackFormation || {},
                involvedParties: [currentUser.uid, targetCity.ownerId].filter(id => id),
                isVillageTarget: !!targetCity.isVillageTarget,
                isCrossIsland, // Add the flag here
            };
        }

        batch.set(newMovementRef, movementData);

        // --- THIS IS THE FIX ---
        // Prepare the updated state for units and resources
        const gameDocRef = doc(db, `users/${currentUser.uid}/games`, worldId);
        const updatedUnits = { ...gameState.units };
        for (const unitId in units) {
            updatedUnits[unitId] = (updatedUnits[unitId] || 0) - units[unitId];
        }

        const updatedResources = { ...gameState.resources };
        const updatedCave = { ...gameState.cave };
        if (mode === 'scout') {
            if (resources && resources.silver) {
                updatedCave.silver = (updatedCave.silver || 0) - resources.silver;
            }
        } else if (resources) {
            for (const resource in resources) {
                updatedResources[resource] -= resources[resource];
            }
        }
        
        // Add the update operation to the same batch
        batch.update(gameDocRef, {
            units: updatedUnits,
            resources: updatedResources,
            cave: updatedCave
        });
        // --- END OF FIX ---


        // Optimistically update the local state for immediate UI feedback
        const newGameState = {
            ...gameState,
            units: updatedUnits,
            resources: updatedResources,
            cave: updatedCave,
        };

        try {
            await batch.commit();
            setGameState(newGameState);
            setMessage(`Movement sent to ${targetCity.cityName || targetCity.name}!`);
        } catch (error) {
            console.error("Error sending movement:", error);
            setMessage(`Failed to send movement: ${error.message}`);
        }
    };

    const handleCreateDummyCity = async (citySlotId, slotData) => {
        if (!userProfile?.is_admin) {
            setMessage("You are not authorized to perform this action.");
            return;
        }
        setMessage("Creating dummy city...");

        const citySlotRef = doc(db, 'worlds', worldId, 'citySlots', citySlotId);
        const dummyUserId = `dummy_${uuidv4()}`;
        const dummyUsername = `DummyPlayer_${Math.floor(Math.random() * 10000)}`;
        const dummyGameDocRef = doc(db, `users/${dummyUserId}/games`, worldId);

        try {
            const slotSnap = await getDoc(citySlotRef);
            if (!slotSnap.exists() || slotSnap.data().ownerId !== null) {
                throw new Error("Slot is already taken.");
            }

            const batch = writeBatch(db);
            const dummyCityName = `${dummyUsername}'s Outpost`;

            batch.update(citySlotRef, {
                ownerId: dummyUserId,
                ownerUsername: dummyUsername,
                cityName: dummyCityName,
            });

            const initialBuildings = {};
            Object.keys(buildingConfig).forEach(key => {
                initialBuildings[key] = { level: 0 };
            });
            initialBuildings.senate = { level: 1 };

            batch.set(dummyGameDocRef, {
                id: citySlotId,
                cityName: dummyCityName,
                playerInfo: { religion: 'Dummy', nation: 'Dummy' },
                resources: { wood: 500, stone: 500, silver: 100 },
                buildings: initialBuildings,
                units: {},
                lastUpdated: Date.now(),
            });

            await batch.commit();
            setMessage(`Dummy city "${dummyCityName}" created successfully!`);

            invalidateChunkCache(slotData.x, slotData.y);

        } catch (error) {
            console.error("Error creating dummy city:", error);
            setMessage(`Failed to create dummy city: ${error.message}`);
        }
    };

    return {
        message,
        setMessage,
        travelTimeInfo,
        setTravelTimeInfo,
        handleActionClick,
        handleSendMovement,
        handleCreateDummyCity
    };
};
</file>

<file path="src/hooks/usemapdatapls.js">
import { useState, useEffect, useCallback } from 'react';
import { collection, query, where, getDocs, onSnapshot } from 'firebase/firestore';
import { db } from '../firebase/config';

const CHUNK_SIZE = 50;
const TILE_SIZE = 32;


export const useMapData = (currentUser, worldId, worldState, pan, zoom, viewportSize) => {
    const [movements, setMovements] = useState([]);
    const [cachedCitySlots, setCachedCitySlots] = useState({});
    const [visibleSlots, setVisibleSlots] = useState({});
    const [villages, setVillages] = useState({});


    const invalidateChunkCache = useCallback((x, y) => {
        const chunkX = Math.floor(x / CHUNK_SIZE);
        const chunkY = Math.floor(y / CHUNK_SIZE);
        const chunkKey = `${chunkX},${chunkY}`;
        setCachedCitySlots(prevCache => {
            const newCache = { ...prevCache };
            delete newCache[chunkKey];
            return newCache;
        });
    }, []);

    useEffect(() => {
        if (!worldId || !currentUser) return;
        const movementsRef = collection(db, 'worlds', worldId, 'movements');
        const q = query(movementsRef, where('involvedParties', 'array-contains', currentUser.uid));
        const unsubscribeMovements = onSnapshot(q, (snapshot) => {
            const allMovements = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            setMovements(allMovements.sort((a, b) => a.arrivalTime.toMillis() - b.arrivalTime.toMillis()));
        });

        const villagesColRef = collection(db, 'worlds', worldId, 'villages');
        const unsubscribeVillages = onSnapshot(villagesColRef, (snapshot) => {
            const villagesData = {};
            snapshot.docs.forEach(doc => {
                villagesData[doc.id] = { id: doc.id, ...doc.data() };
            });
            setVillages(villagesData);
        });

        return () => {
            unsubscribeMovements();
            unsubscribeVillages();
        };
    }, [worldId, currentUser]);


    useEffect(() => {
        const fetchVisibleSlots = async () => {
            if (!worldState || viewportSize.width === 0 || zoom <= 0 || !worldId) return;

            const scaledTileSize = TILE_SIZE * zoom;
            const viewStartCol = Math.floor(-pan.x / scaledTileSize);
            const viewEndCol = Math.ceil((-pan.x + viewportSize.width) / scaledTileSize);
            const viewStartRow = Math.floor(-pan.y / scaledTileSize);
            const viewEndRow = Math.ceil((-pan.y + viewportSize.height) / scaledTileSize);

            const newVisible = {};
            const chunksToFetch = new Set();
            let needsFetch = false;

            for (let y = viewStartRow; y <= viewEndRow; y++) {
                for (let x = viewStartCol; x <= viewEndCol; x++) {
                    const chunkKey = `${Math.floor(x / CHUNK_SIZE)},${Math.floor(y / CHUNK_SIZE)}`;
                    if (!cachedCitySlots[chunkKey]) {
                        needsFetch = true;
                        chunksToFetch.add(chunkKey);
                    } else {
                        Object.values(cachedCitySlots[chunkKey]).forEach(slot => {
                            if (slot.x >= viewStartCol && slot.x <= viewEndCol && slot.y >= viewStartRow && slot.y <= viewEndRow) {
                                newVisible[slot.id] = slot;
                            }
                        });
                    }
                }
            }

            if (needsFetch) {
                const newCache = { ...cachedCitySlots };
                await Promise.all(Array.from(chunksToFetch).map(async (key) => {
                    const [chunkX, chunkY] = key.split(',').map(Number);
                    const q = query(
                        collection(db, 'worlds', worldId, 'citySlots'),
                        where('x', '>=', chunkX * CHUNK_SIZE), where('x', '<', (chunkX + 1) * CHUNK_SIZE),
                        where('y', '>=', chunkY * CHUNK_SIZE), where('y', '<', (chunkY + 1) * CHUNK_SIZE)
                    );
                    try {
                        const snapshot = await getDocs(q);
                        const chunkData = {};
                        snapshot.forEach(doc => {
                            chunkData[doc.id] = { id: doc.id, ...doc.data() };
                            if (doc.data().x >= viewStartCol && doc.data().x <= viewEndCol && doc.data().y >= viewStartRow && doc.data().y <= viewEndRow) {
                                newVisible[doc.id] = { id: doc.id, ...doc.data() };
                            }
                        });
                        newCache[key] = chunkData;
                    } catch (error) {
                           console.error(`Error fetching city slots for chunk ${key}:`, error);
                    }
                }));
                setCachedCitySlots(newCache);
            }
            setVisibleSlots(newVisible);
        };
        const timer = setTimeout(fetchVisibleSlots, 200);
        return () => clearTimeout(timer);
    }, [pan, zoom, viewportSize.width, viewportSize.height, worldState, worldId, cachedCitySlots]);


    return {
        movements,
        visibleSlots,
        villages,
        invalidateChunkCache
    };
};
</file>

<file path="src/hooks/useMapInteraction.js">
import { useState, useCallback, useEffect } from 'react';

const TILE_SIZE = 32;
const OVERSCROLL_AMOUNT = 100;

export const useMapInteraction = (viewportRef, mapContainerRef, worldState, playerCity) => {
    const [pan, setPan] = useState({ x: 0, y: 0 });
    const [zoom, setZoom] = useState(0.5);
    const [minZoom, setMinZoom] = useState(0.5);
    const [isPanning, setIsPanning] = useState(false);
    const [startPos, setStartPos] = useState({ x: 0, y: 0 });
    const [borderOpacity, setBorderOpacity] = useState({ top: 0, bottom: 0, left: 0, right: 0 });
    const [viewportSize, setViewportSize] = useState({ width: 0, height: 0 });

    const clampPan = useCallback((newPan, currentZoom) => {
        if (!viewportRef.current || !worldState?.islands) return newPan;
        const mapWidth = worldState.width * TILE_SIZE;
        const mapHeight = worldState.height * TILE_SIZE;
        const { clientWidth: viewportWidth, clientHeight: viewportHeight } = viewportRef.current;
        const minX = viewportWidth - mapWidth * currentZoom;
        const minY = viewportHeight - mapHeight * currentZoom;

        setBorderOpacity({
            left: Math.max(0, Math.min(1, newPan.x / OVERSCROLL_AMOUNT)),
            right: Math.max(0, Math.min(1, (minX - newPan.x) / OVERSCROLL_AMOUNT)),
            top: Math.max(0, Math.min(1, newPan.y / OVERSCROLL_AMOUNT)),
            bottom: Math.max(0, Math.min(1, (minY - newPan.y) / OVERSCROLL_AMOUNT)),
        });

        return {
            x: Math.min(OVERSCROLL_AMOUNT, Math.max(minX - OVERSCROLL_AMOUNT, newPan.x)),
            y: Math.min(OVERSCROLL_AMOUNT, Math.max(minY - OVERSCROLL_AMOUNT, newPan.y)),
        };
    }, [worldState, viewportRef]);

    const goToCoordinates = useCallback((x, y) => {
        if (!viewportRef.current) return;
        const { clientWidth: viewportWidth, clientHeight: viewportHeight } = viewportRef.current;
        const targetX = -x * TILE_SIZE * zoom + (viewportWidth / 2) - (TILE_SIZE * zoom / 2);
        const targetY = -y * TILE_SIZE * zoom + (viewportHeight / 2) - (TILE_SIZE * zoom / 2);
        const newPan = clampPan({ x: targetX, y: targetY }, zoom);
        setPan(newPan);
    }, [zoom, clampPan, viewportRef]);

    const centerOnCity = useCallback(() => {
        if (playerCity) {
            goToCoordinates(playerCity.x, playerCity.y);
        }
    }, [playerCity, goToCoordinates]);


    useEffect(() => {
        const viewport = viewportRef.current;
        if (!viewport || !worldState?.islands) return;
        const handleResize = () => {
            setViewportSize({ width: viewport.clientWidth, height: viewport.clientHeight });
            const newMinZoom = Math.max(
                viewport.clientWidth / (worldState.width * TILE_SIZE),
                viewport.clientHeight / (worldState.height * TILE_SIZE),
                0.3
            );
            setMinZoom(newMinZoom);
            setZoom(prevZoom => Math.max(newMinZoom, prevZoom));
        };
        handleResize();
        centerOnCity();
        window.addEventListener('resize', handleResize);
        return () => window.removeEventListener('resize', handleResize);
    }, [worldState, centerOnCity, viewportRef]);


    useEffect(() => {
        const container = mapContainerRef.current;
        if (container) {
            container.style.transform = `translate(${pan.x}px, ${pan.y}px) scale(${zoom})`;
        }
    }, [pan, zoom, mapContainerRef]);

    const handleWheel = useCallback((e) => {
        if (!viewportRef.current) return;
        e.preventDefault();
        const scaleAmount = -e.deltaY * 0.002;
        const newZoom = Math.max(minZoom, Math.min(3, zoom + scaleAmount));
        const rect = viewportRef.current.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        const pointX = (mouseX - pan.x) / zoom;
        const pointY = (mouseY - pan.y) / zoom;
        const newPan = clampPan({ x: mouseX - pointX * newZoom, y: mouseY - pointY * newZoom }, newZoom);
        setZoom(newZoom);
        setPan(newPan);
    }, [zoom, pan, clampPan, minZoom, viewportRef]);


    useEffect(() => {
        const viewport = viewportRef.current;
        if (viewport) {
            viewport.addEventListener('wheel', handleWheel, { passive: false });
        }
        return () => {
            if (viewport) {
                viewport.removeEventListener('wheel', handleWheel);
            }
        };
    }, [handleWheel, viewportRef]);


    const handleMouseDown = useCallback((e) => {
        if (e.button !== 0) return;
        setStartPos({ x: e.clientX - pan.x, y: e.clientY - pan.y });
        setIsPanning(true);
    }, [pan]);

    useEffect(() => {
        const handleMouseMove = (e) => {
            if (!isPanning) return;
            const newPan = clampPan({ x: e.clientX - startPos.x, y: e.clientY - startPos.y }, zoom);
            setPan(newPan);
        };
        const handleMouseUp = () => setIsPanning(false);

        if (isPanning) {
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp);
        }

        return () => {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        };
    }, [isPanning, startPos, zoom, clampPan]);


    return {
        pan,
        zoom,
        viewportSize,
        borderOpacity,
        isPanning,
        handleMouseDown,
        goToCoordinates,
        centerOnCity
    };
};
</file>

<file path="src/hooks/useModalState.js">
// src/hooks/useModalState.js
import { useState } from 'react';

export const useModalState = () => {
    const [modalState, setModalState] = useState({
        selectedCity: null,
        selectedVillage: null,
        actionDetails: null,
        isMovementsPanelOpen: false,
        isReportsPanelOpen: false,
        isAllianceModalOpen: false,
        isAllianceCreationOpen: false, // Added this line
        isMessagesPanelOpen: false,
        isDivinePowersOpen: false,
        divinePowersTarget: null,
        isProfileModalOpen: false,
    });

    const openModal = (type, data) => {
        setModalState(prevState => {
            switch (type) {
                case 'city': return { ...prevState, selectedCity: data };
                case 'village': return { ...prevState, selectedVillage: data };
                case 'action': return { ...prevState, actionDetails: data };
                case 'movements': return { ...prevState, isMovementsPanelOpen: true };
                case 'reports': return { ...prevState, isReportsPanelOpen: true };
                case 'alliance': return { ...prevState, isAllianceModalOpen: true };
                case 'allianceCreation': return { ...prevState, isAllianceCreationOpen: true }; // Added this line
                case 'messages': return { ...prevState, isMessagesPanelOpen: true };
                case 'divinePowers': return { ...prevState, isDivinePowersOpen: true, divinePowersTarget: data?.targetCity || null };
                case 'profile': return { ...prevState, isProfileModalOpen: true };
                default: return prevState;
            }
        });
    };

    const closeModal = (type) => {
        setModalState(prevState => {
            switch (type) {
                case 'city': return { ...prevState, selectedCity: null };
                case 'village': return { ...prevState, selectedVillage: null };
                case 'action': return { ...prevState, actionDetails: null };
                case 'movements': return { ...prevState, isMovementsPanelOpen: false };
                case 'reports': return { ...prevState, isReportsPanelOpen: false };
                case 'alliance': return { ...prevState, isAllianceModalOpen: false };
                case 'allianceCreation': return { ...prevState, isAllianceCreationOpen: false }; // Added this line
                case 'messages': return { ...prevState, isMessagesPanelOpen: false };
                case 'divinePowers': return { ...prevState, isDivinePowersOpen: false, divinePowersTarget: null };
                case 'profile': return { ...prevState, isProfileModalOpen: false };
                default: return prevState;
            }
        });
    };

    return {
        modalState,
        openModal,
        closeModal,
    };
};
</file>

<file path="src/utils/combat.js">
// src/utils/combat.js
import unitConfig from '../gameData/units.json';

/**
 * Resolves a battle between attacking and defending units of a specific type.
 * Incorporates phalanx, support, and counter unit logic.
 * @param {object} attackingUnits - Units of the attacker.
 * @param {object} defendingUnits - Units of the defender.
 * @param {string} unitType - 'land' or 'naval'.
 * @param {string|null} attackerPhalanx - The unit ID chosen as phalanx by the attacker.
 * @param {string|null} attackerSupport - The unit ID chosen as support by the attacker.
 * @param {string|null} defenderPhalanx - The unit ID chosen as phalanx by the defender.
 * @param {string|null} defenderSupport - The unit ID chosen as support by the defender.
 * @returns {object} Battle results including attackerWon, attackerLosses, defenderLosses.
 */
const resolveBattle = (attackingUnits, defendingUnits, unitType, attackerPhalanx, attackerSupport, defenderPhalanx, defenderSupport) => {
    // Check if either side has units of the required type
    const hasAttackingUnits = Object.entries(attackingUnits || {}).some(
        ([unitId, count]) => count > 0 && unitConfig[unitId]?.type === unitType && unitConfig[unitId]?.attack > 0
    );
    const hasDefendingUnits = Object.entries(defendingUnits || {}).some(
        ([unitId, count]) => count > 0 && unitConfig[unitId]?.type === unitType
    );

    // If the defender has no relevant units, the attacker automatically wins this phase.
    if (!hasDefendingUnits) {
        return {
            attackerWon: true,
            attackerLosses: {},
            defenderLosses: {},
        };
    }
    
    // If the attacker has no relevant combat units, but the defender does, the attacker loses.
    if (!hasAttackingUnits) {
        return {
            attackerWon: false,
            attackerLosses: {},
            defenderLosses: {},
        };
    }

    let currentAttackingUnits = { ...attackingUnits };
    let currentDefendingUnits = { ...defendingUnits };

    // Function to calculate effective power considering counters
    const calculateEffectivePower = (units, opponentUnits, isAttacker, phalanxUnit, supportUnit) => {
        let totalPower = 0;
        let phalanxPower = 0;
        let supportPower = 0;
        let otherPower = 0;

        for (const unitId in units) {
            const unitCount = units[unitId] || 0;
            if (unitCount === 0) continue;

            const unitInfo = unitConfig[unitId];
            if (!unitInfo || unitInfo.type !== unitType) continue;

            let attack = unitInfo.attack;
            let defense = unitInfo.defense;

            // Apply counter bonuses
            for (const opponentUnitId in opponentUnits) {
                const opponentUnitCount = opponentUnits[opponentUnitId] || 0;
                if (opponentUnitCount > 0) {
                    const opponentUnitInfo = unitConfig[opponentUnitId];
                    if (unitInfo.counters && unitInfo.counters.includes(opponentUnitId)) {
                        // If this unit counters the opponent unit, gain bonus attack
                        attack *= 1.2; // 20% attack bonus
                    }
                    if (opponentUnitInfo.counters && opponentUnitInfo.counters.includes(unitId)) {
                        // If opponent unit counters this unit, this unit's defense is reduced
                        defense *= 0.8; // 20% defense penalty
                    }
                }
            }

            const unitPower = unitCount * (isAttacker ? attack : defense);

            if (unitId === phalanxUnit) {
                phalanxPower += unitPower;
            } else if (unitId === supportUnit) {
                supportPower += unitPower;
            } else {
                otherPower += unitPower;
            }
            totalPower += unitPower;
        }
        return { totalPower, phalanxPower, supportPower, otherPower };
    };

    const attackerStats = calculateEffectivePower(currentAttackingUnits, currentDefendingUnits, true, attackerPhalanx, attackerSupport);
    const defenderStats = calculateEffectivePower(currentDefendingUnits, currentAttackingUnits, false, defenderPhalanx, defenderSupport);

    // Simplified combat rounds (can be expanded for more complexity)
    // Phalanx units engage first
    let initialAttackerPower = attackerStats.phalanxPower + attackerStats.supportPower * 0.5 + attackerStats.otherPower * 0.2; // Support and other units contribute less initially
    let initialDefenderPower = defenderStats.phalanxPower + defenderStats.supportPower * 0.5 + defenderStats.otherPower * 0.2;

    // Determine initial losses based on overall power
    const attackerLossRatio = Math.min(1, initialDefenderPower / (initialAttackerPower || 1));
    const defenderLossRatio = Math.min(1, initialAttackerPower / (initialDefenderPower || 1));

    // Apply losses based on role: phalanx takes more, then support, then others
    const applyLosses = (units, lossRatio, phalanx, support) => {
        const totalUnits = Object.values(units).reduce((sum, count) => sum + count, 0);
        if (totalUnits === 0) return {};

        const losses = {};
        let remainingLosses = Math.floor(totalUnits * lossRatio);

        // Prioritize losses for phalanx
        if (phalanx && units[phalanx] && remainingLosses > 0) {
            const phalanxLoss = Math.min(units[phalanx], Math.ceil(remainingLosses * 0.6)); // Phalanx takes 60% of initial losses
            losses[phalanx] = phalanxLoss;
            remainingLosses -= phalanxLoss;
        }

        // Then support
        if (support && units[support] && remainingLosses > 0) {
            const supportLoss = Math.min(units[support], Math.ceil(remainingLosses * 0.3)); // Support takes 30%
            losses[support] = (losses[support] || 0) + supportLoss;
            remainingLosses -= supportLoss;
        }

        // Distribute remaining losses proportionally among other units
        const otherUnits = Object.keys(units).filter(id => id !== phalanx && id !== support && unitConfig[id]?.type === unitType);
        if (remainingLosses > 0 && otherUnits.length > 0) {
            let currentOtherUnitsTotal = otherUnits.reduce((sum, id) => sum + (units[id] || 0) - (losses[id] || 0), 0);
            if (currentOtherUnitsTotal === 0) currentOtherUnitsTotal = 1; // Avoid division by zero

            for (const unitId of otherUnits) {
                if (remainingLosses > 0) {
                    const unitCount = (units[unitId] || 0) - (losses[unitId] || 0);
                    const proportionalLoss = Math.floor(remainingLosses * (unitCount / currentOtherUnitsTotal));
                    const actualLoss = Math.min(unitCount, proportionalLoss);
                    losses[unitId] = (losses[unitId] || 0) + actualLoss;
                    remainingLosses -= actualLoss;
                }
            }
            // Distribute any leftover losses to the largest remaining unit type
            if (remainingLosses > 0) {
                const largestRemainingUnit = otherUnits.reduce((largest, id) => {
                    const currentCount = (units[id] || 0) - (losses[id] || 0);
                    return currentCount > (units[largest] || 0) - (losses[largest] || 0) ? id : largest;
                }, otherUnits[0]);
                if (largestRemainingUnit) {
                    losses[largestRemainingUnit] = (losses[largestRemainingUnit] || 0) + remainingLosses;
                }
            }
        }
        return losses;
    };

    const finalAttackerLosses = applyLosses(currentAttackingUnits, attackerLossRatio, attackerPhalanx, attackerSupport);
    const finalDefenderLosses = applyLosses(currentDefendingUnits, defenderLossRatio, defenderPhalanx, defenderSupport);

    // Update current units after losses for the next calculation (if multiple rounds were simulated)
    for (const unitId in finalAttackerLosses) {
        currentAttackingUnits[unitId] = Math.max(0, (currentAttackingUnits[unitId] || 0) - finalAttackerLosses[unitId]);
    }
    for (const unitId in finalDefenderLosses) {
        currentDefendingUnits[unitId] = Math.max(0, (currentDefendingUnits[unitId] || 0) - finalDefenderLosses[unitId]);
    }

    // Recalculate power with remaining units to determine winner
    const finalAttackerPower = calculateEffectivePower(currentAttackingUnits, currentDefendingUnits, true, null, null).totalPower;
    const finalDefenderPower = calculateEffectivePower(currentDefendingUnits, currentAttackingUnits, false, null, null).totalPower;
    
    // Attacker wins on a tie (e.g., 0 vs 0 power)
    return {
        attackerWon: finalAttackerPower >= finalDefenderPower,
        attackerLosses: finalAttackerLosses,
        defenderLosses: finalDefenderLosses,
    };
};
export function getVillageTroops(villageData) {
    if (villageData.troops && Object.keys(villageData.troops).length > 0) {
        return villageData.troops;
    }

    const level = villageData.level || 1;
    let troops = {};
    switch (level) {
        case 1:
            troops = { swordsman: 15, archer: 10 };
            break;
        case 2:
            troops = { swordsman: 25, archer: 15, slinger: 5 };
            break;
        case 3:
            troops = { swordsman: 40, archer: 25, slinger: 10, hoplite: 5 };
            break;
        case 4:
            troops = { swordsman: 60, archer: 40, slinger: 20, hoplite: 15, cavalry: 5 };
            break;
        case 5:
            troops = { swordsman: 100, archer: 75, slinger: 50, hoplite: 40, cavalry: 20 };
            break;
        default:
            troops = { swordsman: 15, archer: 10 };
            break;
    }
    return troops;
}
export function resolveCombat(attackingUnits, defendingUnits, defendingResources, isNavalAttack, attackerPhalanx, attackerSupport, defenderPhalanx, defenderSupport) {
    let totalAttackerLosses = {};
    let totalDefenderLosses = {};
    let attackerWon = false;
    let plunder = { wood: 0, stone: 0, silver: 0 };
    let wounded = {};

    if (isNavalAttack) {
        const navalBattle = resolveBattle(attackingUnits, defendingUnits, 'naval', null, null, null, null); // No phalanx/support for naval
        totalAttackerLosses = { ...navalBattle.attackerLosses };
        totalDefenderLosses = { ...navalBattle.defenderLosses };

        if (navalBattle.attackerWon) {
            const survivingAttackers = { ...attackingUnits };
            for (const unitId in totalAttackerLosses) {
                survivingAttackers[unitId] = Math.max(0, (survivingAttackers[unitId] || 0) - totalAttackerLosses[unitId]);
            }

            const landBattle = resolveBattle(survivingAttackers, defendingUnits, 'land', attackerPhalanx, attackerSupport, defenderPhalanx, defenderSupport);
            for (const unitId in landBattle.attackerLosses) {
                totalAttackerLosses[unitId] = (totalAttackerLosses[unitId] || 0) + landBattle.attackerLosses[unitId];
            }
            for (const unitId in landBattle.defenderLosses) {
                totalDefenderLosses[unitId] = (totalDefenderLosses[unitId] || 0) + landBattle.defenderLosses[unitId];
            }
            
            attackerWon = landBattle.attackerWon;

            if (landBattle.attackerWon) {
                plunder.wood = Math.floor(defendingResources.wood * 0.25);
                plunder.stone = Math.floor(defendingResources.stone * 0.25);
                plunder.silver = Math.floor(defendingResources.silver * 0.25);
            }
        } else {
            // If naval battle is lost, all land units on transport ships are lost
            for (const unitId in attackingUnits) {
                if (unitConfig[unitId].type === 'land') {
                    totalAttackerLosses[unitId] = (totalAttackerLosses[unitId] || 0) + attackingUnits[unitId];
                }
            }
        }
    } else {
        const landBattle = resolveBattle(attackingUnits, defendingUnits, 'land', attackerPhalanx, attackerSupport, defenderPhalanx, defenderSupport);
        totalAttackerLosses = landBattle.attackerLosses;
        totalDefenderLosses = landBattle.defenderLosses;
        attackerWon = landBattle.attackerWon;
        if (landBattle.attackerWon) {
            plunder.wood = Math.floor(defendingResources.wood * 0.25);
            plunder.stone = Math.floor(defendingResources.stone * 0.25);
            plunder.silver = Math.floor(defendingResources.silver * 0.25);
        }
    }

    // Calculate wounded troops from attacker losses
    for (const unitId in totalAttackerLosses) {
        const losses = totalAttackerLosses[unitId];
        const woundedCount = Math.floor(losses * 0.15); // 15% of losses become wounded
        if (woundedCount > 0) {
            wounded[unitId] = woundedCount;
            totalAttackerLosses[unitId] = losses - woundedCount; // Reduce losses by the number of wounded
        }
    }

    return {
        attackerWon,
        attackerLosses: totalAttackerLosses,
        defenderLosses: totalDefenderLosses,
        plunder,
        wounded,
    };
}

/**
 * Resolves a scouting mission.
 * @param {object} targetGameState - The game state of the target city.
 * @param {number} attackingSilver - The amount of silver used for the scouting mission.
 * @returns {object} An object containing the scouting outcome.
 */
export function resolveScouting(targetGameState, attackingSilver) {
    const defenderCaveSilver = targetGameState.cave?.silver || 0; // Get silver in cave
    const defenderSecurityBonus = defenderCaveSilver * 2; // Example: defender gets 2x bonus from silver in cave
    const attackerEspionagePower = attackingSilver;

    // A simple probability model: higher attackerEspionagePower and lower defenderSecurityBonus increase success chance
    const successThreshold = 0.5; // Base chance to succeed without any silver
    const adjustedSuccessChance = (attackerEspionagePower + 1) / (attackerEspionagePower + defenderSecurityBonus + 1); // +1 to avoid division by zero and ensure some chance

    const success = Math.random() < adjustedSuccessChance && adjustedSuccessChance > successThreshold; // Only succeed if above a certain threshold

    if (success) {
        // If scouting is successful, return a report of target's resources and units
        return {
            success: true,
            message: 'Scouting successful! Detailed report obtained.',
            targetCityName: targetGameState.cityName,
            targetOwnerUsername: targetGameState.playerInfo?.username || 'Unknown', // Safely access username
            resources: { ...targetGameState.resources },
            units: { ...targetGameState.units },
            buildings: { ...targetGameState.buildings },
            god: targetGameState.god || 'None', // Include worshipped god
        };
    } else {
        // If scouting fails, attacker loses their silver (already deducted in movementmodal),
        // and defender gains some of the attacking silver if their cave silver was higher or it was a close call.
        // Let's say defender gains 50% of the attacking silver if scout fails.
        const silverGainedByDefender = Math.floor(attackingSilver * 0.5);
        return {
            success: false,
            message: 'Scouting failed! Your spy was detected.',
            silverGained: silverGainedByDefender
        };
    }
}
</file>

<file path="src/utils/travel.js">
/**
 * Calculates the Euclidean distance between two points (cities).
 * @param {object} cityA - The starting city with x, y coordinates.
 * @param {object} cityB - The destination city with x, y coordinates.
 * @returns {number} The distance between the two cities in map tiles.
 */
export function calculateDistance(cityA, cityB) {
    if (!cityA || !cityB) return 0;
    const dx = cityA.x - cityB.x;
    const dy = cityA.y - cityB.y;
    return Math.sqrt(dx * dx + dy * dy);
}

/**
 * Calculates the travel time in seconds based on distance and speed.
 * @param {number} distance - The distance to travel in map tiles.
 * @param {number} speed - The speed of the unit in tiles per hour.
 * @returns {number} The travel time in seconds.
 */
export function calculateTravelTime(distance, speed) {
    if (speed <= 0) return Infinity;
    const hours = distance / speed;
    return hours * 3600; // Convert hours to seconds
}

/**
 * Formats a duration in seconds into a readable HH:MM:SS format.
 * @param {number} totalSeconds - The total seconds to format.
 * @returns {string} The formatted time string.
 */
export function formatTravelTime(totalSeconds) {
    if (totalSeconds === Infinity) return 'N/A';
    if (isNaN(totalSeconds)) return 'Invalid Time';

    const hours = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor((totalSeconds % 3600) / 60);
    const seconds = Math.floor(totalSeconds % 60);

    const pad = (num) => num.toString().padStart(2, '0');

    return `${pad(hours)}:${pad(minutes)}:${pad(seconds)}`;
}
</file>

<file path="src/utils/worldGeneration.js">
export const generateIslands = (width, height, count) => {
    const islands = [];
    const minMargin = 4;
    const maxMargin = 8;
    const maxAttempts = 20;

    const checkCollision = (newIsland, existingIslands) => {
        for (const existing of existingIslands) {
            const distance = Math.sqrt(
                Math.pow(newIsland.x - existing.x, 2) +
                Math.pow(newIsland.y - existing.y, 2)
            );
            const margin = minMargin + Math.random() * (maxMargin - minMargin);
            if (distance < newIsland.radius + existing.radius + margin) {
                return true;
            }
        }
        return false;
    };

    for (let i = 0; i < count; i++) {
        let island = {};
        let hasCollision = true;
        let attempts = 0;

        while (hasCollision && attempts < maxAttempts) {
            const radius = Math.random() * 3 + 4; // Radius between 4 and 7 tiles
            island = {
                id: `island-${Date.now()}-${i}`,
                name: `Island ${i + 1}`,
                x: Math.floor(Math.random() * (width - radius * 2)) + radius,
                y: Math.floor(Math.random() * (height - radius * 2)) + radius,
                radius: radius,
            };
            hasCollision = checkCollision(island, islands);
            attempts++;
        }

        if (!hasCollision) {
            islands.push(island);
        }
    }
    return islands;
};

export const generateCitySlots = (islands, worldWidth, worldHeight) => {
    const citySlots = {};
    const tempGrid = Array(worldHeight).fill(null).map(() => Array(worldWidth).fill(false));

    // First, map out all land tiles
    islands.forEach(island => {
        const centerX = Math.round(island.x);
        const centerY = Math.round(island.y);
        for (let i = -Math.floor(island.radius); i <= Math.ceil(island.radius); i++) {
            for (let j = -Math.floor(island.radius); j <= Math.ceil(island.radius); j++) {
                if (i * i + j * j <= island.radius * island.radius) {
                    const x = centerX + j;
                    const y = centerY + i;
                    if (y >= 0 && y < worldHeight && x >= 0 && x < worldWidth) {
                        tempGrid[y][x] = true;
                    }
                }
            }
        }
    });

    // Then, identify and create slots on coastal tiles
    islands.forEach(island => {
        const coastalTiles = [];
        const centerX = Math.round(island.x);
        const centerY = Math.round(island.y);

        for (let i = -Math.floor(island.radius); i <= Math.ceil(island.radius); i++) {
            for (let j = -Math.floor(island.radius); j <= Math.ceil(island.radius); j++) {
                if (i * i + j * j <= island.radius * island.radius) {
                    const x = centerX + j;
                    const y = centerY + i;
                    if (y >= 0 && y < worldHeight && x >= 0 && x < worldWidth && tempGrid[y][x]) {
                        const neighbors = [[y - 1, x], [y + 1, x], [y, x - 1], [y, x + 1]];
                        let isCoastal = false;
                        for (const [ny, nx] of neighbors) {
                            if (ny < 0 || ny >= worldHeight || nx < 0 || nx >= worldWidth || !tempGrid[ny][nx]) {
                                isCoastal = true;
                                break;
                            }
                        }
                        if (isCoastal) coastalTiles.push({ x, y });
                    }
                }
            }
        }

        coastalTiles.forEach((slot, index) => {
            const slotId = `${island.id}-slot-${index}`;
            citySlots[slotId] = {
                islandId: island.id,
                x: slot.x,
                y: slot.y,
                ownerId: null,
                cityName: 'Unclaimed',
                ownerEmail: null,
                ownerUsername: null,
                ownerFaction: null
            };
        });
    });

    return citySlots;
};

function generateVillageTroops(level) {
    // All villages start at level 1, so we only need level 1 troop logic here.
    // The shared getVillageTroops function in combat.js handles higher levels for upgrades.
    return { swordsman: 15, archer: 10 };
}

export const generateFarmingVillages = (islands, citySlots, worldWidth, worldHeight) => {
    const villages = {};
    const occupiedSlots = new Set(Object.values(citySlots).map(slot => `${slot.x},${slot.y}`));
    const landTilesByIsland = new Map();

    // An array of the different demand cooldowns in seconds.
    const demandCooldowns = [
        300,    // 5 minutes
        1200,   // 20 minutes
        5400,   // 1 hour 30 minutes
        14400   // 4 hours
    ];

    islands.forEach(island => {
        landTilesByIsland.set(island.id, []);
        const centerX = Math.round(island.x);
        const centerY = Math.round(island.y);
        for (let i = -Math.floor(island.radius); i <= Math.ceil(island.radius); i++) {
            for (let j = -Math.floor(island.radius); j <= Math.ceil(island.radius); j++) {
                if (i * i + j * j <= island.radius * island.radius) {
                    const x = centerX + j;
                    const y = centerY + i;
                    if (y >= 0 && y < worldHeight && x >= 0 && x < worldWidth) {
                        landTilesByIsland.get(island.id).push({ x, y });
                    }
                }
            }
        }
    });

    landTilesByIsland.forEach((tiles, islandId) => {
        const availableTiles = tiles.filter(tile => !occupiedSlots.has(`${tile.x},${tile.y}`));
        const numVillages = Math.min(availableTiles.length, 5); // Set to a fixed 5 villages per island

        for (let i = 0; i < numVillages; i++) {
            if (availableTiles.length === 0) break;

            const tileIndex = Math.floor(Math.random() * availableTiles.length);
            const tile = availableTiles[tileIndex];
            availableTiles.splice(tileIndex, 1);
            occupiedSlots.add(`${tile.x},${tile.y}`);

            const villageId = `v${islandId}-${i}`;
            const level = 1; // All villages start at level 1
            
            // Select a random cooldown from the array
            const randomCooldown = demandCooldowns[Math.floor(Math.random() * demandCooldowns.length)];

            // Define trade properties
            const resources = ['wood', 'stone', 'silver'];
            let demands = resources.splice(Math.floor(Math.random() * resources.length), 1)[0];
            let supplies = resources.splice(Math.floor(Math.random() * resources.length), 1)[0];


            villages[villageId] = {
                id: villageId,
                x: tile.x,
                y: tile.y,
                islandId: islandId,
                name: `Farming Village ${villageId}`,
                level: level,
                demandYield: {
                    wood: level * 50,
                    stone: level * 50,
                    silver: level * 20,
                },
                resources: { wood: 500, stone: 500, silver: 500 },
                maxResources: 1000 + level * 200,
                lastDemandTime: 0,
                demandCooldown: randomCooldown,
                troops: generateVillageTroops(level),
                tradeRatio: 1.25,
                demands: demands,
                supplies: supplies
            };
        }
    });

    return villages;
};
</file>

<file path="src/App.js">
import React, { useState } from 'react';
import { useAuth } from './contexts/AuthContext';
import { GameProvider, useGame } from './contexts/GameContext';
import AuthScreen from './components/AuthScreen';
import SelectionScreen from './components/SelectionScreen';
import Game from './components/Game';
import WorldSelectionScreen from './components/WorldSelectionScreen';

const GameController = ({ onBackToWorlds }) => {
    const { playerHasChosenFaction, worldState, loading: gameLoading } = useGame();

    if (gameLoading) {
        return <div className="text-white text-center p-10">Loading World Data...</div>;
    }

    if (!worldState) {
        return (
            <div className="text-white text-center p-10">
                <p>Error: Could not load the selected world.</p>
                <button onClick={onBackToWorlds} className="btn btn-primary mt-4">Back to World Selection</button>
            </div>
        );
    }

    if (playerHasChosenFaction) {
        return <Game onBackToWorlds={onBackToWorlds} />;
    }
    
    return <SelectionScreen />;
};


function App() {
    const [selectedWorldId, setSelectedWorldId] = useState(null);
    const { currentUser, loading: authLoading } = useAuth();

    if (authLoading) {
        return <div className="text-white text-center p-10">Authenticating...</div>;
    }

    if (!currentUser) {
        return <AuthScreen />;
    }

    if (selectedWorldId) {
        return (
            <GameProvider worldId={selectedWorldId}>
                <GameController onBackToWorlds={() => setSelectedWorldId(null)} />
            </GameProvider>
        );
    }
    
    return <WorldSelectionScreen onWorldSelected={setSelectedWorldId} />;
}

export default App;
</file>

<file path="src/index.css">
@import url('https://fonts.googleapis.com/css2?family=IM+Fell+English+SC&family=Inter:wght@400;500;700&display=swap');
@import url('https://fonts.googleapis.com/css2?family=Kalam:wght@400;700&display=swap'); /* Keep Kalam font for messaging */

@tailwind base;
@tailwind components;
@tailwind utilities;

body {
    font-family: 'Inter', sans-serif;
}

.font-title {
    font-family: 'IM Fell English SC', serif;
}

/* --- General Components & Buttons --- */
.btn {
    @apply transition-all duration-200;
}
.btn:hover {
    @apply transform scale-105;
}
.btn-primary {
    @apply bg-gray-700 text-gray-200 border border-gray-600 rounded-lg;
}
.btn-primary:hover {
    @apply bg-gray-600;
}
.btn-confirm {
    @apply bg-green-600 text-white font-bold rounded-lg;
}
.btn-confirm:hover {
    @apply bg-green-500;
}
.btn-upgrade {
    @apply bg-gradient-to-r from-gray-500 to-gray-600 text-white font-bold border border-gray-400 rounded-lg;
}
.btn-upgrade:hover {
    @apply from-gray-600 to-gray-700;
}
.btn-disabled {
    @apply bg-gray-600 cursor-not-allowed opacity-60 rounded-lg;
}
.btn-danger {
    @apply bg-red-600 text-white font-bold rounded-lg;
}
.btn-danger:hover {
    @apply bg-red-500;
}

.selection-card {
    @apply bg-gray-800 border-2 border-gray-700 cursor-pointer transition-all duration-200 rounded-lg p-4;
}
.selection-card.selected {
    @apply border-blue-500 transform scale-105 shadow-lg;
}

.resource-icon {
    @apply w-6 h-6 mr-2;
}

/* --- Layout Components --- */

.sidebar {
    @apply w-56 bg-gray-800 p-4 flex-shrink-0 flex flex-col border-r border-gray-700;
}

.sidebar-button {
    @apply w-full text-left p-3 rounded-lg text-gray-300 hover:bg-gray-700 transition-colors duration-200 mb-2 font-semibold;
}

.main-content {
    @apply flex-grow relative;
}

.nav-button {
    @apply bg-gray-700 text-gray-200 border border-gray-600 rounded-lg px-4 py-2 font-semibold transition-all duration-200;
}
.nav-button:hover {
    @apply bg-gray-600 transform scale-105;
}

/* --- Glowing Effect for Reports Button --- */
.glowing-border {
    animation: glowing-border-animation 2s infinite;
    border: 1px solid transparent; /* Base border */
}

@keyframes glowing-border-animation {
    0% {
        border-color: #fde047;
        box-shadow: 0 0 3px #fde047;
    }
    50% {
        border-color: #fef08a;
        box-shadow: 0 0 15px #fef08a, 0 0 5px #fef08a inset;
    }
    100% {
        border-color: #fde047;
        box-shadow: 0 0 3px #fde047;
    }
}


/* --- Map & Tile Styles --- */

.map-viewport {
    @apply absolute inset-0 w-full h-full cursor-grab bg-blue-800 overflow-hidden;
}
.map-viewport:active {
    @apply cursor-grabbing;
}

.map-border {
    @apply absolute bg-red-500 pointer-events-none z-40 transition-opacity duration-200;
}
.map-border.top { @apply top-0 left-0 right-0 h-1; }
.map-border.bottom { @apply bottom-0 left-0 right-0 h-1; }
.map-border.left { @apply top-0 bottom-0 left-0 w-1; }
.map-border.right { @apply top-0 bottom-0 right-0 w-1; }

.map-grid {
    @apply grid;
}

.map-tile {
    @apply w-24 h-24 flex items-center justify-center relative;
}

/* Generic tooltip for all map objects */
.map-object-tooltip {
    @apply invisible absolute w-40 bg-gray-900 text-white text-center rounded-md py-1 px-2 z-30 bottom-full left-1/2 -translate-x-1/2 mb-2 opacity-0 transition-opacity;
}

/* City Slot Styles */
.city-slot {
    @apply w-6 h-6 rounded-full m-1 cursor-pointer relative transition-transform duration-150;
}
.city-slot:hover {
    @apply scale-125 ring-2 ring-white z-20;
}
.city-slot:hover .map-object-tooltip {
    @apply visible opacity-100;
}
.empty-slot {
    @apply bg-gray-500 border border-dashed border-gray-400;
}
.my-city {
    @apply bg-yellow-400 border-2 border-yellow-200;
}
.other-city {
    @apply bg-red-500 border-2 border-red-300;
}
.alliance-city {
    @apply bg-blue-500 border-2 border-blue-300;
}
.dummy-city-plot {
    @apply bg-purple-500 border-2 border-purple-300;
}
.dummy-placement-plot {
    @apply bg-gray-500 border-2 border-dashed border-yellow-400 cursor-crosshair animate-pulse;
}

/* Farming Village Styles */
.village-slot {
    @apply w-3 h-3 rounded-full m-1 cursor-pointer relative transition-transform duration-150; /* Makes it a small dot */
}
.village-slot:hover {
    @apply scale-150 ring-2 ring-white z-20;
}
.village-slot:hover .map-object-tooltip {
    @apply visible opacity-100;
}
.neutral-village {
    @apply bg-gray-300 border border-gray-500;
}
.my-village {
    @apply bg-blue-500 border border-blue-300;
}
.other-village-plot { /* A village owned by another player */
    @apply bg-red-600 border border-red-400;
}

/* --- Auth Card Flip --- */
.perspective {
    perspective: 1000px;
}
.auth-card {
    transition: transform 0.8s;
    transform-style: preserve-3d;
    position: relative;
    width: 100%;
    max-width: 448px; /* max-w-md */
    min-height: 550px;
}
.auth-card.flipped {
    transform: rotateY(180deg);
}
.auth-card-face {
    position: absolute;
    width: 100%;
    height: 100%;
    backface-visibility: hidden;
    -webkit-backface-visibility: hidden;
}
.auth-card-back {
    transform: rotateY(180deg);
}

/* --- City View --- */
.city-viewport {
    width: 100%;
    height: 100%;
    cursor: grab;
    overflow: hidden;
    position: relative;
}
.city-viewport:active {
    cursor: grabbing;
}
.city-grid {
    flex-grow: 1;
    display: grid;
    height: 100%;
    width: 100%;
    grid-template-columns: repeat(8, 1fr);
    grid-template-rows: repeat(8, 1fr);
    gap: 0.75rem;
    grid-template-areas:
        "wall wall wall wall wall wall wall wall"
        ". timber timber senate senate quarry quarry ."
        "silver silver warehouse warehouse market market . ."
        "barracks barracks farm farm . . academy academy"
        "cave cave temple temple . . . ."
        "shipyard shipyard . . . . . ."
        ". . . . . . . ."
        ". . . . . . . .";
    background: linear-gradient(to bottom, 
        #2a623d 0%,
        #2a623d 65%,
        #1e3a8a 65%,
        #1e3a8a 100%
    );
    padding: 1.5rem;
    position: relative;
}

/* Building Plot Styles */
.building-plot {
    border: 2px solid rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    color: white;
    cursor: pointer;
    transition: all 0.2s ease-in-out;
    background-color: rgba(0, 0, 0, 0.3);
    position: relative;
    overflow: hidden;
    grid-area: var(--grid-area);
}
.building-plot::before {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(to top, rgba(0,0,0,0.7) 0%, rgba(0,0,0,0) 50%, rgba(0,0,0,0.7) 100%);
}
.building-plot:hover {
    transform: translateY(-4px) scale(1.03);
    border-color: #f0e0c0;
    box-shadow: 0 0 25px rgba(255, 235, 192, 0.5);
}
.building-plot-empty {
    border: 2px dashed rgba(255, 255, 255, 0.2);
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s ease-in-out;
    background-color: rgba(0, 0, 0, 0.2);
}
.building-plot-empty:hover {
    background-color: rgba(255, 255, 255, 0.1);
    border-color: rgba(255, 255, 255, 0.4);
}

/* Specific Building Styles */
#plot-city_wall { min-height: 60px; }
#plot-senate { border: 4px solid #a17c48; border-radius: 12px; }
#plot-shipyard {
    align-self: end;
    min-height: 120px;
    border: 3px solid #6b4a2b;
    border-top-left-radius: 40px;
    border-top-right-radius: 40px;
    background: linear-gradient(to bottom, #5d4037 0%, #5d4037 60%, #1e3a8a 60%, #1e3a8a 100%);
}
#plot-temple { clip-path: polygon(50% 0%, 100% 25%, 100% 100%, 0 100%, 0 25%); background-color: #8d6e63; }
#plot-cave { background-color: #5d4037; }
#plot-farm { background-color: #689f38; grid-area: farm; }
#plot-timber_camp { grid-area: timber; }
#plot-quarry { grid-area: quarry; }
#plot-silver_mine { grid-area: silver; }
#plot-warehouse { grid-area: warehouse; }
#plot-market { grid-area: market; }
#plot-barracks { grid-area: barracks; }
#plot-academy { grid-area: academy; }

/* --- Overlays & Indicators --- */

.movement-indicator {
    position: absolute;
    width: 16px;
    height: 16px;
    border-radius: 50%;
    z-index: 30;
    filter: drop-shadow(0 0 5px currentColor);
    animation: pulse 1.5s infinite alternate;
}
@keyframes pulse {
    0% { transform: scale(1); opacity: 1; }
    100% { transform: scale(1.2); opacity: 0.8; }
}
.movement-indicator.outgoing { background-color: #ef4444; color: #ef4444; }
.movement-indicator.incoming { background-color: #10b981; color: #10b981; }

.troop-display-container {
    @apply absolute top-1/2 right-4 -translate-y-1/2 w-48 bg-gray-900 bg-opacity-80 p-2 flex flex-col gap-2 border-2 border-gray-600 rounded-lg shadow-lg z-20;
    backdrop-filter: blur(2px);
}
.troop-section {
    @apply bg-black bg-opacity-20 rounded p-1;
}
.troop-section-header {
    @apply text-yellow-500 font-bold text-sm text-center pb-1 mb-1 border-b border-gray-700;
}
.troop-grid {
    @apply grid grid-cols-3 gap-1.5;
}
.troop-item {
    @apply relative w-full aspect-square bg-gray-700 rounded-md overflow-hidden border border-gray-500 hover:border-yellow-400 transition-all;
}
.troop-image {
    @apply w-full h-full object-cover;
}
.troop-count {
    @apply absolute bottom-0 right-1 text-white font-bold text-base;
    text-shadow: 1px 1px 3px rgba(0, 0, 0, 1);
}
.hide-number-spinners::-webkit-outer-spin-button,
.hide-number-spinners::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0; /* Important to remove default margin that comes with appearance */
}

/* Hide number input spinners for Firefox */
.hide-number-spinners[type='number'] {
  -moz-appearance: textfield; /* Firefox-specific property */
}

/* Ensure default appearance is removed for other potential cases */
.hide-number-spinners {
  appearance: none;
}
</file>

<file path="src/index.js">
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import { AuthProvider } from './contexts/AuthContext';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <AuthProvider>
      <div className="bg-gray-900 text-white min-h-screen font-sans">
        <App />
      </div>
    </AuthProvider>
  </React.StrictMode>
);
</file>

<file path=".firebaserc">
{
  "projects": {
    "default": "grepollike"
  }
}
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# vitepress build output
**/.vitepress/dist

# vitepress cache directory
**/.vitepress/cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*
</file>

<file path="firebase.json">
{
  "functions": [
    {
      "source": "functions",
      "codebase": "default",
      "ignore": [
        "node_modules",
        ".git",
        "firebase-debug.log",
        "firebase-debug.*.log",
        "*.local"
      ],
      "predeploy": [
        "npm --prefix \"$RESOURCE_DIR\" run lint"
      ]
    }
  ]
}
</file>

<file path="package.json">
{
  "name": "grepolis-clone",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@testing-library/jest-dom": "^5.17.0",
    "@testing-library/react": "^13.4.0",
    "@testing-library/user-event": "^13.5.0",
    "firebase": "^10.12.2",
    "framer-motion": "^12.23.9",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-scripts": "5.0.1",
    "web-vitals": "^2.1.4"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "tailwindcss": "^3.4.17"
  }
}
</file>

<file path="tailwind.config.js">
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./src/**/*.{js,jsx,ts,tsx}",
  ],
  theme: {
    extend: {
      fontFamily: {
        'sans': ['Inter', 'sans-serif'],
        'title': ['"IM Fell English SC"', 'serif'],
      },
      colors: {
        // You can define custom colors here if you want
      }
    },
  },
  plugins: [],
}
</file>

<file path="todo.txt">
Ruins around the world to give you hidden researches.

Monuments that you have to sacrifice city lvls that gives op boosts, the others can also steal it from you.

Add hospital and wounded troops

Add mythical troops and special building for them

Think of a way to do leaderboard,

Add forum

Remake movement tab

Add population to resource buildings to produce more resources

Make the travel time smaller, a lot smaller for scouting and trading

add cities inside the island

do mythic troops of the gods

make it so you can conquer other cities

different troops for different nationalities

add a request system

random names for villages

make market and adjust the trades accordingly

add invitation system to the alliance

add alliance settings
</file>

</files>
